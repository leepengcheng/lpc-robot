{
    "simRRS1.REVERSE_MOTION": {
        "body": "simRRS1.REVERSE_MOTION(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.REVERSE_MOTION", 
        "description": "int status= simRRS1.REVERSE_MOTION(bitstring2 rcsHandle)"
    }, 
    "sim.filtercomponent_subtractfrombuffer1": {
        "body": "sim.filtercomponent_subtractfrombuffer1", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_subtractfrombuffer1", 
        "description": "Constants"
    }, 
    "simB0.destroyPublisher": {
        "body": "simB0.destroyPublisher(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "simB0.destroyPublisher", 
        "description": "simB0.destroyPublisher(string handle)"
    }, 
    "sim.vortex_joint_lowerlimitrestitution": {
        "body": "sim.vortex_joint_lowerlimitrestitution", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_lowerlimitrestitution", 
        "description": "Constants"
    }, 
    "sim.newton_body_bitcoded": {
        "body": "sim.newton_body_bitcoded", 
        "scope": "source.lua", 
        "prefix": "sim.newton_body_bitcoded", 
        "description": "Constants"
    }, 
    "simOMPL.simplifyPath": {
        "body": "simOMPL.simplifyPath(${0:taskHandle},${1:maxSimplificationTime=-1.0})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.simplifyPath", 
        "description": "number result = simOMPL.simplifyPath(number taskHandle,number maxSimplificationTime=-1.0)"
    }, 
    "package.preload": {
        "body": "package.preload(${0:...})", 
        "scope": "source.lua", 
        "prefix": "package.preload", 
        "description": "5.1,5.2,5.3\n\npackage.preload"
    }, 
    "sim.boolparam_force_calcstruct_all": {
        "body": "sim.boolparam_force_calcstruct_all", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_force_calcstruct_all", 
        "description": "Constants"
    }, 
    "sim.checkOctreePointOccupancy": {
        "body": "sim.checkOctreePointOccupancy(${0:octreeHandle},${1:options},${2:points})", 
        "scope": "source.lua", 
        "prefix": "sim.checkOctreePointOccupancy", 
        "description": "number result,number tag,number locationLow,number locationHigh = sim.checkOctreePointOccupancy(number octreeHandle,number options,table points)Checks whether the provided points collide with the octree voxels. See also sim.insertVoxelsIntoOctree and the other octree related functions. octreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the points specified as X/Y/Z coordinatesptCnt: the number of points contained in ptstag: a pointer to a tag value, receiving the tag value of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL.location: a pointer to a uint64 value, which specifies the location of the voxel that collides with a single point. If several points are tested, then this pointer is ignored. Can be NULL. The location value is coded in following way:bit0 - bit5: the depth level of the voxel in the octree structure (1-63).bit6 - bit63: a triple bit-value for each depth level. triple bit-values represent the node location relative to the parent node:0: (-1,-1,-1)1: (+1,-1,-1)2: (-1,+1,-1)3: (+1,+1,-1)4: (-1,-1,+1)5: (+1,-1,+1)6: (-1,+1,+1)7: (+1,+1,+1)as an example, 0xE02 would indicate a depth level 2, with coordinates: (+1,+1,+1)*voxelSize*2+(-1,-1,-1)*voxelSize.reserved: reserved for future extensions. Set to NULL -1 if operation was not successful, 0 if the points do not collide with the voxels, 1 if the points collide with the voxels"
    }, 
    "simUI.curve_scatter_shape.triangle": {
        "body": "simUI.curve_scatter_shape.triangle", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_scatter_shape.triangle", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_dependencyfactor": {
        "body": "sim.vortex_joint_dependencyfactor", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_dependencyfactor", 
        "description": "Constants"
    }, 
    "simUI.getEditValue": {
        "body": "simUI.getEditValue(${0:handle},${1:id})", 
        "scope": "source.lua", 
        "prefix": "simUI.getEditValue", 
        "description": "string value = simUI.getEditValue(number handle,number id)"
    }, 
    "sim.childscriptattribute_automaticcascadingcalls": {
        "body": "sim.childscriptattribute_automaticcascadingcalls", 
        "scope": "source.lua", 
        "prefix": "sim.childscriptattribute_automaticcascadingcalls", 
        "description": "Constants"
    }, 
    "simRRS1.DEBUG": {
        "body": "simRRS1.DEBUG(${0:rcsHandle},${1:debugFlags},${2:opcodeSelect})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.DEBUG", 
        "description": "int status= simRRS1.DEBUG(bitstring2 rcsHandle,bitstring debugFlags,int opcodeSelect)"
    }, 
    "simUI.getColumnCount": {
        "body": "simUI.getColumnCount(${0:handle},${1:id})", 
        "scope": "source.lua", 
        "prefix": "simUI.getColumnCount", 
        "description": "number count = simUI.getColumnCount(number handle,number id)"
    }, 
    "sim.newton_joint_dependentobjectid": {
        "body": "sim.newton_joint_dependentobjectid", 
        "scope": "source.lua", 
        "prefix": "sim.newton_joint_dependentobjectid", 
        "description": "Constants"
    }, 
    "sim.boolparam_hierarchy_toolbarbutton_enabled": {
        "body": "sim.boolparam_hierarchy_toolbarbutton_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_hierarchy_toolbarbutton_enabled", 
        "description": "Constants"
    }, 
    "string.packsize": {
        "body": "string.packsize(${0:...})", 
        "scope": "source.lua", 
        "prefix": "string.packsize", 
        "description": "5.3\n\nstring.packsize (fmt)"
    }, 
    "sim.getStringParameter": {
        "body": "sim.getStringParameter(${0:parameter})", 
        "scope": "source.lua", 
        "prefix": "sim.getStringParameter", 
        "description": "string stringState = sim.getStringParameter(number parameter)Retrieves a string value. See the string parameter identifiers. See also sim.getBoolParameter, sim.getInt32Parameter, sim.getArrayParameter and sim.getFloatParameter. parameter: string parameter identifierparameter: string parameter identifier NULL if operation was not successful. Otherwise the string parameter. The user is in charge of releasing the returned buffer with simReleaseBuffer."
    }, 
    "sim.removeObject": {
        "body": "sim.removeObject(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.removeObject", 
        "description": "number result = sim.removeObject(number objectHandle)Removes an object from the scene. See also sim.removeModel.Threaded child scripts can only destroy objects that do not contain other scripts attached than itself.Object destruction always tries to destroy attached scripts before destroying the object itself. If a script tries to destroy the object it is attached to, then the object will first be destroyed, and the script destruction will be delayed. objectHandle: handle of the object to remove. sim_handle_all removes all objects from the sceneobjectHandle: handle of the object to remove. sim_handle_all removes all objects from the scene -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.createOctree": {
        "body": "sim.createOctree(${0:voxelSize},${1:options},${2:pointSize})", 
        "scope": "source.lua", 
        "prefix": "sim.createOctree", 
        "description": "number handle = sim.createOctree(number voxelSize,number options,number pointSize)Creates an empty octree. See also sim.removeObject and the other octree related functions. voxelSize: the size of the voxelsoptions: bit-coded:bit0 set (1): voxels have random colorsbit1 set (2): show octree structurebit2 set (4): show points instead of voxelsbit3 set (8): reserved. keep unsetbit4 set (16): color is emissivepointSize: the size of the points in pixels, when voxels are rendered with pointsreserved: reserved for future extensions. Set to NULLvoxelSize: the size of the voxelsoptions: bit-coded:bit0 set (1): voxels have random colorsbit1 set (2): show octree structurebit2 set (4): show points instead of voxelsbit3 set (8): reserved. keep unsetbit4 set (16): color is emissivepointSize: the size of the points in pixels, when voxels are rendered with pointsreserved: reserved for future extensions. Set to NULLvoxelSize: the size of the voxelsoptions: bit-coded:bit0 set (1): voxels have random colorsbit1 set (2): show octree structurebit2 set (4): show points instead of voxelsbit3 set (8): reserved. keep unsetbit4 set (16): color is emissivepointSize: the size of the points in pixels, when voxels are rendered with pointsreserved: reserved for future extensions. Set to NULLvoxelSize: the size of the voxelsoptions: bit-coded:bit0 set (1): voxels have random colorsbit1 set (2): show octree structurebit2 set (4): show points instead of voxelsbit3 set (8): reserved. keep unsetbit4 set (16): color is emissivepointSize: the size of the points in pixels, when voxels are rendered with pointsreserved: reserved for future extensions. Set to NULLvoxelSize: the size of the voxelsoptions: bit-coded:bit0 set (1): voxels have random colorsbit1 set (2): show octree structurebit2 set (4): show points instead of voxelsbit3 set (8): reserved. keep unsetbit4 set (16): color is emissivepointSize: the size of the points in pixels, when voxels are rendered with pointsreserved: reserved for future extensions. Set to NULLvoxelSize: the size of the voxelsoptions: bit-coded:bit0 set (1): voxels have random colorsbit1 set (2): show octree structurebit2 set (4): show points instead of voxelsbit3 set (8): reserved. keep unsetbit4 set (16): color is emissivepointSize: the size of the points in pixels, when voxels are rendered with pointsreserved: reserved for future extensions. Set to NULLvoxelSize: the size of the voxelsoptions: bit-coded:bit0 set (1): voxels have random colorsbit1 set (2): show octree structurebit2 set (4): show points instead of voxelsbit3 set (8): reserved. keep unsetbit4 set (16): color is emissivepointSize: the size of the points in pixels, when voxels are rendered with pointsreserved: reserved for future extensions. Set to NULLvoxelSize: the size of the voxelsoptions: bit-coded:bit0 set (1): voxels have random colorsbit1 set (2): show octree structurebit2 set (4): show points instead of voxelsbit3 set (8): reserved. keep unsetbit4 set (16): color is emissivepointSize: the size of the points in pixels, when voxels are rendered with pointsreserved: reserved for future extensions. Set to NULLvoxelSize: the size of the voxelsoptions: bit-coded:bit0 set (1): voxels have random colorsbit1 set (2): show octree structurebit2 set (4): show points instead of voxelsbit3 set (8): reserved. keep unsetbit4 set (16): color is emissivepointSize: the size of the points in pixels, when voxels are rendered with pointsreserved: reserved for future extensions. Set to NULL -1 if operation was not successful, otherwise the handle of the octree"
    }, 
    "sim.vortex_global_constraintlinearkineticloss": {
        "body": "sim.vortex_global_constraintlinearkineticloss", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_global_constraintlinearkineticloss", 
        "description": "Constants"
    }, 
    "sim.vortex_body_autosleepangularaccelthreshold": {
        "body": "sim.vortex_body_autosleepangularaccelthreshold", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_autosleepangularaccelthreshold", 
        "description": "Constants"
    }, 
    "sim.intparam_dynamic_iteration_count": {
        "body": "sim.intparam_dynamic_iteration_count", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_dynamic_iteration_count", 
        "description": "Constants"
    }, 
    "sim.script_no_error": {
        "body": "sim.script_no_error", 
        "scope": "source.lua", 
        "prefix": "sim.script_no_error", 
        "description": "Constants"
    }, 
    "sim.joint_spherical_subtype": {
        "body": "sim.joint_spherical_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.joint_spherical_subtype", 
        "description": "Constants"
    }, 
    "sim.ik_gamma_constraint": {
        "body": "sim.ik_gamma_constraint", 
        "scope": "source.lua", 
        "prefix": "sim.ik_gamma_constraint", 
        "description": "Constants"
    }, 
    "sim.ode_global_constraintsolvingiterations": {
        "body": "sim.ode_global_constraintsolvingiterations", 
        "scope": "source.lua", 
        "prefix": "sim.ode_global_constraintsolvingiterations", 
        "description": "Constants"
    }, 
    "simB0.create": {
        "body": "simB0.create(${0:name})", 
        "scope": "source.lua", 
        "prefix": "simB0.create", 
        "description": "string handle simB0.create(string name)"
    }, 
    "sim.boolparam_fullscreen": {
        "body": "sim.boolparam_fullscreen", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_fullscreen", 
        "description": "Constants"
    }, 
    "simB0.setCompression": {
        "body": "simB0.setCompression(${0:handle},${1:compression_algorithm},${2:compression_level=-1})", 
        "scope": "source.lua", 
        "prefix": "simB0.setCompression", 
        "description": "simB0.setCompression(string handle,string compression_algorithm,number compression_level=-1)"
    }, 
    "sim.particle_ignoresgravity": {
        "body": "sim.particle_ignoresgravity", 
        "scope": "source.lua", 
        "prefix": "sim.particle_ignoresgravity", 
        "description": "Constants"
    }, 
    "sim.vortex_bodyfrictionmodel_neutral": {
        "body": "sim.vortex_bodyfrictionmodel_neutral", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_bodyfrictionmodel_neutral", 
        "description": "Constants"
    }, 
    "sim.drawing_overlay": {
        "body": "sim.drawing_overlay", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_overlay", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_p1damping": {
        "body": "sim.vortex_joint_p1damping", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p1damping", 
        "description": "Constants"
    }, 
    "sim.getSimulationTime": {
        "body": "sim.getSimulationTime()", 
        "scope": "source.lua", 
        "prefix": "sim.getSimulationTime", 
        "description": "number simulationTime = sim.getSimulationTime()Retrieves the current simulation time None negative value (-1.0) if operation not successful, otherwise the simulation time"
    }, 
    "sim.visionintparam_windowed_size_x": {
        "body": "sim.visionintparam_windowed_size_x", 
        "scope": "source.lua", 
        "prefix": "sim.visionintparam_windowed_size_x", 
        "description": "Constants"
    }, 
    "simUI.addCurveXYPoints": {
        "body": "simUI.addCurveXYPoints(${0:handle},${1:id},${2:name},${3:t},${4:x},${5:y})", 
        "scope": "source.lua", 
        "prefix": "simUI.addCurveXYPoints", 
        "description": "simUI.addCurveXYPoints(number handle,number id,string name,table t,table x,table y)"
    }, 
    "tostring": {
        "body": "tostring(${1:v})", 
        "scope": "source.lua", 
        "prefix": "tostring", 
        "description": "5.1,5.2,5.3\n\ntostring (v)"
    }, 
    "sim.getSystemTime": {
        "body": "sim.getSystemTime()", 
        "scope": "source.lua", 
        "prefix": "sim.getSystemTime", 
        "description": "number systemTime = sim.getSystemTime()Retrieves the system time. The system time is the time is seconds that elapsed since Windows or V-REP was started, depending on the system. See also sim.getSystemTimeInMs. None system time in seconds, or a negative value (-1.0) in case of an error"
    }, 
    "simCHAI3D.addConstraintSegment": {
        "body": "simCHAI3D.addConstraintSegment(${0:deviceIndex},${1:point},${2:segment},${3:Kp},${4:Kv},${5:Fmax})", 
        "scope": "source.lua", 
        "prefix": "simCHAI3D.addConstraintSegment", 
        "description": "number objectID = simCHAI3D.addConstraintSegment(number deviceIndex,table_3 point,table_3 segment,number Kp,number Kv,number Fmax)"
    }, 
    "sim.boolparam_headless": {
        "body": "sim.boolparam_headless", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_headless", 
        "description": "Constants"
    }, 
    "sim.customizationscriptcall_initialization": {
        "body": "sim.customizationscriptcall_initialization", 
        "scope": "source.lua", 
        "prefix": "sim.customizationscriptcall_initialization", 
        "description": "Constants"
    }, 
    "sim.camerafloatparam_pov_blur_distance": {
        "body": "sim.camerafloatparam_pov_blur_distance", 
        "scope": "source.lua", 
        "prefix": "sim.camerafloatparam_pov_blur_distance", 
        "description": "Constants"
    }, 
    "sim.handle_chain": {
        "body": "sim.handle_chain", 
        "scope": "source.lua", 
        "prefix": "sim.handle_chain", 
        "description": "Constants"
    }, 
    "sim.boolparam_ik_handling_enabled": {
        "body": "sim.boolparam_ik_handling_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_ik_handling_enabled", 
        "description": "Constants"
    }, 
    "sim.vortex_body_skinthickness": {
        "body": "sim.vortex_body_skinthickness", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_skinthickness", 
        "description": "Constants"
    }, 
    "sim.intparam_server_port_next": {
        "body": "sim.intparam_server_port_next", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_server_port_next", 
        "description": "Constants"
    }, 
    "sim.clearStringSignal": {
        "body": "sim.clearStringSignal(${0:signalName})", 
        "scope": "source.lua", 
        "prefix": "sim.clearStringSignal", 
        "description": "number clearCount = sim.clearStringSignal(string signalName)Clears a string signal (removes it). See also the other signal functions. signalName: name of the signal or NULL to clear all string signalssignalName: name of the signal or NULL to clear all string signals -1 if operation was not successful, otherwise the number of signals cleared"
    }, 
    "debug.setfenv": {
        "body": "debug.setfenv(${0:...})", 
        "scope": "source.lua", 
        "prefix": "debug.setfenv", 
        "description": "5.1\n\ndebug.setfenv (object, table)"
    }, 
    "sim.particle_spheres": {
        "body": "sim.particle_spheres", 
        "scope": "source.lua", 
        "prefix": "sim.particle_spheres", 
        "description": "Constants"
    }, 
    "sim.pathproperty_show_position": {
        "body": "sim.pathproperty_show_position", 
        "scope": "source.lua", 
        "prefix": "sim.pathproperty_show_position", 
        "description": "Constants"
    }, 
    "sim.joint_prismatic_subtype": {
        "body": "sim.joint_prismatic_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.joint_prismatic_subtype", 
        "description": "Constants"
    }, 
    "simROS.getParamInt": {
        "body": "simROS.getParamInt(${0:name},${1:defaultValue=0})", 
        "scope": "source.lua", 
        "prefix": "simROS.getParamInt", 
        "description": "bool exists,number value = simROS.getParamInt(string name,number defaultValue=0)"
    }, 
    "table.remove": {
        "body": "table.remove( ${1:list},${2: [pos,]} )", 
        "scope": "source.lua", 
        "prefix": "table.remove", 
        "description": "5.1,5.2,5.3\n\ntable.remove"
    }, 
    "sim.vortex_joint_p0frictionloss": {
        "body": "sim.vortex_joint_p0frictionloss", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p0frictionloss", 
        "description": "Constants"
    }, 
    "simOMPL.setup": {
        "body": "simOMPL.setup(${0:taskHandle})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.setup", 
        "description": "number result = simOMPL.setup(number taskHandle)"
    }, 
    "debug.traceback": {
        "body": "debug.traceback( ${1:[thread,]}${2:[message]}${3:[, level]} )", 
        "scope": "source.lua", 
        "prefix": "debug.traceback", 
        "description": "5.1,5.2,5.3\n\ndebug.traceback ([thread,] [message [, level]])"
    }, 
    "file:setvbuf": {
        "body": "file:setvbuf(${0:...})", 
        "scope": "source.lua", 
        "prefix": "file:setvbuf", 
        "description": "5.1,5.2,5.3\n\nfile:setvbuf (mode [, size])"
    }, 
    "sim.bullet_global_internalscalingfactor": {
        "body": "sim.bullet_global_internalscalingfactor", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_global_internalscalingfactor", 
        "description": "Constants"
    }, 
    "math.frexp": {
        "body": "math.frexp(${0:...})", 
        "scope": "source.lua", 
        "prefix": "math.frexp", 
        "description": "5.1,5.2\n\nmath.frexp (x)"
    }, 
    "simx.clearIntegerSignal": {
        "body": "simx.clearIntegerSignal(${0:clientId},${1:signalName})", 
        "scope": "source.lua", 
        "prefix": "simx.clearIntegerSignal", 
        "description": "number returnCode= simx.clearIntegerSignal(number clientId,string signalName)Clears an integer signal (removes it). See also simx.setIntegerSignal, simx.clearFloatSignal and simx.clearStringSignal. clientID: the client ID. refer to simx.start.signalName: name of the signal or an empty string to clear all integer signalsoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "sim.object_light_type": {
        "body": "sim.object_light_type", 
        "scope": "source.lua", 
        "prefix": "sim.object_light_type", 
        "description": "Constants"
    }, 
    "simUI.setCurrentTab": {
        "body": "simUI.setCurrentTab(${0:handle},${1:id},${2:index},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setCurrentTab", 
        "description": "simUI.setCurrentTab(number handle,number id,number index,bool suppressEvents=true)"
    }, 
    "sim.readCustomDataBlock": {
        "body": "sim.readCustomDataBlock(${0:objectHandle},${1:tagName})", 
        "scope": "source.lua", 
        "prefix": "sim.readCustomDataBlock", 
        "description": "string data = sim.readCustomDataBlock(number objectHandle,string tagName)Reads custom data that is stored inside of an object, a script or a scene (i.e. the data is part of the object, the script or the scene).  Reads also custom data for the application's currrent session. See also sim.writeCustomDataBlock, sim.readCustomDataBlockTags and the data packing/unpacking functions. objectHandle: handle of the object or script where the data is stored, or sim_handle_scene if the data is stored in the scene, or sim_handle_app if the data is stored in the application's current session.tagName: a string that identifies the data. dataSize: a pointer to an integer receiving the size of the returned buffer.objectHandle: handle of the object or script where the data is stored, or sim_handle_scene if the data is stored in the scene, or sim_handle_app if the data is stored in the application's current session.tagName: a string that identifies the data. dataSize: a pointer to an integer receiving the size of the returned buffer.objectHandle: handle of the object or script where the data is stored, or sim_handle_scene if the data is stored in the scene, or sim_handle_app if the data is stored in the application's current session.tagName: a string that identifies the data. dataSize: a pointer to an integer receiving the size of the returned buffer. the custom data block, or nil in case of an error (or if the data is not present). The user is in charge of releasing the returned buffer with simReleaseBuffer."
    }, 
    "simx.startSimulation": {
        "body": "simx.startSimulation(${0:clientId})", 
        "scope": "source.lua", 
        "prefix": "simx.startSimulation", 
        "description": "number returnCode= simx.startSimulation(number clientId)Requests a start of a simulation (or a resume of a paused simulation). This function is only executed by continuous remote API server services. See also simx.pauseSimulation and simx.stopSimulation. clientID: the client ID. refer to simx.start.operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot. returnCode: a remote API function return code"
    }, 
    "simx.getObjectVelocity": {
        "body": "simx.getObjectVelocity(${0:clientId},${1:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.getObjectVelocity", 
        "description": "number returnCode,table_3 linearVelocity,table_3 angularVelocity= simx.getObjectVelocity(number clientId,number objectHandle)Retrieves the linear and angular velocity of an object. See also simx.getObjectPosition, simx.getObjectOrientation and simx.getObjectGroupData. clientID: the client ID. refer to simx.start.objectHandle: handle of the objectoperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls) returnCode: a remote API function return codelinearVelocity: the linearVelocity (vx, vy, vz)angularVelocity: the angularVelocity (dAlpha, dBeta, dGamma)"
    }, 
    "simx.return_novalue_flag": {
        "body": "simx.return_novalue_flag", 
        "scope": "source.lua", 
        "prefix": "simx.return_novalue_flag", 
        "description": "Constants"
    }, 
    "sim.shapefloatparam_texture_scaling_y": {
        "body": "sim.shapefloatparam_texture_scaling_y", 
        "scope": "source.lua", 
        "prefix": "sim.shapefloatparam_texture_scaling_y", 
        "description": "Constants"
    }, 
    "sim.shapefloatparam_texture_scaling_x": {
        "body": "sim.shapefloatparam_texture_scaling_x", 
        "scope": "source.lua", 
        "prefix": "sim.shapefloatparam_texture_scaling_x", 
        "description": "Constants"
    }, 
    "package.loaders": {
        "body": "package.loaders(${0:...})", 
        "scope": "source.lua", 
        "prefix": "package.loaders", 
        "description": "5.1\n\npackage.loaders"
    }, 
    "sim.setStringSignal": {
        "body": "sim.setStringSignal(${0:signalName},${1:signalValue})", 
        "scope": "source.lua", 
        "prefix": "sim.setStringSignal", 
        "description": "number result = sim.setStringSignal(string signalName,string signalValue)Sets the value of a string signal. If that signal is not yet present, it is added. Signals created in the main script or in a child script are automatically cleared at simulation end. See also sim.getStringSignal, the other signal functions,  the data packing/unpacking functions and sim.persistentDataWrite. signalName: name of the signalsignalValue: value of the signal (which may contain any value, including embedded zeros)stringLength: the size of the string value.signalName: name of the signalsignalValue: value of the signal (which may contain any value, including embedded zeros)stringLength: the size of the string value.signalName: name of the signalsignalValue: value of the signal (which may contain any value, including embedded zeros)stringLength: the size of the string value. -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.intparam_stop_request_counter": {
        "body": "sim.intparam_stop_request_counter", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_stop_request_counter", 
        "description": "Constants"
    }, 
    "simUI.curve_style.step_right": {
        "body": "simUI.curve_style.step_right", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_style.step_right", 
        "description": "Constants"
    }, 
    "simB0.init": {
        "body": "simB0.init(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "simB0.init", 
        "description": "string name simB0.init(string handle)"
    }, 
    "sim.handleflag_greyscale": {
        "body": "sim.handleflag_greyscale", 
        "scope": "source.lua", 
        "prefix": "sim.handleflag_greyscale", 
        "description": "Constants"
    }, 
    "sim.vortex_body_restitutionthreshold": {
        "body": "sim.vortex_body_restitutionthreshold", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_restitutionthreshold", 
        "description": "Constants"
    }, 
    "sim.object_joint_type": {
        "body": "sim.object_joint_type", 
        "scope": "source.lua", 
        "prefix": "sim.object_joint_type", 
        "description": "Constants"
    }, 
    "sim.objectspecialproperty_detectable_laser": {
        "body": "sim.objectspecialproperty_detectable_laser", 
        "scope": "source.lua", 
        "prefix": "sim.objectspecialproperty_detectable_laser", 
        "description": "Constants"
    }, 
    "math.ldexp": {
        "body": "math.ldexp(${0:...})", 
        "scope": "source.lua", 
        "prefix": "math.ldexp", 
        "description": "5.1,5.2\n\nmath.ldexp (m, e)"
    }, 
    "simUI.setText": {
        "body": "simUI.setText(${0:handle},${1:id},${2:text},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setText", 
        "description": "simUI.setText(number handle,number id,string text,bool suppressEvents=true)"
    }, 
    "sim.getMechanismHandle": {
        "body": "sim.getMechanismHandle(${0:mechanismName})", 
        "scope": "source.lua", 
        "prefix": "sim.getMechanismHandle", 
        "description": "number mechanismHandle = sim.getMechanismHandle(string mechanismName)Retrieves the handle of a mechanism to be solved by the geometric constraint solver. The operation of this function depends on the current name suffix settings (see sim.getNameSuffix, sim.setNameSuffix, and the section on accessing general-type objects). See also sim.isHandleValid. mechanismName: name of the mechanismmechanismName: name of the mechanism Handle of the mechanism if operation was successful, -1 otherwise"
    }, 
    "sim.vortex_body_normalmangulararaxisfrictionmodel": {
        "body": "sim.vortex_body_normalmangulararaxisfrictionmodel", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_normalmangulararaxisfrictionmodel", 
        "description": "Constants"
    }, 
    "sim.setObjectFloatParameter": {
        "body": "sim.setObjectFloatParameter(${0:objectHandle},${1:parameterID},${2:parameter})", 
        "scope": "source.lua", 
        "prefix": "sim.setObjectFloatParameter", 
        "description": "number result = sim.setObjectFloatParameter(number objectHandle,number parameterID,number parameter)Sets a floating-point parameter of a scene object or calculation object. See also sim.getObjectFloatParameter, sim.setObjectInt32Parameter and sim.setObjectStringParameter objectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: parameter valueobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: parameter valueobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: parameter valueobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: parameter value -1 in case of an error, 0 if the parameter could not be set (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful"
    }, 
    "math.log": {
        "body": "math.log( ${1:x}${2:[, base]} )", 
        "scope": "source.lua", 
        "prefix": "math.log", 
        "description": "5.1,5.2,5.3\n\nmath.log"
    }, 
    "sim.navigation_camerazoomwheel": {
        "body": "sim.navigation_camerazoomwheel", 
        "scope": "source.lua", 
        "prefix": "sim.navigation_camerazoomwheel", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_proportionalmotorfriction": {
        "body": "sim.vortex_joint_proportionalmotorfriction", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_proportionalmotorfriction", 
        "description": "Constants"
    }, 
    "simOMPL.getPath": {
        "body": "simOMPL.getPath(${0:taskHandle})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.getPath", 
        "description": "number result,table states = simOMPL.getPath(number taskHandle)"
    }, 
    "version": {
        "body": "_VERSION", 
        "scope": "source.lua", 
        "prefix": "version", 
        "description": "_VERSION"
    }, 
    "sim.setEngineBoolParameter": {
        "body": "sim.setEngineBoolParameter(${0:paramId},${1:objectHandle},${2:boolParam})", 
        "scope": "source.lua", 
        "prefix": "sim.setEngineBoolParameter", 
        "description": "number result = sim.setEngineBoolParameter(number paramId,number objectHandle,boolean boolParam)Sets a bool-type physics engine property. You might have to call sim.resetDynamicObject for changes to take effect. See also the other engine properties setter and getter API functions. paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to set a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to set a global engine parameter. If NULL, then the objectHandle argument will be evaluated.val: the new property values.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to set a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to set a global engine parameter. If NULL, then the objectHandle argument will be evaluated.val: the new property values.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to set a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to set a global engine parameter. If NULL, then the objectHandle argument will be evaluated.val: the new property values.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to set a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to set a global engine parameter. If NULL, then the objectHandle argument will be evaluated.val: the new property values. 1 in case of success. This function call doesn't generate any error message."
    }, 
    "sim.writeTexture": {
        "body": "sim.writeTexture(${0:textureId},${1:options},${2:textureData},${3:posX=0},${4:posY=0},${5:sizeX=0},${6:sizeY=0},${7:interpol=0})", 
        "scope": "source.lua", 
        "prefix": "sim.writeTexture", 
        "description": "number result = sim.writeTexture(number textureId,number options,string textureData,number posX=0,number posY=0,number sizeX=0,number sizeY=0,number interpol=0)Overwrites a specific texture (or a portion of it) with RGB data. See also sim.getTextureId, sim.readTexture and sim.createTexture. textureId: the ID of the texture. See also simGetTextureId.options: bit-coded:bit0 reserved. Do not set.bit1 reserved. Do not set.bit2 set (4)=only an elliptical/circular portion of the texture data will be written.textureData: RGB data to write onto the texture. Each pixel is represented with 3 bytes (0-255).posX / posY: the x/y position where to copy the RGB data. Set to 0/0 to overwrite the full texturesizeX / sizeY: the x/y size of the RGB data. Set to 0/0 to overwrite the full textureinterpolation: the fade or interpolation factor. 0 for no fade.textureId: the ID of the texture. See also simGetTextureId.options: bit-coded:bit0 reserved. Do not set.bit1 reserved. Do not set.bit2 set (4)=only an elliptical/circular portion of the texture data will be written.textureData: RGB data to write onto the texture. Each pixel is represented with 3 bytes (0-255).posX / posY: the x/y position where to copy the RGB data. Set to 0/0 to overwrite the full texturesizeX / sizeY: the x/y size of the RGB data. Set to 0/0 to overwrite the full textureinterpolation: the fade or interpolation factor. 0 for no fade.textureId: the ID of the texture. See also simGetTextureId.options: bit-coded:bit0 reserved. Do not set.bit1 reserved. Do not set.bit2 set (4)=only an elliptical/circular portion of the texture data will be written.textureData: RGB data to write onto the texture. Each pixel is represented with 3 bytes (0-255).posX / posY: the x/y position where to copy the RGB data. Set to 0/0 to overwrite the full texturesizeX / sizeY: the x/y size of the RGB data. Set to 0/0 to overwrite the full textureinterpolation: the fade or interpolation factor. 0 for no fade.textureId: the ID of the texture. See also simGetTextureId.options: bit-coded:bit0 reserved. Do not set.bit1 reserved. Do not set.bit2 set (4)=only an elliptical/circular portion of the texture data will be written.textureData: RGB data to write onto the texture. Each pixel is represented with 3 bytes (0-255).posX / posY: the x/y position where to copy the RGB data. Set to 0/0 to overwrite the full texturesizeX / sizeY: the x/y size of the RGB data. Set to 0/0 to overwrite the full textureinterpolation: the fade or interpolation factor. 0 for no fade.textureId: the ID of the texture. See also simGetTextureId.options: bit-coded:bit0 reserved. Do not set.bit1 reserved. Do not set.bit2 set (4)=only an elliptical/circular portion of the texture data will be written.textureData: RGB data to write onto the texture. Each pixel is represented with 3 bytes (0-255).posX / posY: the x/y position where to copy the RGB data. Set to 0/0 to overwrite the full texturesizeX / sizeY: the x/y size of the RGB data. Set to 0/0 to overwrite the full textureinterpolation: the fade or interpolation factor. 0 for no fade.textureId: the ID of the texture. See also simGetTextureId.options: bit-coded:bit0 reserved. Do not set.bit1 reserved. Do not set.bit2 set (4)=only an elliptical/circular portion of the texture data will be written.textureData: RGB data to write onto the texture. Each pixel is represented with 3 bytes (0-255).posX / posY: the x/y position where to copy the RGB data. Set to 0/0 to overwrite the full texturesizeX / sizeY: the x/y size of the RGB data. Set to 0/0 to overwrite the full textureinterpolation: the fade or interpolation factor. 0 for no fade.textureId: the ID of the texture. See also simGetTextureId.options: bit-coded:bit0 reserved. Do not set.bit1 reserved. Do not set.bit2 set (4)=only an elliptical/circular portion of the texture data will be written.textureData: RGB data to write onto the texture. Each pixel is represented with 3 bytes (0-255).posX / posY: the x/y position where to copy the RGB data. Set to 0/0 to overwrite the full texturesizeX / sizeY: the x/y size of the RGB data. Set to 0/0 to overwrite the full textureinterpolation: the fade or interpolation factor. 0 for no fade.textureId: the ID of the texture. See also simGetTextureId.options: bit-coded:bit0 reserved. Do not set.bit1 reserved. Do not set.bit2 set (4)=only an elliptical/circular portion of the texture data will be written.textureData: RGB data to write onto the texture. Each pixel is represented with 3 bytes (0-255).posX / posY: the x/y position where to copy the RGB data. Set to 0/0 to overwrite the full texturesizeX / sizeY: the x/y size of the RGB data. Set to 0/0 to overwrite the full textureinterpolation: the fade or interpolation factor. 0 for no fade.textureId: the ID of the texture. See also simGetTextureId.options: bit-coded:bit0 reserved. Do not set.bit1 reserved. Do not set.bit2 set (4)=only an elliptical/circular portion of the texture data will be written.textureData: RGB data to write onto the texture. Each pixel is represented with 3 bytes (0-255).posX / posY: the x/y position where to copy the RGB data. Set to 0/0 to overwrite the full texturesizeX / sizeY: the x/y size of the RGB data. Set to 0/0 to overwrite the full textureinterpolation: the fade or interpolation factor. 0 for no fade. -1 in case of an error."
    }, 
    "simx.getVisionSensorImage": {
        "body": "simx.getVisionSensorImage(${0:clientId},${1:sensorHandle},${2:options})", 
        "scope": "source.lua", 
        "prefix": "simx.getVisionSensorImage", 
        "description": "number returnCode,string image,table_2 resolution= simx.getVisionSensorImage(number clientId,number sensorHandle,number options)Retrieves the image of a vision sensor. The returned data doesn't make sense if sim.handleVisionSensor wasn't called previously (sim.handleVisionSensor is called by default in the main script if the vision sensor is not tagged as explicit handling). Use the simx.getLastCmdTime function to verify the freshness of the retrieved data. See also simx.setVisionSensorImage, simx.getVisionSensorDepthBuffer and simx.readVisionSensor. clientID: the client ID. refer to simx.start.sensorHandle: handle of the vision sensoroptions: image options, bit-coded:operationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls) returnCode: a remote API function return codeimage: the image dataresolution: the image"
    }, 
    "sim.boolparam_realtime_simulation": {
        "body": "sim.boolparam_realtime_simulation", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_realtime_simulation", 
        "description": "Constants"
    }, 
    "sim.getObjectsInTree": {
        "body": "sim.getObjectsInTree(${0:treeBaseHandle},${1:objectType=sim_handle_all},${2:options=0})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectsInTree", 
        "description": "table objects = sim.getObjectsInTree(number treeBaseHandle,number objectType=sim_handle_all,number options=0)Retrieves object handles in a given hierarchy tree. See also sim.getObjects. treeBaseHandle: the handle of the object that describes  the hierarchy tree, or sim_handle_scene for all objects in the scene.objectType: the object type to retrieve or sim_handle_all for any type of object in the treeoptions: bit-coded:bit0 set (1): exclude the tree base from the returned arraybit1 set (2): include in the returned array only the object's first children. If treeBaseHandle is sim_handle_scene, then only parentless objects will be included.objectCount (out value): the number of returned object handlestreeBaseHandle: the handle of the object that describes  the hierarchy tree, or sim_handle_scene for all objects in the scene.objectType: the object type to retrieve or sim_handle_all for any type of object in the treeoptions: bit-coded:bit0 set (1): exclude the tree base from the returned arraybit1 set (2): include in the returned array only the object's first children. If treeBaseHandle is sim_handle_scene, then only parentless objects will be included.objectCount (out value): the number of returned object handlestreeBaseHandle: the handle of the object that describes  the hierarchy tree, or sim_handle_scene for all objects in the scene.objectType: the object type to retrieve or sim_handle_all for any type of object in the treeoptions: bit-coded:bit0 set (1): exclude the tree base from the returned arraybit1 set (2): include in the returned array only the object's first children. If treeBaseHandle is sim_handle_scene, then only parentless objects will be included.objectCount (out value): the number of returned object handlestreeBaseHandle: the handle of the object that describes  the hierarchy tree, or sim_handle_scene for all objects in the scene.objectType: the object type to retrieve or sim_handle_all for any type of object in the treeoptions: bit-coded:bit0 set (1): exclude the tree base from the returned arraybit1 set (2): include in the returned array only the object's first children. If treeBaseHandle is sim_handle_scene, then only parentless objects will be included.objectCount (out value): the number of returned object handlestreeBaseHandle: the handle of the object that describes  the hierarchy tree, or sim_handle_scene for all objects in the scene.objectType: the object type to retrieve or sim_handle_all for any type of object in the treeoptions: bit-coded:bit0 set (1): exclude the tree base from the returned arraybit1 set (2): include in the returned array only the object's first children. If treeBaseHandle is sim_handle_scene, then only parentless objects will be included.objectCount (out value): the number of returned object handlestreeBaseHandle: the handle of the object that describes  the hierarchy tree, or sim_handle_scene for all objects in the scene.objectType: the object type to retrieve or sim_handle_all for any type of object in the treeoptions: bit-coded:bit0 set (1): exclude the tree base from the returned arraybit1 set (2): include in the returned array only the object's first children. If treeBaseHandle is sim_handle_scene, then only parentless objects will be included.objectCount (out value): the number of returned object handles a pointer to an array containing object handles, or NULL in case of an error. The user is in charge of releasing the returned buffer with simReleaseBuffer."
    }, 
    "simx.callScriptFunction": {
        "body": "simx.callScriptFunction(${0:clientId},${1:scriptDescription},${2:scriptHandleOrType},${3:functionName},${4:inInts},${5:inFloats},${6:inStrings},${7:inBuffer})", 
        "scope": "source.lua", 
        "prefix": "simx.callScriptFunction", 
        "description": "number returnCode,table retInts,table retFloats,table retStrings,string retBuffer= simx.callScriptFunction(number clientId,string scriptDescription,number scriptHandleOrType,string functionName,table inInts,table inFloats,table inStrings,string inBuffer)Remotely calls a V-REP script function. When calling simulation scripts, then simulation must be running (and threaded scripts must still be running, i.e. not ended yet). Refer to this section for additional details. clientID: the client ID. refer to simx.start.scriptDescription: the name of the scene object where the script is attached to, or an empty string if the script has no associated scene object.scriptHandleOrType: the handle of the script, otherwise the type of the script:functionName: the name of the Lua function to call in the specified script.inInts: the input integer values that are handed over to the script function. Can be an empty table.inFloats: the input floating-point values that are handed over to the script function. Can be an empty table.inStrings: the input strings that are handed over to the script function. Can be an empty table.inBuffer: the input buffer that is handed over to the script function. Can be an empty string.operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return codeoutInts: the returned integer values.outFloats: the returned floating-point values.outStrings: the returned strings.outBuffer: the returned buffer."
    }, 
    "sim.boolparam_dynamics_handling_enabled": {
        "body": "sim.boolparam_dynamics_handling_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_dynamics_handling_enabled", 
        "description": "Constants"
    }, 
    "simUI.hide": {
        "body": "simUI.hide(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "simUI.hide", 
        "description": "simUI.hide(number handle)"
    }, 
    "sim.createPureShape": {
        "body": "sim.createPureShape(${0:primitiveType},${1:options},${2:sizes},${3:mass},${4:precision=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.createPureShape", 
        "description": "number objectHandle = sim.createPureShape(number primitiveType,number options,table_3 sizes,number mass,table_2 precision=nil)Creates a pure primitive shape. See also sim.createMeshShape, sim.createHeightfieldShape and sim.addParticleObject. primitiveType: 0 for a cuboid, 1 for a sphere, 2 for a cylinder and 3 for a coneoptions: Bit-coded: if bit0 is set (1), backfaces are culled. If bit1 is set (2), edges are visible. If bit2 is set (4), the shape appears smooth. If bit3 is set (8), the shape is respondable. If bit4 is set (16), the shape is static. If bit5 is set (32), the cylinder has open endssizes: 3 values indicating the size of the shapemass: the mass of the shapeprecision: 2 values that allow specifying the number of sides and faces of a cylinder or sphere. Can be NULL for default valuesprimitiveType: 0 for a cuboid, 1 for a sphere, 2 for a cylinder and 3 for a coneoptions: Bit-coded: if bit0 is set (1), backfaces are culled. If bit1 is set (2), edges are visible. If bit2 is set (4), the shape appears smooth. If bit3 is set (8), the shape is respondable. If bit4 is set (16), the shape is static. If bit5 is set (32), the cylinder has open endssizes: 3 values indicating the size of the shapemass: the mass of the shapeprecision: 2 values that allow specifying the number of sides and faces of a cylinder or sphere. Can be NULL for default valuesprimitiveType: 0 for a cuboid, 1 for a sphere, 2 for a cylinder and 3 for a coneoptions: Bit-coded: if bit0 is set (1), backfaces are culled. If bit1 is set (2), edges are visible. If bit2 is set (4), the shape appears smooth. If bit3 is set (8), the shape is respondable. If bit4 is set (16), the shape is static. If bit5 is set (32), the cylinder has open endssizes: 3 values indicating the size of the shapemass: the mass of the shapeprecision: 2 values that allow specifying the number of sides and faces of a cylinder or sphere. Can be NULL for default valuesprimitiveType: 0 for a cuboid, 1 for a sphere, 2 for a cylinder and 3 for a coneoptions: Bit-coded: if bit0 is set (1), backfaces are culled. If bit1 is set (2), edges are visible. If bit2 is set (4), the shape appears smooth. If bit3 is set (8), the shape is respondable. If bit4 is set (16), the shape is static. If bit5 is set (32), the cylinder has open endssizes: 3 values indicating the size of the shapemass: the mass of the shapeprecision: 2 values that allow specifying the number of sides and faces of a cylinder or sphere. Can be NULL for default valuesprimitiveType: 0 for a cuboid, 1 for a sphere, 2 for a cylinder and 3 for a coneoptions: Bit-coded: if bit0 is set (1), backfaces are culled. If bit1 is set (2), edges are visible. If bit2 is set (4), the shape appears smooth. If bit3 is set (8), the shape is respondable. If bit4 is set (16), the shape is static. If bit5 is set (32), the cylinder has open endssizes: 3 values indicating the size of the shapemass: the mass of the shapeprecision: 2 values that allow specifying the number of sides and faces of a cylinder or sphere. Can be NULL for default valuesprimitiveType: 0 for a cuboid, 1 for a sphere, 2 for a cylinder and 3 for a coneoptions: Bit-coded: if bit0 is set (1), backfaces are culled. If bit1 is set (2), edges are visible. If bit2 is set (4), the shape appears smooth. If bit3 is set (8), the shape is respondable. If bit4 is set (16), the shape is static. If bit5 is set (32), the cylinder has open endssizes: 3 values indicating the size of the shapemass: the mass of the shapeprecision: 2 values that allow specifying the number of sides and faces of a cylinder or sphere. Can be NULL for default values -1 if operation was not successful, otherwise the handle of the newly created shape"
    }, 
    "sim.vortex_joint_a1frictioncoeff": {
        "body": "sim.vortex_joint_a1frictioncoeff", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a1frictioncoeff", 
        "description": "Constants"
    }, 
    "sim.msgbox_buttons_ok": {
        "body": "sim.msgbox_buttons_ok", 
        "scope": "source.lua", 
        "prefix": "sim.msgbox_buttons_ok", 
        "description": "Constants"
    }, 
    "sim.boolparam_play_toolbarbutton_enabled": {
        "body": "sim.boolparam_play_toolbarbutton_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_play_toolbarbutton_enabled", 
        "description": "Constants"
    }, 
    "sim.forcefloatparam_error_pos": {
        "body": "sim.forcefloatparam_error_pos", 
        "scope": "source.lua", 
        "prefix": "sim.forcefloatparam_error_pos", 
        "description": "Constants"
    }, 
    "sim.vortex_body_autoangulardamping": {
        "body": "sim.vortex_body_autoangulardamping", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_autoangulardamping", 
        "description": "Constants"
    }, 
    "sim.handleChildScripts": {
        "body": "sim.handleChildScripts(${0:callType},${1:passed})", 
        "scope": "source.lua", 
        "prefix": "sim.handleChildScripts", 
        "description": "number executedScriptCount = sim.handleChildScripts(number callType,objects to be passed)Executes non-threaded child scripts located in the current scene hierarchy branch.  Child scripts will be executed in a cascaded fashion and this command should only be called from the main script. - -"
    }, 
    "sim.objfloatparam_abs_z_velocity": {
        "body": "sim.objfloatparam_abs_z_velocity", 
        "scope": "source.lua", 
        "prefix": "sim.objfloatparam_abs_z_velocity", 
        "description": "Constants"
    }, 
    "sim.proximitysensor_ray_subtype": {
        "body": "sim.proximitysensor_ray_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.proximitysensor_ray_subtype", 
        "description": "Constants"
    }, 
    "math.randomseed": {
        "body": "math.randomseed(${0:...})", 
        "scope": "source.lua", 
        "prefix": "math.randomseed", 
        "description": "5.1,5.2,5.3\n\nmath.randomseed (x)"
    }, 
    "sim.handle_scene": {
        "body": "sim.handle_scene", 
        "scope": "source.lua", 
        "prefix": "sim.handle_scene", 
        "description": "Constants"
    }, 
    "sim.stringparam_scene_path": {
        "body": "sim.stringparam_scene_path", 
        "scope": "source.lua", 
        "prefix": "sim.stringparam_scene_path", 
        "description": "Constants"
    }, 
    "simUI.show": {
        "body": "simUI.show(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "simUI.show", 
        "description": "simUI.show(number handle)"
    }, 
    "sim.vortex_joint_p2loss": {
        "body": "sim.vortex_joint_p2loss", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p2loss", 
        "description": "Constants"
    }, 
    "simB0.spinOnce": {
        "body": "simB0.spinOnce(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "simB0.spinOnce", 
        "description": "simB0.spinOnce(string handle)"
    }, 
    "sim.scriptexecorder_normal": {
        "body": "sim.scriptexecorder_normal", 
        "scope": "source.lua", 
        "prefix": "sim.scriptexecorder_normal", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_upper_limit": {
        "body": "sim.jointfloatparam_upper_limit", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_upper_limit", 
        "description": "Constants"
    }, 
    "sim.floatparam_dynamic_step_size": {
        "body": "sim.floatparam_dynamic_step_size", 
        "scope": "source.lua", 
        "prefix": "sim.floatparam_dynamic_step_size", 
        "description": "Constants"
    }, 
    "sim.objectspecialproperty_detectable_capacitive": {
        "body": "sim.objectspecialproperty_detectable_capacitive", 
        "scope": "source.lua", 
        "prefix": "sim.objectspecialproperty_detectable_capacitive", 
        "description": "Constants"
    }, 
    "sim.intparam_simulation_warning_disabled_mask": {
        "body": "sim.intparam_simulation_warning_disabled_mask", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_simulation_warning_disabled_mask", 
        "description": "Constants"
    }, 
    "sim.objintparam_illumination_handle": {
        "body": "sim.objintparam_illumination_handle", 
        "scope": "source.lua", 
        "prefix": "sim.objintparam_illumination_handle", 
        "description": "Constants"
    }, 
    "sim.scriptexecorder_first": {
        "body": "sim.scriptexecorder_first", 
        "scope": "source.lua", 
        "prefix": "sim.scriptexecorder_first", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_rotate": {
        "body": "sim.filtercomponent_rotate", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_rotate", 
        "description": "Constants"
    }, 
    "bit32.btest": {
        "body": "bit32.btest(${0:...})", 
        "scope": "source.lua", 
        "prefix": "bit32.btest", 
        "description": "5.2\n\nbit32.btest (...)"
    }, 
    "sim.boolparam_rml2_available": {
        "body": "sim.boolparam_rml2_available", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_rml2_available", 
        "description": "Constants"
    }, 
    "sim.setIntegerSignal": {
        "body": "sim.setIntegerSignal(${0:signalName},${1:signalValue})", 
        "scope": "source.lua", 
        "prefix": "sim.setIntegerSignal", 
        "description": "number result = sim.setIntegerSignal(string signalName,number signalValue)Sets the value of an integer signal. If that signal is not yet present, it is added. Signals created in the main script or in a child script are automatically cleared at simulation end. See also sim.getIntegerSignal, the other signal functions,  and sim.persistentDataWrite. signalName: name of the signalsignalValue: value of the signalsignalName: name of the signalsignalValue: value of the signalsignalName: name of the signalsignalValue: value of the signal -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simROS.serviceServerTreatUInt8ArrayAsString": {
        "body": "simROS.serviceServerTreatUInt8ArrayAsString(${0:serviceServerHandle})", 
        "scope": "source.lua", 
        "prefix": "simROS.serviceServerTreatUInt8ArrayAsString", 
        "description": "simROS.serviceServerTreatUInt8ArrayAsString(number serviceServerHandle)"
    }, 
    "sim.distcalcmethod_max_dl_dac": {
        "body": "sim.distcalcmethod_max_dl_dac", 
        "scope": "source.lua", 
        "prefix": "sim.distcalcmethod_max_dl_dac", 
        "description": "Constants"
    }, 
    "sim.shapeintparam_respondable": {
        "body": "sim.shapeintparam_respondable", 
        "scope": "source.lua", 
        "prefix": "sim.shapeintparam_respondable", 
        "description": "Constants"
    }, 
    "sim.objectspecialproperty_detectable_inductive": {
        "body": "sim.objectspecialproperty_detectable_inductive", 
        "scope": "source.lua", 
        "prefix": "sim.objectspecialproperty_detectable_inductive", 
        "description": "Constants"
    }, 
    "sim.addStatusbarMessage": {
        "body": "sim.addStatusbarMessage(${0:message})", 
        "scope": "source.lua", 
        "prefix": "sim.addStatusbarMessage", 
        "description": "number result = sim.addStatusbarMessage(string message)Adds a message to the status bar. See also sim.auxiliaryConsoleOpen.  message: message. Will clear the status bar if message is NULL.message: message. Will clear the status bar if message is NULL. -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simx.auxiliaryConsoleShow": {
        "body": "simx.auxiliaryConsoleShow(${0:clientId},${1:consoleHandle},${2:showState})", 
        "scope": "source.lua", 
        "prefix": "simx.auxiliaryConsoleShow", 
        "description": "number returnCode= simx.auxiliaryConsoleShow(number clientId,number consoleHandle,boolean showState)Shows or hides an auxiliary console window. See also simx.auxiliaryConsoleOpen and simx.auxiliaryConsoleClose. clientID: the client ID. refer to simx.start.consoleHandle: the handle of the console window, previously returned by the simx.auxiliaryConsoleOpen commandshowState: indicates whether the console should be hidden or shownoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return code"
    }, 
    "sim.vortex_body_fastmoving": {
        "body": "sim.vortex_body_fastmoving", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_fastmoving", 
        "description": "Constants"
    }, 
    "sim.modelproperty_not_visible": {
        "body": "sim.modelproperty_not_visible", 
        "scope": "source.lua", 
        "prefix": "sim.modelproperty_not_visible", 
        "description": "Constants"
    }, 
    "io.input": {
        "body": "io.input(${0:...})", 
        "scope": "source.lua", 
        "prefix": "io.input", 
        "description": "5.1,5.2,5.3\n\nio.input ([file])"
    }, 
    "simK3.getUltrasonic": {
        "body": "simK3.getUltrasonic(${0:k3Handle},${1:index})", 
        "scope": "source.lua", 
        "prefix": "simK3.getUltrasonic", 
        "description": "number distance = simK3.getUltrasonic(number k3Handle,number index)"
    }, 
    "sim.drawing_auxchannelcolor1": {
        "body": "sim.drawing_auxchannelcolor1", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_auxchannelcolor1", 
        "description": "Constants"
    }, 
    "package.seeall": {
        "body": "package.seeall(${0:...})", 
        "scope": "source.lua", 
        "prefix": "package.seeall", 
        "description": "5.1\n\npackage.seeall (module)"
    }, 
    "sim.boolparam_rosinterface_donotrunmainscript": {
        "body": "sim.boolparam_rosinterface_donotrunmainscript", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_rosinterface_donotrunmainscript", 
        "description": "Constants"
    }, 
    "sim.appobj_collection_type": {
        "body": "sim.appobj_collection_type", 
        "scope": "source.lua", 
        "prefix": "sim.appobj_collection_type", 
        "description": "Constants"
    }, 
    "select": {
        "body": "select(${1:index}, ${2:...})", 
        "scope": "source.lua", 
        "prefix": "select", 
        "description": "5.1,5.2,5.3\n\nselect (index, \\u00b7\\u00b7\\u00b7)"
    }, 
    "simUI.updateTreeItemParent": {
        "body": "simUI.updateTreeItemParent(${0:handle},${1:id},${2:item_id},${3:parent_id},${4:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.updateTreeItemParent", 
        "description": "simUI.updateTreeItemParent(number handle,number id,number item_id,number parent_id,bool suppressEvents=true)"
    }, 
    "sim.jointfloatparam_spherical_qy": {
        "body": "sim.jointfloatparam_spherical_qy", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_spherical_qy", 
        "description": "Constants"
    }, 
    "sim.getObjectAssociatedWithScript": {
        "body": "sim.getObjectAssociatedWithScript(${0:scriptHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectAssociatedWithScript", 
        "description": "number objectHandle = sim.getObjectAssociatedWithScript(number scriptHandle)Retrives the handle of the object the script is attached to. See also sim.getScriptAssociatedWithObject, sim.getCustomizationScriptAssociatedWithObject and sim.associateScriptWithObject. scriptHandle: handle of the scriptscriptHandle: handle of the script Handle of the object that is associated with the script, or -1 if no object is associated with the script, or in case of an error."
    }, 
    "io.lines": {
        "body": "io.lines(${0:...})", 
        "scope": "source.lua", 
        "prefix": "io.lines", 
        "description": "5.1,5.2,5.3\n\nio.lines ([filename])"
    }, 
    "simUI.curve_type.xy": {
        "body": "simUI.curve_type.xy", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_type.xy", 
        "description": "Constants"
    }, 
    "simUI.curve_scatter_shape.peace": {
        "body": "simUI.curve_scatter_shape.peace", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_scatter_shape.peace", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_swapbuffers": {
        "body": "sim.filtercomponent_swapbuffers", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_swapbuffers", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_p0stiffness": {
        "body": "sim.vortex_joint_p0stiffness", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p0stiffness", 
        "description": "Constants"
    }, 
    "sim.objectproperty_depthinvisible": {
        "body": "sim.objectproperty_depthinvisible", 
        "scope": "source.lua", 
        "prefix": "sim.objectproperty_depthinvisible", 
        "description": "Constants"
    }, 
    "simx.readStringStream": {
        "body": "simx.readStringStream(${0:clientId},${1:signalName})", 
        "scope": "source.lua", 
        "prefix": "simx.readStringStream", 
        "description": "number returnCode,string signalValue= simx.readStringStream(number clientId,string signalName)Gets the value of a string signal, then clears it.  Useful to retrieve continuous data from the server. To pack/unpack integers/floats into/from a string, refer to simx.packInts, simx.packFloats, simx.unpackInts and simx.unpackFloats. See also simx.writeStringStream. clientID: the client ID. refer to simx.start.signalName: name of the signaloperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls). simx.opmode_blocking is forbidden. Use a construction like following in order to continuously exchange data with V-REP: returnCode: a remote API function return codestringData: the string data"
    }, 
    "sim.setScriptVariable": {
        "body": "sim.setScriptVariable(${0:variableNameAtScriptName},${1:scriptHandleOrType},${2:variable})", 
        "scope": "source.lua", 
        "prefix": "sim.setScriptVariable", 
        "description": "number result = sim.setScriptVariable(string variableNameAtScriptName,number scriptHandleOrType,variable)Sets or clears a script variable (i.e. a Lua variable). Call this only:a) from the main thread, or:b) from a thread that originated from a threaded child script. In that case, you cannot set a variable in a non-threaded child script.See also sim.callScriptFunction. scriptHandleOrType: the handle of the script, otherwise the type of the script:sim_scripttype_mainscript (0): the main script is the target.sim_scripttype_childscript (1): a child script is the target. In that case, arrayNameAtScriptName should also contain the name of the object associated with the script.sim_scripttype_customizationscript (6): a customization script is the target. In that case, arrayNameAtScriptName should also contain the name of the object associated with the script.variableNameAtScriptName: the name of the variable. If scriptHandleOrType is sim_scripttype_childscript, or sim_scripttype_customizationscript, then variableNameAtScriptName should also contain the name of the object associated with the script: variableName@scriptName.stackHandle: the handle of a stack object. The top stack item represents the variable value. If the handle is 0, then the variable will be assigned the value nil. See also the available stack functions.scriptHandleOrType: the handle of the script, otherwise the type of the script:sim_scripttype_mainscript (0): the main script is the target.sim_scripttype_childscript (1): a child script is the target. In that case, arrayNameAtScriptName should also contain the name of the object associated with the script.sim_scripttype_customizationscript (6): a customization script is the target. In that case, arrayNameAtScriptName should also contain the name of the object associated with the script.variableNameAtScriptName: the name of the variable. If scriptHandleOrType is sim_scripttype_childscript, or sim_scripttype_customizationscript, then variableNameAtScriptName should also contain the name of the object associated with the script: variableName@scriptName.stackHandle: the handle of a stack object. The top stack item represents the variable value. If the handle is 0, then the variable will be assigned the value nil. See also the available stack functions.scriptHandleOrType: the handle of the script, otherwise the type of the script:sim_scripttype_mainscript (0): the main script is the target.sim_scripttype_childscript (1): a child script is the target. In that case, arrayNameAtScriptName should also contain the name of the object associated with the script.sim_scripttype_customizationscript (6): a customization script is the target. In that case, arrayNameAtScriptName should also contain the name of the object associated with the script.variableNameAtScriptName: the name of the variable. If scriptHandleOrType is sim_scripttype_childscript, or sim_scripttype_customizationscript, then variableNameAtScriptName should also contain the name of the object associated with the script: variableName@scriptName.stackHandle: the handle of a stack object. The top stack item represents the variable value. If the handle is 0, then the variable will be assigned the value nil. See also the available stack functions.scriptHandleOrType: the handle of the script, otherwise the type of the script:sim_scripttype_mainscript (0): the main script is the target.sim_scripttype_childscript (1): a child script is the target. In that case, arrayNameAtScriptName should also contain the name of the object associated with the script.sim_scripttype_customizationscript (6): a customization script is the target. In that case, arrayNameAtScriptName should also contain the name of the object associated with the script.variableNameAtScriptName: the name of the variable. If scriptHandleOrType is sim_scripttype_childscript, or sim_scripttype_customizationscript, then variableNameAtScriptName should also contain the name of the object associated with the script: variableName@scriptName.stackHandle: the handle of a stack object. The top stack item represents the variable value. If the handle is 0, then the variable will be assigned the value nil. See also the available stack functions.scriptHandleOrType: the handle of the script, otherwise the type of the script:sim_scripttype_mainscript (0): the main script is the target.sim_scripttype_childscript (1): a child script is the target. In that case, arrayNameAtScriptName should also contain the name of the object associated with the script.sim_scripttype_customizationscript (6): a customization script is the target. In that case, arrayNameAtScriptName should also contain the name of the object associated with the script.variableNameAtScriptName: the name of the variable. If scriptHandleOrType is sim_scripttype_childscript, or sim_scripttype_customizationscript, then variableNameAtScriptName should also contain the name of the object associated with the script: variableName@scriptName.stackHandle: the handle of a stack object. The top stack item represents the variable value. If the handle is 0, then the variable will be assigned the value nil. See also the available stack functions.scriptHandleOrType: the handle of the script, otherwise the type of the script:sim_scripttype_mainscript (0): the main script is the target.sim_scripttype_childscript (1): a child script is the target. In that case, arrayNameAtScriptName should also contain the name of the object associated with the script.sim_scripttype_customizationscript (6): a customization script is the target. In that case, arrayNameAtScriptName should also contain the name of the object associated with the script.variableNameAtScriptName: the name of the variable. If scriptHandleOrType is sim_scripttype_childscript, or sim_scripttype_customizationscript, then variableNameAtScriptName should also contain the name of the object associated with the script: variableName@scriptName.stackHandle: the handle of a stack object. The top stack item represents the variable value. If the handle is 0, then the variable will be assigned the value nil. See also the available stack functions. -1 in case of an error"
    }, 
    "table.unpack": {
        "body": "table.unpack(${0:...})", 
        "scope": "source.lua", 
        "prefix": "table.unpack", 
        "description": "5.2,5.3\n\ntable.unpack (list [, i [, j]])"
    }, 
    "sim.vortex_body_adhesiveforce": {
        "body": "sim.vortex_body_adhesiveforce", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_adhesiveforce", 
        "description": "Constants"
    }, 
    "simx.synchronousTrigger": {
        "body": "simx.synchronousTrigger()", 
        "scope": "source.lua", 
        "prefix": "simx.synchronousTrigger", 
        "description": "number returnCode= simx.synchronousTrigger()Sends a synchronization  trigger signal to the server. The function is blocking. The server needs to be previously enabled for synchronous operation via the simx.synchronous function. The trigger signal will inform V-REP to execute the next simulation step (i.e. to call sim.handleMainScript). While in synchronous operation mode, the client application is in charge of triggering the next simulation step, otherwise simulation will stall. See also this section. This is a remote API helper function. clientID: the client ID. refer to simx.start. returnCode: a remote API function return code"
    }, 
    "sim.bullet_joint_normalcfm": {
        "body": "sim.bullet_joint_normalcfm", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_joint_normalcfm", 
        "description": "Constants"
    }, 
    "sim.objectspecialproperty_detectable_all": {
        "body": "sim.objectspecialproperty_detectable_all", 
        "scope": "source.lua", 
        "prefix": "sim.objectspecialproperty_detectable_all", 
        "description": "Constants"
    }, 
    "sim.handleflag_model": {
        "body": "sim.handleflag_model", 
        "scope": "source.lua", 
        "prefix": "sim.handleflag_model", 
        "description": "Constants"
    }, 
    "type": {
        "body": "type(${1:v})", 
        "scope": "source.lua", 
        "prefix": "type", 
        "description": "5.1,5.2,5.3\n\ntype (v)"
    }, 
    "sim.cutPathCtrlPoints": {
        "body": "sim.cutPathCtrlPoints(${0:pathHandle},${1:startIndex},${2:ptCnt})", 
        "scope": "source.lua", 
        "prefix": "sim.cutPathCtrlPoints", 
        "description": "number result = sim.cutPathCtrlPoints(number pathHandle,number startIndex,number ptCnt)Removes one or several control points from a path object. See also sim.insertPathCtrlPoints and sim.createPath. pathHandle: the handle of the path. Refer also to simGetObjectHandle.startIndex: the zero-based index of the first control point to remove, or -1 to remove all the control points.ptCnt: the number of control points to remove.pathHandle: the handle of the path. Refer also to simGetObjectHandle.startIndex: the zero-based index of the first control point to remove, or -1 to remove all the control points.ptCnt: the number of control points to remove.pathHandle: the handle of the path. Refer also to simGetObjectHandle.startIndex: the zero-based index of the first control point to remove, or -1 to remove all the control points.ptCnt: the number of control points to remove. -1 if operation was not successful."
    }, 
    "sim.shapefloatparam_mass": {
        "body": "sim.shapefloatparam_mass", 
        "scope": "source.lua", 
        "prefix": "sim.shapefloatparam_mass", 
        "description": "Constants"
    }, 
    "sim.setThreadIsFree": {
        "body": "sim.setThreadIsFree(${0:freeMode})", 
        "scope": "source.lua", 
        "prefix": "sim.setThreadIsFree", 
        "description": "number result = sim.setThreadIsFree(boolean freeMode)Threads created by V-REP are never running concurrently, they rather behave like coroutines. This allows achieving same results as with pure threads, except when an external command is blocking (e.g. commands not directly supported by V-REP). Those can be lengthly image processing routines, or socket communication routines for example. When such external blocking commands are called, V-REP appears frozen until the external commands return. To avoid such a situation, you can declare a non-blocking section with the sim.setThreadIsFree command: sim.setThreadIsFree(true) starts a non-blocking section, and sim.setThreadIsFree(false) closes it. Try to avoid using V-REP commands when in a non-blocking section (bad synchronization), and never forget to close a non-blocking section, otherwise V-REP will hang indefinitely. Use sim.setThreadIsFree with extra care when calling it from C. A thread running in a non-blocking section cannot be paused nor stopped. This command has no effect when called from the main thread or a non-threaded script. freeMode: specify 1 to start a non-blocking section. Specify 0 to end a non-blocking sectionfreeMode: specify 1 to start a non-blocking section. Specify 0 to end a non-blocking section 1 if operation was successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.newton_global_highjointaccuracy": {
        "body": "sim.newton_global_highjointaccuracy", 
        "scope": "source.lua", 
        "prefix": "sim.newton_global_highjointaccuracy", 
        "description": "Constants"
    }, 
    "simx.opmode_blocking": {
        "body": "simx.opmode_blocking", 
        "scope": "source.lua", 
        "prefix": "simx.opmode_blocking", 
        "description": "Constants"
    }, 
    "simRRS1.SET_ADVANCE_MOTION": {
        "body": "simRRS1.SET_ADVANCE_MOTION(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_ADVANCE_MOTION", 
        "description": "int status= simRRS1.SET_ADVANCE_MOTION(bitstring2 rcsHandle)"
    }, 
    "sim.handleflag_extended": {
        "body": "sim.handleflag_extended", 
        "scope": "source.lua", 
        "prefix": "sim.handleflag_extended", 
        "description": "Constants"
    }, 
    "sim.banner_bitmapfont": {
        "body": "sim.banner_bitmapfont", 
        "scope": "source.lua", 
        "prefix": "sim.banner_bitmapfont", 
        "description": "Constants"
    }, 
    "sim.checkProximitySensorEx2": {
        "body": "sim.checkProximitySensorEx2(${0:sensorHandle},${1:vertices},${2:itemType},${3:itemCount},${4:mode},${5:threshold},${6:maxAngle})", 
        "scope": "source.lua", 
        "prefix": "sim.checkProximitySensorEx2", 
        "description": "number result,number distance,table_3 detectedPoint,table_3 normalVector = sim.checkProximitySensorEx2(number sensorHandle,table vertices,number itemType,number itemCount,number mode,number threshold,number maxAngle)Checks whether the proximity sensor detects the indicated points, segments or triangles. Detection is silent (no visual feedback). See also sim.readProximitySensor and sim.checkProximitySensorEx. sensorHandle: handle of the proximity sensor objectvertexPointer: a pointer to verticesitemType: 0 for points, 1 for segments and 2 for trianglesitemCount: the number of items that vertexPointer points atFor the other parameters, see the description in simCheckProximitySensorEx. (simCheckProximitySensorEx2 doesn't support occlusion checking)sensorHandle: handle of the proximity sensor objectvertexPointer: a pointer to verticesitemType: 0 for points, 1 for segments and 2 for trianglesitemCount: the number of items that vertexPointer points atFor the other parameters, see the description in simCheckProximitySensorEx. (simCheckProximitySensorEx2 doesn't support occlusion checking)sensorHandle: handle of the proximity sensor objectvertexPointer: a pointer to verticesitemType: 0 for points, 1 for segments and 2 for trianglesitemCount: the number of items that vertexPointer points atFor the other parameters, see the description in simCheckProximitySensorEx. (simCheckProximitySensorEx2 doesn't support occlusion checking)sensorHandle: handle of the proximity sensor objectvertexPointer: a pointer to verticesitemType: 0 for points, 1 for segments and 2 for trianglesitemCount: the number of items that vertexPointer points atFor the other parameters, see the description in simCheckProximitySensorEx. (simCheckProximitySensorEx2 doesn't support occlusion checking)sensorHandle: handle of the proximity sensor objectvertexPointer: a pointer to verticesitemType: 0 for points, 1 for segments and 2 for trianglesitemCount: the number of items that vertexPointer points atFor the other parameters, see the description in simCheckProximitySensorEx. (simCheckProximitySensorEx2 doesn't support occlusion checking) -1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)"
    }, 
    "simUI.setRowHeaderText": {
        "body": "simUI.setRowHeaderText(${0:handle},${1:id},${2:row},${3:text})", 
        "scope": "source.lua", 
        "prefix": "simUI.setRowHeaderText", 
        "description": "simUI.setRowHeaderText(number handle,number id,number row,string text)"
    }, 
    "sim.floatparam_stereo_distance": {
        "body": "sim.floatparam_stereo_distance", 
        "scope": "source.lua", 
        "prefix": "sim.floatparam_stereo_distance", 
        "description": "Constants"
    }, 
    "debug.getmetatable": {
        "body": "debug.getmetatable( ${1:value} )", 
        "scope": "source.lua", 
        "prefix": "debug.getmetatable", 
        "description": "5.1,5.2,5.3\n\ndebug.getmetatable (value)"
    }, 
    "sim.scripttype_childscript": {
        "body": "sim.scripttype_childscript", 
        "scope": "source.lua", 
        "prefix": "sim.scripttype_childscript", 
        "description": "Constants"
    }, 
    "sim.buttonproperty_closeaction": {
        "body": "sim.buttonproperty_closeaction", 
        "scope": "source.lua", 
        "prefix": "sim.buttonproperty_closeaction", 
        "description": "Constants"
    }, 
    "unpack": {
        "body": "unpack(${0:...})", 
        "scope": "source.lua", 
        "prefix": "unpack", 
        "description": "5.1\n\nunpack (list [, i [, j]])"
    }, 
    "getmetatable": {
        "body": "getmetatable(${1:object})", 
        "scope": "source.lua", 
        "prefix": "getmetatable", 
        "description": "5.1,5.2,5.3\n\ngetmetatable (object)"
    }, 
    "sim.subtractObjectFromOctree": {
        "body": "sim.subtractObjectFromOctree(${0:octreeHandle},${1:objectHandle},${2:options})", 
        "scope": "source.lua", 
        "prefix": "sim.subtractObjectFromOctree", 
        "description": "number totalVoxelCnt = sim.subtractObjectFromOctree(number octreeHandle,number objectHandle,number options)Removes an object from an octree, as voxel subtractions. See also sim.insertObjectIntoOctree, sim.removeVoxelsFromOctree and the other octree related functions. octreeHandle: the handle of the octree. See also simGetObjectHandleobjectHandle: the handle of the object to subtract. Only potentially collidable objects are supportedoptions: reserved. Set to 0reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleobjectHandle: the handle of the object to subtract. Only potentially collidable objects are supportedoptions: reserved. Set to 0reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleobjectHandle: the handle of the object to subtract. Only potentially collidable objects are supportedoptions: reserved. Set to 0reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleobjectHandle: the handle of the object to subtract. Only potentially collidable objects are supportedoptions: reserved. Set to 0reserved: reserved for future extensions. Set to NULL -1 if operation was not successful, otherwise the total number of voxels in the octree"
    }, 
    "math.ult": {
        "body": "math.ult(${0:...})", 
        "scope": "source.lua", 
        "prefix": "math.ult", 
        "description": "5.3\n\nmath.ult (m, n)"
    }, 
    "sim.filtercomponent_tooutput": {
        "body": "sim.filtercomponent_tooutput", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_tooutput", 
        "description": "Constants"
    }, 
    "simRRS1.SET_CARTESIAN_ORIENTATION_SPEED": {
        "body": "simRRS1.SET_CARTESIAN_ORIENTATION_SPEED(${0:rcsHandle},${1:rotationNo})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_CARTESIAN_ORIENTATION_SPEED", 
        "description": "int status= simRRS1.SET_CARTESIAN_ORIENTATION_SPEED(bitstring2 rcsHandle,int rotationNo)"
    }, 
    "debug.setlocal": {
        "body": "debug.setlocal( ${1:[thead,]}${2:level}, ${3:local}, ${4:value} )", 
        "scope": "source.lua", 
        "prefix": "debug.setlocal", 
        "description": "5.1,5.2,5.3\n\ndebug.setlocal ([thread,] level, local, value)"
    }, 
    "sim.vortex_global_constraintlinearcompliance": {
        "body": "sim.vortex_global_constraintlinearcompliance", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_global_constraintlinearcompliance", 
        "description": "Constants"
    }, 
    "sim.message_prox_sensor_select_up": {
        "body": "sim.message_prox_sensor_select_up", 
        "scope": "source.lua", 
        "prefix": "sim.message_prox_sensor_select_up", 
        "description": "Constants"
    }, 
    "sim.pure_primitive_cuboid": {
        "body": "sim.pure_primitive_cuboid", 
        "scope": "source.lua", 
        "prefix": "sim.pure_primitive_cuboid", 
        "description": "Constants"
    }, 
    "sim.bullet_global_stepsize": {
        "body": "sim.bullet_global_stepsize", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_global_stepsize", 
        "description": "Constants"
    }, 
    "simCHAI3D.removeObject": {
        "body": "simCHAI3D.removeObject(${0:objectID})", 
        "scope": "source.lua", 
        "prefix": "simCHAI3D.removeObject", 
        "description": "simCHAI3D.removeObject(number objectID)"
    }, 
    "sim.newton_body_lineardrag": {
        "body": "sim.newton_body_lineardrag", 
        "scope": "source.lua", 
        "prefix": "sim.newton_body_lineardrag", 
        "description": "Constants"
    }, 
    "sim.handleflag_silenterror": {
        "body": "sim.handleflag_silenterror", 
        "scope": "source.lua", 
        "prefix": "sim.handleflag_silenterror", 
        "description": "Constants"
    }, 
    "math.random": {
        "body": "math.random( ${1:[m]}${2:[, n]} )", 
        "scope": "source.lua", 
        "prefix": "math.random", 
        "description": "5.1,5.2,5.3\n\nmath.random"
    }, 
    "simRRS1.SELECT_ORIENTATION_INTERPOLATION_MODE": {
        "body": "simRRS1.SELECT_ORIENTATION_INTERPOLATION_MODE(${0:rcsHandle},${1:interpolationMode})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SELECT_ORIENTATION_INTERPOLATION_MODE", 
        "description": "int status= simRRS1.SELECT_ORIENTATION_INTERPOLATION_MODE(bitstring2 rcsHandle,int interpolationMode)"
    }, 
    "sim.intparam_dynamic_step_divider": {
        "body": "sim.intparam_dynamic_step_divider", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_dynamic_step_divider", 
        "description": "Constants"
    }, 
    "sim.intparam_program_revision": {
        "body": "sim.intparam_program_revision", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_program_revision", 
        "description": "Constants"
    }, 
    "sim.volume_disc": {
        "body": "sim.volume_disc", 
        "scope": "source.lua", 
        "prefix": "sim.volume_disc", 
        "description": "Constants"
    }, 
    "simUI.addTreeItem": {
        "body": "simUI.addTreeItem(${0:handle},${1:id},${2:item_id},${3:text},${4:parent_id=0},${5:expanded=false},${6:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.addTreeItem", 
        "description": "simUI.addTreeItem(number handle,number id,number item_id,table text,number parent_id=0,bool expanded=false,bool suppressEvents=true)"
    }, 
    "sim.vortex_bodyfrictionmodel_proplow": {
        "body": "sim.vortex_bodyfrictionmodel_proplow", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_bodyfrictionmodel_proplow", 
        "description": "Constants"
    }, 
    "simUI.curve_style.line_and_scatter": {
        "body": "simUI.curve_style.line_and_scatter", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_style.line_and_scatter", 
        "description": "Constants"
    }, 
    "sim.drawing_itemcolors": {
        "body": "sim.drawing_itemcolors", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_itemcolors", 
        "description": "Constants"
    }, 
    "sim.modelproperty_not_reset": {
        "body": "sim.modelproperty_not_reset", 
        "scope": "source.lua", 
        "prefix": "sim.modelproperty_not_reset", 
        "description": "Constants"
    }, 
    "string.char": {
        "body": "string.char( ${1:...} )", 
        "scope": "source.lua", 
        "prefix": "string.char", 
        "description": "5.1,5.2,5.3\n\nstring.char"
    }, 
    "os.time": {
        "body": "os.time(${0:...})", 
        "scope": "source.lua", 
        "prefix": "os.time", 
        "description": "5.1,5.2,5.3\n\nos.time ([table])"
    }, 
    "sim.vortex_joint_a0frictioncoeff": {
        "body": "sim.vortex_joint_a0frictioncoeff", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a0frictioncoeff", 
        "description": "Constants"
    }, 
    "sim.persistentDataRead": {
        "body": "sim.persistentDataRead(${0:dataName})", 
        "scope": "source.lua", 
        "prefix": "sim.persistentDataRead", 
        "description": "string dataValue = sim.persistentDataRead(string dataName)Reads a block of persistent data. See also sim.persistentDataWrite, sim.getStringSignal, sim.getIntegerSignal,  sim.getFloatSignal and sim.readCustomDataBlock. dataName: name of the data blockdataLength: the size of the returned data block, since it may contain any data (also embedded zeros).dataName: name of the data blockdataLength: the size of the returned data block, since it may contain any data (also embedded zeros). NULL if operation was not successful or data block does not exist, otherwise the data block (which may contain any value, including embedded zeros). In that case the returned buffer should be released with simReleaseBuffer"
    }, 
    "simOMPL.StateSpaceType.position3d": {
        "body": "simOMPL.StateSpaceType.position3d", 
        "scope": "source.lua", 
        "prefix": "simOMPL.StateSpaceType.position3d", 
        "description": "Constants"
    }, 
    "sim.distcalcmethod_dl_and_dac": {
        "body": "sim.distcalcmethod_dl_and_dac", 
        "scope": "source.lua", 
        "prefix": "sim.distcalcmethod_dl_and_dac", 
        "description": "Constants"
    }, 
    "sysCall_afterCreate": {
        "body": "sysCall_afterCreate(${0:array.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_afterCreate", 
        "description": "sysCall_afterCreate(called just after objects were created. Arg1 is a map with 'objectHandles' array.)"
    }, 
    "sim.setScriptSimulationParameter": {
        "body": "sim.setScriptSimulationParameter(${0:scriptHandle},${1:parameterName},${2:parameterValue})", 
        "scope": "source.lua", 
        "prefix": "sim.setScriptSimulationParameter", 
        "description": "number setCount = sim.setScriptSimulationParameter(number scriptHandle,string parameterName,string parameterValue)Sets a main script's or child script's parameter in its simulation parameter list. Useful for simple interaction with the user or for simple parameter exchange with other scripts. See also sim.getScriptSimulationParameter and the data packing/unpacking functions. scriptHandle: handle of the script, or sim_handle_main_script or sim_handle_allparameterName: name of the parameter to setparameterValue: value of the parameter (all parameters are treated as strings, but can be converted to number later on. Strings may contain any values (also embedded zeros))parameterLength: number of bytes that parameterValue contains. If parameterValue is a regular string (without embedded zeros), then this is strlen(parameterValue).scriptHandle: handle of the script, or sim_handle_main_script or sim_handle_allparameterName: name of the parameter to setparameterValue: value of the parameter (all parameters are treated as strings, but can be converted to number later on. Strings may contain any values (also embedded zeros))parameterLength: number of bytes that parameterValue contains. If parameterValue is a regular string (without embedded zeros), then this is strlen(parameterValue).scriptHandle: handle of the script, or sim_handle_main_script or sim_handle_allparameterName: name of the parameter to setparameterValue: value of the parameter (all parameters are treated as strings, but can be converted to number later on. Strings may contain any values (also embedded zeros))parameterLength: number of bytes that parameterValue contains. If parameterValue is a regular string (without embedded zeros), then this is strlen(parameterValue).scriptHandle: handle of the script, or sim_handle_main_script or sim_handle_allparameterName: name of the parameter to setparameterValue: value of the parameter (all parameters are treated as strings, but can be converted to number later on. Strings may contain any values (also embedded zeros))parameterLength: number of bytes that parameterValue contains. If parameterValue is a regular string (without embedded zeros), then this is strlen(parameterValue).scriptHandle: handle of the script, or sim_handle_main_script or sim_handle_allparameterName: name of the parameter to setparameterValue: value of the parameter (all parameters are treated as strings, but can be converted to number later on. Strings may contain any values (also embedded zeros))parameterLength: number of bytes that parameterValue contains. If parameterValue is a regular string (without embedded zeros), then this is strlen(parameterValue). number of parameters that were set (can be >1 if sim_handle_all was specified) or -1 if the parameterName could not be found or in case of an error"
    }, 
    "sim.serialClose": {
        "body": "sim.serialClose(${0:portHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.serialClose", 
        "description": "number result = sim.serialClose(number portHandle)Closes a serial port (RS-232). See also sim.serialOpen.  portHandle: the handle returned by the simSerialOpen functionportHandle: the handle returned by the simSerialOpen function -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simRRS1.CONTROLLER_POSITION_TO_MATRIX": {
        "body": "simRRS1.CONTROLLER_POSITION_TO_MATRIX(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.CONTROLLER_POSITION_TO_MATRIX", 
        "description": "int status,cartPosType cartPos,string configuration= simRRS1.CONTROLLER_POSITION_TO_MATRIX(bitstring2 rcsHandle)"
    }, 
    "sim.buffer_uint8rgb": {
        "body": "sim.buffer_uint8rgb", 
        "scope": "source.lua", 
        "prefix": "sim.buffer_uint8rgb", 
        "description": "Constants"
    }, 
    "sysCall_dynCallback": {
        "body": "sysCall_dynCallback(${0:pass.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_dynCallback", 
        "description": "sysCall_dynCallback(Called by the physics engine twice per dynamic simulation pass.)"
    }, 
    "math.type": {
        "body": "math.type( ${1:x} )", 
        "scope": "source.lua", 
        "prefix": "math.type", 
        "description": "5.3\n\nmath.type"
    }, 
    "sim.pure_primitive_disc": {
        "body": "sim.pure_primitive_disc", 
        "scope": "source.lua", 
        "prefix": "sim.pure_primitive_disc", 
        "description": "Constants"
    }, 
    "sim.setNavigationMode": {
        "body": "sim.setNavigationMode(${0:navigationMode})", 
        "scope": "source.lua", 
        "prefix": "sim.setNavigationMode", 
        "description": "number result = sim.setNavigationMode(number navigationMode)Sets the navigation and selection mode for the mouse. See also sim.getNavigationMode. navigationMode: mouse navigation modenavigationMode: mouse navigation mode -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.addObjectToCollection": {
        "body": "sim.addObjectToCollection(${0:collectionHandle},${1:objectHandle},${2:what},${3:options})", 
        "scope": "source.lua", 
        "prefix": "sim.addObjectToCollection", 
        "description": "number result = sim.addObjectToCollection(number collectionHandle,number objectHandle,number what,number options)Adds an object (or a group of objects) to a collection. See also sim.emptyCollection, sim.removeCollection, sim.getCollectionHandle, sim.getObjectHandle, sim.getCollectionObjects and sim.createCollection.  collectionHandle: the handle of a collection.objectHandle: the handle of an object.what: the type of object (or group of objects) to add. Following are allowed values: sim_handle_single (for a single object), sim_handle_all (for all objects in the scene), sim_handle_tree (for a tree of objects), or sim_handle_chain (for a chain of objects (i.e. an inverted tree)).options: bit-coded options:bit 0 set (1): the specified object (or group of objects) is removed from the collection. Otherwise it is added.bit 1 set (2): the specified object is not included in the group of objects, if sim_handle_tree or sim_handle_chain is specified (i.e. the tree base or tip is excluded).collectionHandle: the handle of a collection.objectHandle: the handle of an object.what: the type of object (or group of objects) to add. Following are allowed values: sim_handle_single (for a single object), sim_handle_all (for all objects in the scene), sim_handle_tree (for a tree of objects), or sim_handle_chain (for a chain of objects (i.e. an inverted tree)).options: bit-coded options:bit 0 set (1): the specified object (or group of objects) is removed from the collection. Otherwise it is added.bit 1 set (2): the specified object is not included in the group of objects, if sim_handle_tree or sim_handle_chain is specified (i.e. the tree base or tip is excluded).collectionHandle: the handle of a collection.objectHandle: the handle of an object.what: the type of object (or group of objects) to add. Following are allowed values: sim_handle_single (for a single object), sim_handle_all (for all objects in the scene), sim_handle_tree (for a tree of objects), or sim_handle_chain (for a chain of objects (i.e. an inverted tree)).options: bit-coded options:bit 0 set (1): the specified object (or group of objects) is removed from the collection. Otherwise it is added.bit 1 set (2): the specified object is not included in the group of objects, if sim_handle_tree or sim_handle_chain is specified (i.e. the tree base or tip is excluded).collectionHandle: the handle of a collection.objectHandle: the handle of an object.what: the type of object (or group of objects) to add. Following are allowed values: sim_handle_single (for a single object), sim_handle_all (for all objects in the scene), sim_handle_tree (for a tree of objects), or sim_handle_chain (for a chain of objects (i.e. an inverted tree)).options: bit-coded options:bit 0 set (1): the specified object (or group of objects) is removed from the collection. Otherwise it is added.bit 1 set (2): the specified object is not included in the group of objects, if sim_handle_tree or sim_handle_chain is specified (i.e. the tree base or tip is excluded).collectionHandle: the handle of a collection.objectHandle: the handle of an object.what: the type of object (or group of objects) to add. Following are allowed values: sim_handle_single (for a single object), sim_handle_all (for all objects in the scene), sim_handle_tree (for a tree of objects), or sim_handle_chain (for a chain of objects (i.e. an inverted tree)).options: bit-coded options:bit 0 set (1): the specified object (or group of objects) is removed from the collection. Otherwise it is added.bit 1 set (2): the specified object is not included in the group of objects, if sim_handle_tree or sim_handle_chain is specified (i.e. the tree base or tip is excluded).collectionHandle: the handle of a collection.objectHandle: the handle of an object.what: the type of object (or group of objects) to add. Following are allowed values: sim_handle_single (for a single object), sim_handle_all (for all objects in the scene), sim_handle_tree (for a tree of objects), or sim_handle_chain (for a chain of objects (i.e. an inverted tree)).options: bit-coded options:bit 0 set (1): the specified object (or group of objects) is removed from the collection. Otherwise it is added.bit 1 set (2): the specified object is not included in the group of objects, if sim_handle_tree or sim_handle_chain is specified (i.e. the tree base or tip is excluded). -1 if operation was not successful."
    }, 
    "sim.insertVoxelsIntoOctree": {
        "body": "sim.insertVoxelsIntoOctree(${0:octreeHandle},${1:options},${2:points},${3:color=nil},${4:tag=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.insertVoxelsIntoOctree", 
        "description": "number totalVoxelCnt = sim.insertVoxelsIntoOctree(number octreeHandle,number options,table points,table color=nil,table tag=nil)Inserts voxels into an octree. Each voxel will store a color and a tag value. See also sim.removeVoxelsFromOctree and the other octree related functions. octreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point, and the tag array contains one value per point. Otherwise it the color array contains a single RGB triple, and the tag array contains a single value.pts: a pointer to the voxel positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.tag: a pointer to one or several uint32 values, which are user-defined values. Can be NULL, and should be NULL if color is NULL.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point, and the tag array contains one value per point. Otherwise it the color array contains a single RGB triple, and the tag array contains a single value.pts: a pointer to the voxel positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.tag: a pointer to one or several uint32 values, which are user-defined values. Can be NULL, and should be NULL if color is NULL.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point, and the tag array contains one value per point. Otherwise it the color array contains a single RGB triple, and the tag array contains a single value.pts: a pointer to the voxel positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.tag: a pointer to one or several uint32 values, which are user-defined values. Can be NULL, and should be NULL if color is NULL.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point, and the tag array contains one value per point. Otherwise it the color array contains a single RGB triple, and the tag array contains a single value.pts: a pointer to the voxel positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.tag: a pointer to one or several uint32 values, which are user-defined values. Can be NULL, and should be NULL if color is NULL.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point, and the tag array contains one value per point. Otherwise it the color array contains a single RGB triple, and the tag array contains a single value.pts: a pointer to the voxel positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.tag: a pointer to one or several uint32 values, which are user-defined values. Can be NULL, and should be NULL if color is NULL.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point, and the tag array contains one value per point. Otherwise it the color array contains a single RGB triple, and the tag array contains a single value.pts: a pointer to the voxel positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.tag: a pointer to one or several uint32 values, which are user-defined values. Can be NULL, and should be NULL if color is NULL.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point, and the tag array contains one value per point. Otherwise it the color array contains a single RGB triple, and the tag array contains a single value.pts: a pointer to the voxel positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.tag: a pointer to one or several uint32 values, which are user-defined values. Can be NULL, and should be NULL if color is NULL.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point, and the tag array contains one value per point. Otherwise it the color array contains a single RGB triple, and the tag array contains a single value.pts: a pointer to the voxel positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.tag: a pointer to one or several uint32 values, which are user-defined values. Can be NULL, and should be NULL if color is NULL.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point, and the tag array contains one value per point. Otherwise it the color array contains a single RGB triple, and the tag array contains a single value.pts: a pointer to the voxel positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.tag: a pointer to one or several uint32 values, which are user-defined values. Can be NULL, and should be NULL if color is NULL.reserved: reserved for future extensions. Set to NULL -1 if operation was not successful, otherwise the total number of voxels in the octree"
    }, 
    "bit32.lrotate": {
        "body": "bit32.lrotate(${0:...})", 
        "scope": "source.lua", 
        "prefix": "bit32.lrotate", 
        "description": "5.2\n\nbit32.lrotate (x, disp)"
    }, 
    "sim.particle_respondable5to8": {
        "body": "sim.particle_respondable5to8", 
        "scope": "source.lua", 
        "prefix": "sim.particle_respondable5to8", 
        "description": "Constants"
    }, 
    "sim.newton_global_contactmergetolerance": {
        "body": "sim.newton_global_contactmergetolerance", 
        "scope": "source.lua", 
        "prefix": "sim.newton_global_contactmergetolerance", 
        "description": "Constants"
    }, 
    "sim.boolOr32": {
        "body": "sim.boolOr32(${0:value1},${1:value2})", 
        "scope": "source.lua", 
        "prefix": "sim.boolOr32", 
        "description": "number result = sim.boolOr32(number value1,number value2)Performs a 32-bit Boolean OR operation between two numbers. See also sim.boolAnd32 and sim.boolXor32. - -"
    }, 
    "sim.ik_y_constraint": {
        "body": "sim.ik_y_constraint", 
        "scope": "source.lua", 
        "prefix": "sim.ik_y_constraint", 
        "description": "Constants"
    }, 
    "simK3.create": {
        "body": "simK3.create(${0:wheelMotorHandles},${1:colorSensorHandles},${2:IrSensorHandles},${3:usSensorHandles},${4:armMotorHandles},${5:fingerMotorHandles},${6:gripperDistSensHandles},${7:gripperColSensHandles},${8:uiHandle})", 
        "scope": "source.lua", 
        "prefix": "simK3.create", 
        "description": "number k3Handle = simK3.create(table_2 wheelMotorHandles,table_2 colorSensorHandles,table_9 IrSensorHandles,table_5 usSensorHandles,table_6 armMotorHandles,table_3 fingerMotorHandles,table_2 gripperDistSensHandles,table_2 gripperColSensHandles,number uiHandle)"
    }, 
    "simUI.setColumnWidth": {
        "body": "simUI.setColumnWidth(${0:handle},${1:id},${2:column},${3:min_size},${4:max_size})", 
        "scope": "source.lua", 
        "prefix": "simUI.setColumnWidth", 
        "description": "simUI.setColumnWidth(number handle,number id,number column,number min_size,number max_size)"
    }, 
    "sysCall_cleanup": {
        "body": "sysCall_cleanup(${0:destroyed.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_cleanup", 
        "description": "sysCall_cleanup(Called when the script is destroyed.)"
    }, 
    "simROS.imageTransportAdvertise": {
        "body": "simROS.imageTransportAdvertise(${0:topicName},${1:queueSize=1})", 
        "scope": "source.lua", 
        "prefix": "simROS.imageTransportAdvertise", 
        "description": "number publisherHandle = simROS.imageTransportAdvertise(string topicName,number queueSize=1)"
    }, 
    "sim.getContactInfo": {
        "body": "sim.getContactInfo(${0:dynamicPass},${1:objectHandle},${2:index})", 
        "scope": "source.lua", 
        "prefix": "sim.getContactInfo", 
        "description": "table_2 collidingObjects,table_3 collisionPoint,table_3 reactionForce,table_3 normalVector = sim.getContactInfo(number dynamicPass,number objectHandle,number index)Retrieves contact point information of a dynamic simulation pass.  dynamicPass: a specific dynamic sub-step index or sim_handle_all. By default a call to simHandleDynamics executes the dynamics engine x times, with x times smaller time steps (where x is a parameter that can be adjusted). At each of those sub-steps, contacts are created and destroyed. With the dynamicPass argument you can select which sub-step you wish to retrieve contacts from (zero-based index), or sim_handle_all to retrieve the contacts of all sub-steps. See also simGetInt32Parameter(sim_intparam_dynamic_step_divider).objectHandle: handle of a specific object you wish to retrieve contacts from, or sim_handle_all to retrieve all contacts in the scene.index: zero-based index of the contact to retrieve. Optionally, you may add sim_handleflag_extended to the index, if you also wish to retrieve the normal vector (see further down)objectHandles: handles of the two objects contacting. The handles might also refer to particle objects that are not treated as regular scene objects.contactInfo: pointer to 6 values (or 9 values if sim_handleflag_extended was added to index), where the 3 first values represent the contact position, the 3 next values represent the force generated by the contact, and the (optional) 3 last values represent the normal vector at the contact.dynamicPass: a specific dynamic sub-step index or sim_handle_all. By default a call to simHandleDynamics executes the dynamics engine x times, with x times smaller time steps (where x is a parameter that can be adjusted). At each of those sub-steps, contacts are created and destroyed. With the dynamicPass argument you can select which sub-step you wish to retrieve contacts from (zero-based index), or sim_handle_all to retrieve the contacts of all sub-steps. See also simGetInt32Parameter(sim_intparam_dynamic_step_divider).objectHandle: handle of a specific object you wish to retrieve contacts from, or sim_handle_all to retrieve all contacts in the scene.index: zero-based index of the contact to retrieve. Optionally, you may add sim_handleflag_extended to the index, if you also wish to retrieve the normal vector (see further down)objectHandles: handles of the two objects contacting. The handles might also refer to particle objects that are not treated as regular scene objects.contactInfo: pointer to 6 values (or 9 values if sim_handleflag_extended was added to index), where the 3 first values represent the contact position, the 3 next values represent the force generated by the contact, and the (optional) 3 last values represent the normal vector at the contact.dynamicPass: a specific dynamic sub-step index or sim_handle_all. By default a call to simHandleDynamics executes the dynamics engine x times, with x times smaller time steps (where x is a parameter that can be adjusted). At each of those sub-steps, contacts are created and destroyed. With the dynamicPass argument you can select which sub-step you wish to retrieve contacts from (zero-based index), or sim_handle_all to retrieve the contacts of all sub-steps. See also simGetInt32Parameter(sim_intparam_dynamic_step_divider).objectHandle: handle of a specific object you wish to retrieve contacts from, or sim_handle_all to retrieve all contacts in the scene.index: zero-based index of the contact to retrieve. Optionally, you may add sim_handleflag_extended to the index, if you also wish to retrieve the normal vector (see further down)objectHandles: handles of the two objects contacting. The handles might also refer to particle objects that are not treated as regular scene objects.contactInfo: pointer to 6 values (or 9 values if sim_handleflag_extended was added to index), where the 3 first values represent the contact position, the 3 next values represent the force generated by the contact, and the (optional) 3 last values represent the normal vector at the contact.dynamicPass: a specific dynamic sub-step index or sim_handle_all. By default a call to simHandleDynamics executes the dynamics engine x times, with x times smaller time steps (where x is a parameter that can be adjusted). At each of those sub-steps, contacts are created and destroyed. With the dynamicPass argument you can select which sub-step you wish to retrieve contacts from (zero-based index), or sim_handle_all to retrieve the contacts of all sub-steps. See also simGetInt32Parameter(sim_intparam_dynamic_step_divider).objectHandle: handle of a specific object you wish to retrieve contacts from, or sim_handle_all to retrieve all contacts in the scene.index: zero-based index of the contact to retrieve. Optionally, you may add sim_handleflag_extended to the index, if you also wish to retrieve the normal vector (see further down)objectHandles: handles of the two objects contacting. The handles might also refer to particle objects that are not treated as regular scene objects.contactInfo: pointer to 6 values (or 9 values if sim_handleflag_extended was added to index), where the 3 first values represent the contact position, the 3 next values represent the force generated by the contact, and the (optional) 3 last values represent the normal vector at the contact.dynamicPass: a specific dynamic sub-step index or sim_handle_all. By default a call to simHandleDynamics executes the dynamics engine x times, with x times smaller time steps (where x is a parameter that can be adjusted). At each of those sub-steps, contacts are created and destroyed. With the dynamicPass argument you can select which sub-step you wish to retrieve contacts from (zero-based index), or sim_handle_all to retrieve the contacts of all sub-steps. See also simGetInt32Parameter(sim_intparam_dynamic_step_divider).objectHandle: handle of a specific object you wish to retrieve contacts from, or sim_handle_all to retrieve all contacts in the scene.index: zero-based index of the contact to retrieve. Optionally, you may add sim_handleflag_extended to the index, if you also wish to retrieve the normal vector (see further down)objectHandles: handles of the two objects contacting. The handles might also refer to particle objects that are not treated as regular scene objects.contactInfo: pointer to 6 values (or 9 values if sim_handleflag_extended was added to index), where the 3 first values represent the contact position, the 3 next values represent the force generated by the contact, and the (optional) 3 last values represent the normal vector at the contact.dynamicPass: a specific dynamic sub-step index or sim_handle_all. By default a call to simHandleDynamics executes the dynamics engine x times, with x times smaller time steps (where x is a parameter that can be adjusted). At each of those sub-steps, contacts are created and destroyed. With the dynamicPass argument you can select which sub-step you wish to retrieve contacts from (zero-based index), or sim_handle_all to retrieve the contacts of all sub-steps. See also simGetInt32Parameter(sim_intparam_dynamic_step_divider).objectHandle: handle of a specific object you wish to retrieve contacts from, or sim_handle_all to retrieve all contacts in the scene.index: zero-based index of the contact to retrieve. Optionally, you may add sim_handleflag_extended to the index, if you also wish to retrieve the normal vector (see further down)objectHandles: handles of the two objects contacting. The handles might also refer to particle objects that are not treated as regular scene objects.contactInfo: pointer to 6 values (or 9 values if sim_handleflag_extended was added to index), where the 3 first values represent the contact position, the 3 next values represent the force generated by the contact, and the (optional) 3 last values represent the normal vector at the contact. -1 in case of an error, 0 if no contact was found at the given index or 1 if a contact was returned."
    }, 
    "simRRS1.GET_CURRENT_TARGETID": {
        "body": "simRRS1.GET_CURRENT_TARGETID()", 
        "scope": "source.lua", 
        "prefix": "simRRS1.GET_CURRENT_TARGETID", 
        "description": "int status,int targetId= simRRS1.GET_CURRENT_TARGETID()"
    }, 
    "simUI.curve_scatter_shape.circle": {
        "body": "simUI.curve_scatter_shape.circle", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_scatter_shape.circle", 
        "description": "Constants"
    }, 
    "simRRS1.STOP_MOTION": {
        "body": "simRRS1.STOP_MOTION()", 
        "scope": "source.lua", 
        "prefix": "simRRS1.STOP_MOTION", 
        "description": "int status= simRRS1.STOP_MOTION()"
    }, 
    "coroutine.create": {
        "body": "coroutine.create( ${1:function} )", 
        "scope": "source.lua", 
        "prefix": "coroutine.create", 
        "description": "5.1,5.2,5.3\n\ncoroutine.create"
    }, 
    "string.pack": {
        "body": "string.pack(${0:...})", 
        "scope": "source.lua", 
        "prefix": "string.pack", 
        "description": "5.3\n\nstring.pack (fmt, v1, v2, ...)"
    }, 
    "sim.modelproperty_not_measurable": {
        "body": "sim.modelproperty_not_measurable", 
        "scope": "source.lua", 
        "prefix": "sim.modelproperty_not_measurable", 
        "description": "Constants"
    }, 
    "sim.openTextEditor": {
        "body": "sim.openTextEditor(${0:initText},${1:xml=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.openTextEditor", 
        "description": "string text,table_2 size,table_2 position = sim.openTextEditor(string initText,string xml=nil)Opens a modal text edition window. initText: a pointer to the initial text to be displayed.xml: a pointer to an XML description of the text editor's properties. Can be NULL for default properties. Following is a valid content:<editor title=Window title editable=true searchable=true  tabWidth=4 textColor=50 50 50 backgroundColor=190 190 190  selectionColor=128 128 255 size=800 600 position=100 100 >  <keywords1 color=152 0 0 >    <item word=simGetObjectHandle autocomplete=true      calltip=number handle=simGetObjectHandle(number objectName) />    <item word=simGetObjectPosition autocomplete=true      calltip=table_3 pos=simGetObjectPosition(number handle,        number relHandle) />  </keywords1>  <keywords2 color=220 80 20 >    <item word=simGetObjectOrientation autocomplete=true      calltip=table_3 euler=simGetObjectOrientation(number handle,        number relHandle) />  </keywords2></editor>Other editor attributes with their default values are:isLua=falseuseVrepKeywords=falsecommentColor=0 140 0numberColor=220 0 220stringColor=255 255 0characterColor=255 255 0operatorColor=0 0 0preprocessorColor=0 128 128identifierColor=64 64 64wordColor=0 0 255word4Color=152 64 0reserved: reserved for future extension. Set to NULL.initText: a pointer to the initial text to be displayed.xml: a pointer to an XML description of the text editor's properties. Can be NULL for default properties. Following is a valid content:<editor title=Window title editable=true searchable=true  tabWidth=4 textColor=50 50 50 backgroundColor=190 190 190  selectionColor=128 128 255 size=800 600 position=100 100 >  <keywords1 color=152 0 0 >    <item word=simGetObjectHandle autocomplete=true      calltip=number handle=simGetObjectHandle(number objectName) />    <item word=simGetObjectPosition autocomplete=true      calltip=table_3 pos=simGetObjectPosition(number handle,        number relHandle) />  </keywords1>  <keywords2 color=220 80 20 >    <item word=simGetObjectOrientation autocomplete=true      calltip=table_3 euler=simGetObjectOrientation(number handle,        number relHandle) />  </keywords2></editor>Other editor attributes with their default values are:isLua=falseuseVrepKeywords=falsecommentColor=0 140 0numberColor=220 0 220stringColor=255 255 0characterColor=255 255 0operatorColor=0 0 0preprocessorColor=0 128 128identifierColor=64 64 64wordColor=0 0 255word4Color=152 64 0reserved: reserved for future extension. Set to NULL.initText: a pointer to the initial text to be displayed.xml: a pointer to an XML description of the text editor's properties. Can be NULL for default properties. Following is a valid content:<editor title=Window title editable=true searchable=true  tabWidth=4 textColor=50 50 50 backgroundColor=190 190 190  selectionColor=128 128 255 size=800 600 position=100 100 >  <keywords1 color=152 0 0 >    <item word=simGetObjectHandle autocomplete=true      calltip=number handle=simGetObjectHandle(number objectName) />    <item word=simGetObjectPosition autocomplete=true      calltip=table_3 pos=simGetObjectPosition(number handle,        number relHandle) />  </keywords1>  <keywords2 color=220 80 20 >    <item word=simGetObjectOrientation autocomplete=true      calltip=table_3 euler=simGetObjectOrientation(number handle,        number relHandle) />  </keywords2></editor>Other editor attributes with their default values are:isLua=falseuseVrepKeywords=falsecommentColor=0 140 0numberColor=220 0 220stringColor=255 255 0characterColor=255 255 0operatorColor=0 0 0preprocessorColor=0 128 128identifierColor=64 64 64wordColor=0 0 255word4Color=152 64 0reserved: reserved for future extension. Set to NULL. NULL in case of an error. Otherwise a pointer to the text. The user is in charge of releasing the returned buffer with simReleaseBuffer."
    }, 
    "sim.dynmat_highfriction": {
        "body": "sim.dynmat_highfriction", 
        "scope": "source.lua", 
        "prefix": "sim.dynmat_highfriction", 
        "description": "Constants"
    }, 
    "sim.removeObjectFromSelection": {
        "body": "sim.removeObjectFromSelection(${0:what},${1:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.removeObjectFromSelection", 
        "description": "number result = sim.removeObjectFromSelection(number what,number objectHandle)Removes an object from the selection. See also sim.addObjectToSelection,  sim.isObjectInSelection and sim.getObjectSelection. What: indicates what we wish to remove from the selection. Valid values are sim_handle_single (removes one object from the selection), sim_handle_all (removes all objects from the selection), sim_handle_tree (removes the tree with base objectHandle (inclusive) from the selection, sim_handle_chain (removes the chain with tip objectHandle (inclusive) from the selection.objectHandle: handle of the object to remove from the selection. If sim_handle_all is specifies in what, then objectHandle is ignoredWhat: indicates what we wish to remove from the selection. Valid values are sim_handle_single (removes one object from the selection), sim_handle_all (removes all objects from the selection), sim_handle_tree (removes the tree with base objectHandle (inclusive) from the selection, sim_handle_chain (removes the chain with tip objectHandle (inclusive) from the selection.objectHandle: handle of the object to remove from the selection. If sim_handle_all is specifies in what, then objectHandle is ignoredWhat: indicates what we wish to remove from the selection. Valid values are sim_handle_single (removes one object from the selection), sim_handle_all (removes all objects from the selection), sim_handle_tree (removes the tree with base objectHandle (inclusive) from the selection, sim_handle_chain (removes the chain with tip objectHandle (inclusive) from the selection.objectHandle: handle of the object to remove from the selection. If sim_handle_all is specifies in what, then objectHandle is ignored -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simRRS1.MODIFY_CELL_FRAME": {
        "body": "simRRS1.MODIFY_CELL_FRAME(${0:rcsHandle},${1:storage},${2:frameId})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.MODIFY_CELL_FRAME", 
        "description": "int status= simRRS1.MODIFY_CELL_FRAME(bitstring2 rcsHandle,int storage,string frameId)"
    }, 
    "sim.intparam_visible_layers": {
        "body": "sim.intparam_visible_layers", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_visible_layers", 
        "description": "Constants"
    }, 
    "sim.getQuaternionFromMatrix": {
        "body": "sim.getQuaternionFromMatrix(${0:matrix})", 
        "scope": "source.lua", 
        "prefix": "sim.getQuaternionFromMatrix", 
        "description": "table_4 quaternion = sim.getQuaternionFromMatrix(table_12 matrix)Retrieves the quaternion from a transformation matrix. See also sim.getEulerAnglesFromMatrix and the other matrix/transformation functions. matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])quaternion: pointer to 4 simFloat values representing the quaternion in the matrix (x,y,z,w)matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])quaternion: pointer to 4 simFloat values representing the quaternion in the matrix (x,y,z,w)matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])quaternion: pointer to 4 simFloat values representing the quaternion in the matrix (x,y,z,w)matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])quaternion: pointer to 4 simFloat values representing the quaternion in the matrix (x,y,z,w)matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])quaternion: pointer to 4 simFloat values representing the quaternion in the matrix (x,y,z,w)matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])quaternion: pointer to 4 simFloat values representing the quaternion in the matrix (x,y,z,w) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.vortex_joint_bitcoded": {
        "body": "sim.vortex_joint_bitcoded", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_bitcoded", 
        "description": "Constants"
    }, 
    "package.searchers": {
        "body": "package.searchers(${0:...})", 
        "scope": "source.lua", 
        "prefix": "package.searchers", 
        "description": "5.2,5.3\n\npackage.searchers"
    }, 
    "simCHAI3D.readPosition": {
        "body": "simCHAI3D.readPosition(${0:deviceIndex})", 
        "scope": "source.lua", 
        "prefix": "simCHAI3D.readPosition", 
        "description": "table_3 position = simCHAI3D.readPosition(number deviceIndex)"
    }, 
    "io.read": {
        "body": "io.read(${0:...})", 
        "scope": "source.lua", 
        "prefix": "io.read", 
        "description": "5.1,5.2,5.3\n\nio.read (...)"
    }, 
    "simROS.sendTransform": {
        "body": "simROS.sendTransform(${0:transform})", 
        "scope": "source.lua", 
        "prefix": "simROS.sendTransform", 
        "description": "simROS.sendTransform(table transform)"
    }, 
    "sim.objectspecialproperty_detectable_infrared": {
        "body": "sim.objectspecialproperty_detectable_infrared", 
        "scope": "source.lua", 
        "prefix": "sim.objectspecialproperty_detectable_infrared", 
        "description": "Constants"
    }, 
    "sim.getObjectStringParameter": {
        "body": "sim.getObjectStringParameter(${0:objectHandle},${1:parameterID})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectStringParameter", 
        "description": "string parameter = sim.getObjectStringParameter(number objectHandle,number parameterID)Retrieves a string parameter of a scene object or calculation object. See also sim.setObjectStringParameter, sim.getObjectInt32Parameter and sim.getObjectFloatParameter objectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameterLength: the length of the retrieved parameterobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameterLength: the length of the retrieved parameterobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameterLength: the length of the retrieved parameterobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameterLength: the length of the retrieved parameter A buffer containing the retrieved string, or NULL in case of an error. The user is in charge of releasing the returned buffer with simReleaseBuffer. The returned buffer might contain embedded zeros, and its length is specified by the parameterLength argument."
    }, 
    "sim.getTextureId": {
        "body": "sim.getTextureId(${0:textureName})", 
        "scope": "source.lua", 
        "prefix": "sim.getTextureId", 
        "description": "number textureId,table_2 resolution = sim.getTextureId(string textureName)Retrieves the texture ID of a specific texture. See also sim.readTexture,  sim.writeTexture and sim.createTexture. textureName: the name of the texture ID to be retrieved.resolution: a pointer to 2 integer values representing the resolution of the texture. Can be NULL.textureName: the name of the texture ID to be retrieved.resolution: a pointer to 2 integer values representing the resolution of the texture. Can be NULL. The texture ID, or -1 if the texture does not exist or in case of an error"
    }, 
    "simUI.getSpinboxValue": {
        "body": "simUI.getSpinboxValue(${0:handle},${1:id})", 
        "scope": "source.lua", 
        "prefix": "simUI.getSpinboxValue", 
        "description": "number value = simUI.getSpinboxValue(number handle,number id)"
    }, 
    "simx.getVisionSensorDepthBuffer": {
        "body": "simx.getVisionSensorDepthBuffer(${0:clientId},${1:sensorHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.getVisionSensorDepthBuffer", 
        "description": "number returnCode,table buffer,table_2 resolution= simx.getVisionSensorDepthBuffer(number clientId,number sensorHandle)Retrieves the depth buffer of a vision sensor. The returned data doesn't make sense if sim.handleVisionSensor wasn't called previously (sim.handleVisionSensor is called by default in the main script if the vision sensor is not tagged as explicit handling). Use the simx.getLastCmdTime function to verify the freshness of the retrieved data. See also simx.getVisionSensorImage. clientID: the client ID. refer to simx.start.sensorHandle: handle of the vision sensoroperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls) returnCode: a remote API function return codebuffer: the depth buffer data. Values are in the range of 0-1 (0=closest to sensor, 1=farthest from sensor)resolution: the resolution of the image"
    }, 
    "sim.pathproperty_closed_path": {
        "body": "sim.pathproperty_closed_path", 
        "scope": "source.lua", 
        "prefix": "sim.pathproperty_closed_path", 
        "description": "Constants"
    }, 
    "simUI.getNodePos": {
        "body": "simUI.getNodePos(${0:handle},${1:id},${2:nodeId})", 
        "scope": "source.lua", 
        "prefix": "simUI.getNodePos", 
        "description": "number x,number y = simUI.getNodePos(number handle,number id,number nodeId)"
    }, 
    "sim.dummy_linktype_gcs_tip": {
        "body": "sim.dummy_linktype_gcs_tip", 
        "scope": "source.lua", 
        "prefix": "sim.dummy_linktype_gcs_tip", 
        "description": "Constants"
    }, 
    "sim.scripttype_threaded": {
        "body": "sim.scripttype_threaded", 
        "scope": "source.lua", 
        "prefix": "sim.scripttype_threaded", 
        "description": "Constants"
    }, 
    "io.tmpfile": {
        "body": "io.tmpfile(${0:...})", 
        "scope": "source.lua", 
        "prefix": "io.tmpfile", 
        "description": "5.1,5.2,5.3\n\nio.tmpfile ()"
    }, 
    "simx.setVisionSensorImage": {
        "body": "simx.setVisionSensorImage(${0:clientId},${1:sensorHandle},${2:image},${3:options})", 
        "scope": "source.lua", 
        "prefix": "simx.setVisionSensorImage", 
        "description": "number returnCode= simx.setVisionSensorImage(number clientId,number sensorHandle,string image,number options)Sets the image of a vision sensor (and applies any image processing filter if specified in the vision sensor dialog). Make sure the vision sensor is flagged as use external image. The regular use of this function is to first read the data from a vision sensor with simx.getVisionSensorImage, do some custom filtering, then write the modified image to a passive vision sensor. The alternate use of this function is to display textures, video images, etc. by using a vision sensor object (without however making use of the vision sensor functionality), since a vision sensor can be looked through like camera objects. clientID: the client ID. refer to simx.start.sensorHandle: handle of the vision sensorimage: the image dataoptions: image options, bit-coded:operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "simOMPL.printTaskInfo": {
        "body": "simOMPL.printTaskInfo(${0:taskHandle})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.printTaskInfo", 
        "description": "number result = simOMPL.printTaskInfo(number taskHandle)"
    }, 
    "sim.newton_body_fastmoving": {
        "body": "sim.newton_body_fastmoving", 
        "scope": "source.lua", 
        "prefix": "sim.newton_body_fastmoving", 
        "description": "Constants"
    }, 
    "sim.boolAnd32": {
        "body": "sim.boolAnd32(${0:value1},${1:value2})", 
        "scope": "source.lua", 
        "prefix": "sim.boolAnd32", 
        "description": "number result = sim.boolAnd32(number value1,number value2)Performs a 32-bit Boolean AND operation between two numbers. See also sim.boolOr32 and sim.boolXor32. - -"
    }, 
    "sim.ode_joint_stoperp": {
        "body": "sim.ode_joint_stoperp", 
        "scope": "source.lua", 
        "prefix": "sim.ode_joint_stoperp", 
        "description": "Constants"
    }, 
    "simx.setObjectPosition": {
        "body": "simx.setObjectPosition(${0:clientId},${1:objectHandle},${2:relativeToObjectHandle},${3:eulerAngles})", 
        "scope": "source.lua", 
        "prefix": "simx.setObjectPosition", 
        "description": "number returnCode= simx.setObjectPosition(number clientId,number objectHandle,number relativeToObjectHandle,table_3 eulerAngles)"
    }, 
    "sysCall_afterCopy": {
        "body": "sysCall_afterCopy(${0:keys.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_afterCopy", 
        "description": "sysCall_afterCopy(called just after objects were copied. Arg1 is a map with 'objectHandles' keys.)"
    }, 
    "simRRS1.EXTENDED_SERVICE": {
        "body": "simRRS1.EXTENDED_SERVICE(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.EXTENDED_SERVICE", 
        "description": "int status,string outData= simRRS1.EXTENDED_SERVICE(bitstring2 rcsHandle)"
    }, 
    "_G": {
        "body": "_G(${0:...})", 
        "scope": "source.lua", 
        "prefix": "_G", 
        "description": "5.1,5.2,5.3\n\n_G"
    }, 
    "sim.getApiFunc": {
        "body": "sim.getApiFunc(${0:scriptHandleOrType},${1:apiWord})", 
        "scope": "source.lua", 
        "prefix": "sim.getApiFunc", 
        "description": "table funcsAndVars = sim.getApiFunc(number scriptHandleOrType,string apiWord)Retrieves all API functions and variables that match a specific word. Useful for script code auto-completion functionality. See also sim.getApiInfo. scriptHandleOrType: the handle of the script, otherwise the type of the script.apiWord: the word that API functions and variables should match, e.g. sim.getObjscriptHandleOrType: the handle of the script, otherwise the type of the script.apiWord: the word that API functions and variables should match, e.g. sim.getObj NULL in case of an error, or if there is no match. Otherwise all matching API functions and variables, space-separated. The user is in charge of releasing the returned buffer with simReleaseBuffer."
    }, 
    "simx.getObjectPosition": {
        "body": "simx.getObjectPosition(${0:clientId},${1:objectHandle},${2:relativeToObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.getObjectPosition", 
        "description": "number returnCode,table_3 position= simx.getObjectPosition(number clientId,number objectHandle,number relativeToObjectHandle)Retrieves the position  of an object. See also simx.setObjectPosition, simx.getObjectOrientation, simx.getObjectQuaternion and simx.getObjectGroupData. clientID: the client ID. refer to simx.start.objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the position.   Specify -1 to retrieve the absolute position, sim.handle_parent to   retrieve the position relative to the object's parent, or an object   handle relative to whose reference frame you want the positionoperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls) returnCode: a remote API function return codeposition: the position"
    }, 
    "sim.handle_default": {
        "body": "sim.handle_default", 
        "scope": "source.lua", 
        "prefix": "sim.handle_default", 
        "description": "Constants"
    }, 
    "sim.packUInt8Table": {
        "body": "sim.packUInt8Table(${0:uint8Numbers},${1:startUint8Index=0},${2:uint8count=0})", 
        "scope": "source.lua", 
        "prefix": "sim.packUInt8Table", 
        "description": "string data = sim.packUInt8Table(table uint8Numbers,number startUint8Index=0,number uint8count=0)Packs a table of uint8 numbers into a string. See also sim.unpackUInt8Table and the other packing/unpacking functions. - -"
    }, 
    "simx.setJointForce": {
        "body": "simx.setJointForce(${0:clientId},${1:jointHandle},${2:force})", 
        "scope": "source.lua", 
        "prefix": "simx.setJointForce", 
        "description": "number returnCode= simx.setJointForce(number clientId,number jointHandle,number force)Sets the maximum force or torque that a joint can exert. This function has no effect when the joint is not dynamically enabled, or when it is a spherical joint. See also simx.getJointForce. clientID: the client ID. refer to simx.start.jointHandle: handle of the jointforce: the maximum force or torque that the joint can exertoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "setfenv": {
        "body": "setfenv(${0:...})", 
        "scope": "source.lua", 
        "prefix": "setfenv", 
        "description": "5.1\n\nsetfenv (f, table)"
    }, 
    "simRRS1.SET_CONVEYOR_POSITION": {
        "body": "simRRS1.SET_CONVEYOR_POSITION(${0:rcsHandle},${1:inputFormat},${2:conveyorFlags})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_CONVEYOR_POSITION", 
        "description": "int status= simRRS1.SET_CONVEYOR_POSITION(bitstring2 rcsHandle,bitstring inputFormat,bitstring conveyorFlags)"
    }, 
    "simBubble.start": {
        "body": "simBubble.start(${0:bubbleRobHandle},${1:duration},${2:returnDirectly=false})", 
        "scope": "source.lua", 
        "prefix": "simBubble.start", 
        "description": "boolean result = simBubble.start(number bubbleRobHandle,number duration,boolean returnDirectly=false)"
    }, 
    "simx.getStringSignal": {
        "body": "simx.getStringSignal(${0:clientId},${1:signalName})", 
        "scope": "source.lua", 
        "prefix": "simx.getStringSignal", 
        "description": "number returnCode,string signalValue= simx.getStringSignal(number clientId,string signalName)Gets the value of a string signal. Signals are cleared at simulation start. To pack/unpack integers/floats into/from a string, refer to simx.packInts, simx.packFloats, simx.unpackInts and simx.unpackFloats. See also simx.setStringSignal, simx.readStringStream, simx.clearStringSignal, simx.getIntegerSignal and simx.getFloatSignal. clientID: the client ID. refer to simx.start.signalName: name of the signaloperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls) returnCode: a remote API function return codesignalValue: the value of the signal"
    }, 
    "debug.getuservalue ": {
        "body": "debug.getuservalue ( ${1:u} )", 
        "scope": "source.lua", 
        "prefix": "debug.getuservalue ", 
        "description": "debug.getuservalue (u)"
    }, 
    "sim.jointfloatparam_pid_p": {
        "body": "sim.jointfloatparam_pid_p", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_pid_p", 
        "description": "Constants"
    }, 
    "sim.script_main_not_called": {
        "body": "sim.script_main_not_called", 
        "scope": "source.lua", 
        "prefix": "sim.script_main_not_called", 
        "description": "Constants"
    }, 
    "sim.shapestringparam_color_name": {
        "body": "sim.shapestringparam_color_name", 
        "scope": "source.lua", 
        "prefix": "sim.shapestringparam_color_name", 
        "description": "Constants"
    }, 
    "simx.getJointPosition": {
        "body": "simx.getJointPosition(${0:clientId},${1:jointHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.getJointPosition", 
        "description": "number returnCode,number position= simx.getJointPosition(number clientId,number jointHandle)Retrieves the intrinsic position of a joint. This function cannot be used with spherical joints (use simx.getJointMatrix instead). See also simx.setJointPosition and simx.getObjectGroupData. clientID: the client ID. refer to simx.start.jointHandle: handle of the jointoperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls) returnCode: a remote API function return codeposition: intrinsic position of the joint. This is a one-dimensional value: if the joint is revolute, the rotation angle is returned, if the joint is prismatic, the translation amount is returned, etc."
    }, 
    "sim.filtercomponent_normalize": {
        "body": "sim.filtercomponent_normalize", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_normalize", 
        "description": "Constants"
    }, 
    "simx.displayDialog": {
        "body": "simx.displayDialog(${0:clientId},${1:titleText},${2:mainText},${3:dialogType},${4:initialText},${5:titleColors},${6:dialogColors})", 
        "scope": "source.lua", 
        "prefix": "simx.displayDialog", 
        "description": "number returnCode,number dialogHandle,number UiHandle= simx.displayDialog(number clientId,string titleText,string mainText,number dialogType,string initialText,table_6 titleColors,table_6 dialogColors)Displays a generic dialog box during simulation (and only during simulation!). Use in conjunction with simx.getDialogResult, simx.getDialogInput and simx.endDialog. Use custom user interfaces instead if a higher customization level is required. clientID: the client ID. refer to simx.start.titleText: Title bar textmainText: Information textdialogType: a generic dialog styleinitialText: Initial text in the edit box if the dialog is of type sim.dlgstyle_input. Cannot be nil!titleColors: Title bar color (6  values for RGB for background and foreground), can be nil for default colorsdialogColors: Dialog color (6 values for RGB for background and foreground), can be nil for default colorsoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return codedialogHandle: handle of the generic dialog (different from OpenGl-based custom UI handle!! (see hereafter)). This handle should be used with the following functions: simx.getDialogResult, simx.getDialogInput and simx.endDialog.uiHandle: handle of the corresponding OpenGl-based custom UI."
    }, 
    "sim.mirrorfloatparam_reflectance": {
        "body": "sim.mirrorfloatparam_reflectance", 
        "scope": "source.lua", 
        "prefix": "sim.mirrorfloatparam_reflectance", 
        "description": "Constants"
    }, 
    "simRRS1.CONTINUE_MOTION": {
        "body": "simRRS1.CONTINUE_MOTION()", 
        "scope": "source.lua", 
        "prefix": "simRRS1.CONTINUE_MOTION", 
        "description": "int status= simRRS1.CONTINUE_MOTION()"
    }, 
    "sim.buttonproperty_staydown": {
        "body": "sim.buttonproperty_staydown", 
        "scope": "source.lua", 
        "prefix": "sim.buttonproperty_staydown", 
        "description": "Constants"
    }, 
    "sim.displayattribute_forbidwireframe": {
        "body": "sim.displayattribute_forbidwireframe", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_forbidwireframe", 
        "description": "Constants"
    }, 
    "sim.mill_disc_subtype": {
        "body": "sim.mill_disc_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.mill_disc_subtype", 
        "description": "Constants"
    }, 
    "sim.displayDialog": {
        "body": "sim.displayDialog(${0:title},${1:mainText},${2:style},${3:modal},${4:initTxt},${5:titleColors},${6:dlgColors})", 
        "scope": "source.lua", 
        "prefix": "sim.displayDialog", 
        "description": "number genericDlgHandle,number UIHandle = sim.displayDialog(string title,string mainText,number style,boolean modal,string initTxt,table_6 titleColors,table_6 dlgColors)Displays a generic dialog box. Use in conjunction with sim.getDialogResult ,sim.getDialogInput and sim.endDialog. From C, the function will only create non-modal dialogs (non-blocking), from Lua, modal dialogs can be created if called from a child script that runs in a thread. Use custom user interfaces instead if a higher customization level is required. Dialogs displayed from a main script or a child script will automatically close at simulation end. See also sim.msgBox and sim.fileDialog. titleText: Title bar textmainText: Information textdialogType: generic dialog styleinitialText: Initial text in the edit box if the dialog is of type sim_dlgstyle_input. Can be NULLtitleColors: Title bar color (6 simFloat values for RGB for background and foreground), can be NULL for default colorsdialogColors: Dialog color (6 simFloat values for RGB for background and foreground), can be NULL for default colorsuiHandle: corresponding OpenGl-based custom UI handle. Can be NULLtitleText: Title bar textmainText: Information textdialogType: generic dialog styleinitialText: Initial text in the edit box if the dialog is of type sim_dlgstyle_input. Can be NULLtitleColors: Title bar color (6 simFloat values for RGB for background and foreground), can be NULL for default colorsdialogColors: Dialog color (6 simFloat values for RGB for background and foreground), can be NULL for default colorsuiHandle: corresponding OpenGl-based custom UI handle. Can be NULLtitleText: Title bar textmainText: Information textdialogType: generic dialog styleinitialText: Initial text in the edit box if the dialog is of type sim_dlgstyle_input. Can be NULLtitleColors: Title bar color (6 simFloat values for RGB for background and foreground), can be NULL for default colorsdialogColors: Dialog color (6 simFloat values for RGB for background and foreground), can be NULL for default colorsuiHandle: corresponding OpenGl-based custom UI handle. Can be NULLtitleText: Title bar textmainText: Information textdialogType: generic dialog styleinitialText: Initial text in the edit box if the dialog is of type sim_dlgstyle_input. Can be NULLtitleColors: Title bar color (6 simFloat values for RGB for background and foreground), can be NULL for default colorsdialogColors: Dialog color (6 simFloat values for RGB for background and foreground), can be NULL for default colorsuiHandle: corresponding OpenGl-based custom UI handle. Can be NULLtitleText: Title bar textmainText: Information textdialogType: generic dialog styleinitialText: Initial text in the edit box if the dialog is of type sim_dlgstyle_input. Can be NULLtitleColors: Title bar color (6 simFloat values for RGB for background and foreground), can be NULL for default colorsdialogColors: Dialog color (6 simFloat values for RGB for background and foreground), can be NULL for default colorsuiHandle: corresponding OpenGl-based custom UI handle. Can be NULLtitleText: Title bar textmainText: Information textdialogType: generic dialog styleinitialText: Initial text in the edit box if the dialog is of type sim_dlgstyle_input. Can be NULLtitleColors: Title bar color (6 simFloat values for RGB for background and foreground), can be NULL for default colorsdialogColors: Dialog color (6 simFloat values for RGB for background and foreground), can be NULL for default colorsuiHandle: corresponding OpenGl-based custom UI handle. Can be NULLtitleText: Title bar textmainText: Information textdialogType: generic dialog styleinitialText: Initial text in the edit box if the dialog is of type sim_dlgstyle_input. Can be NULLtitleColors: Title bar color (6 simFloat values for RGB for background and foreground), can be NULL for default colorsdialogColors: Dialog color (6 simFloat values for RGB for background and foreground), can be NULL for default colorsuiHandle: corresponding OpenGl-based custom UI handle. Can be NULL handle of generic dialog (different from OpenGl-based custom UI handle!!) if operation was successful, -1 otherwise. The handle should be used with following functions: simGetDialogResult ,simGetDialogInput and simEndDialog."
    }, 
    "sim.vortex_joint_upperlimitdamping": {
        "body": "sim.vortex_joint_upperlimitdamping", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_upperlimitdamping", 
        "description": "Constants"
    }, 
    "sim.setEngineInt32Parameter": {
        "body": "sim.setEngineInt32Parameter(${0:paramId},${1:objectHandle},${2:int32Param})", 
        "scope": "source.lua", 
        "prefix": "sim.setEngineInt32Parameter", 
        "description": "number result = sim.setEngineInt32Parameter(number paramId,number objectHandle,number int32Param)Sets an int32-type physics engine property. You might have to call sim.resetDynamicObject for changes to take effect. See also the other engine properties setter and getter API functions. paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to set a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to set a global engine parameter. If NULL, then the objectHandle argument will be evaluated.val: the new property values.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to set a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to set a global engine parameter. If NULL, then the objectHandle argument will be evaluated.val: the new property values.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to set a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to set a global engine parameter. If NULL, then the objectHandle argument will be evaluated.val: the new property values.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to set a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to set a global engine parameter. If NULL, then the objectHandle argument will be evaluated.val: the new property values. 1 in case of success. This function call doesn't generate any error message."
    }, 
    "coroutine.yield": {
        "body": "coroutine.yield( ${1:...} )", 
        "scope": "source.lua", 
        "prefix": "coroutine.yield", 
        "description": "5.1,5.2,5.3\n\ncoroutine.yield"
    }, 
    "sim.addScript": {
        "body": "sim.addScript(${0:scriptType})", 
        "scope": "source.lua", 
        "prefix": "sim.addScript", 
        "description": "number scriptHandle = sim.addScript(number scriptType)Inserts a new script. Use with care when simulation is running. See also sim.associateScriptWithObject. scriptType: type of the script. handle of the new script, or -1 in case of an error"
    }, 
    "sim.simulation_advancing_lastbeforestop": {
        "body": "sim.simulation_advancing_lastbeforestop", 
        "scope": "source.lua", 
        "prefix": "sim.simulation_advancing_lastbeforestop", 
        "description": "Constants"
    }, 
    "sim.customizationscriptcall_nonsimulation": {
        "body": "sim.customizationscriptcall_nonsimulation", 
        "scope": "source.lua", 
        "prefix": "sim.customizationscriptcall_nonsimulation", 
        "description": "Constants"
    }, 
    "sim.objectproperty_dontshowasinsidemodel": {
        "body": "sim.objectproperty_dontshowasinsidemodel", 
        "scope": "source.lua", 
        "prefix": "sim.objectproperty_dontshowasinsidemodel", 
        "description": "Constants"
    }, 
    "simOMPL.setCollisionPairs": {
        "body": "simOMPL.setCollisionPairs(${0:taskHandle},${1:collisionPairHandles})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.setCollisionPairs", 
        "description": "number result = simOMPL.setCollisionPairs(number taskHandle,table collisionPairHandles)"
    }, 
    "simx.setIntegerSignal": {
        "body": "simx.setIntegerSignal(${0:clientId},${1:signalName},${2:signalValue})", 
        "scope": "source.lua", 
        "prefix": "simx.setIntegerSignal", 
        "description": "number returnCode= simx.setIntegerSignal(number clientId,string signalName,number signalValue)Sets the value of an integer signal. If that signal is not yet present, it is added. See also simx.getIntegerSignal, simx.clearIntegerSignal, simx.setFloatSignal and simx.setStringSignal. clientID: the client ID. refer to simx.start.signalName: name of the signalsignalValue: value of the signaloperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "sim.setJointInterval": {
        "body": "sim.setJointInterval(${0:objectHandle},${1:cyclic},${2:interval})", 
        "scope": "source.lua", 
        "prefix": "sim.setJointInterval", 
        "description": "number result = sim.setJointInterval(number objectHandle,boolean cyclic,table_2 interval)Sets the interval parameters of a joint (i.e. range values). The attributes or interval parameters might have no effect, depending on the joint-type. See also sim.getJointInterval. objectHandle: handle of the joint objectcyclic: indicates whether the joint is cyclic. Only revolute joints with a pitch of 0 can be cyclicinterval: interval of the joint. interval[0] is the joint minimum allowed value, interval[1] is the joint range (i.e. the maximum allowed value is interval[0]+interval[1])objectHandle: handle of the joint objectcyclic: indicates whether the joint is cyclic. Only revolute joints with a pitch of 0 can be cyclicinterval: interval of the joint. interval[0] is the joint minimum allowed value, interval[1] is the joint range (i.e. the maximum allowed value is interval[0]+interval[1])objectHandle: handle of the joint objectcyclic: indicates whether the joint is cyclic. Only revolute joints with a pitch of 0 can be cyclicinterval: interval of the joint. interval[0] is the joint minimum allowed value, interval[1] is the joint range (i.e. the maximum allowed value is interval[0]+interval[1])objectHandle: handle of the joint objectcyclic: indicates whether the joint is cyclic. Only revolute joints with a pitch of 0 can be cyclicinterval: interval of the joint. interval[0] is the joint minimum allowed value, interval[1] is the joint range (i.e. the maximum allowed value is interval[0]+interval[1]) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.getJointType": {
        "body": "sim.getJointType(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getJointType", 
        "description": "number jointType = sim.getJointType(number objectHandle)Retrieves the type of a joint  objectHandle: handle of the jointobjectHandle: handle of the joint Type of the joint (sim_joint_revolute_subtype, sim_joint_prismatic_subtype or sim_joint_spherical_subtype), or -1 if operation was not successful"
    }, 
    "sim.handleMill": {
        "body": "sim.handleMill(${0:millHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.handleMill", 
        "description": "number cutCount,table_2 removedSurfaceAndVolume = sim.handleMill(number millHandle)Handles (performs cutting) a registered mill object. See also sim.resetMill. millHandle: handle of a mill object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all mill objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)removedSurfaceAndVolume: pointer to two floating point values indicating the total removed surface and volume by this call. Can be NULLmillHandle: handle of a mill object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all mill objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)removedSurfaceAndVolume: pointer to two floating point values indicating the total removed surface and volume by this call. Can be NULLmillHandle: handle of a mill object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all mill objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)removedSurfaceAndVolume: pointer to two floating point values indicating the total removed surface and volume by this call. Can be NULL total number of cut objects, or -1 in case of an error"
    }, 
    "simx.cmdheaderoffset_sim_time": {
        "body": "simx.cmdheaderoffset_sim_time", 
        "scope": "source.lua", 
        "prefix": "simx.cmdheaderoffset_sim_time", 
        "description": "Constants"
    }, 
    "simx.opmode_oneshot_wait": {
        "body": "simx.opmode_oneshot_wait", 
        "scope": "source.lua", 
        "prefix": "simx.opmode_oneshot_wait", 
        "description": "Constants"
    }, 
    "sim.forcefloatparam_error_g": {
        "body": "sim.forcefloatparam_error_g", 
        "scope": "source.lua", 
        "prefix": "sim.forcefloatparam_error_g", 
        "description": "Constants"
    }, 
    "simRRS1.SET_CONFIGURATION_CONTROL": {
        "body": "simRRS1.SET_CONFIGURATION_CONTROL(${0:rcsHandle},${1:paramId})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_CONFIGURATION_CONTROL", 
        "description": "int status= simRRS1.SET_CONFIGURATION_CONTROL(bitstring2 rcsHandle,string paramId)"
    }, 
    "sim.forcefloatparam_error_b": {
        "body": "sim.forcefloatparam_error_b", 
        "scope": "source.lua", 
        "prefix": "sim.forcefloatparam_error_b", 
        "description": "Constants"
    }, 
    "debug.getfenv": {
        "body": "debug.getfenv(${0:...})", 
        "scope": "source.lua", 
        "prefix": "debug.getfenv", 
        "description": "5.1\n\ndebug.getfenv (o)"
    }, 
    "sim.forcefloatparam_error_a": {
        "body": "sim.forcefloatparam_error_a", 
        "scope": "source.lua", 
        "prefix": "sim.forcefloatparam_error_a", 
        "description": "Constants"
    }, 
    "sim.bullet_body_bitcoded": {
        "body": "sim.bullet_body_bitcoded", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_body_bitcoded", 
        "description": "Constants"
    }, 
    "simOMPL.Algorithm.RRTstar": {
        "body": "simOMPL.Algorithm.RRTstar", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.RRTstar", 
        "description": "Constants"
    }, 
    "simUI.setSliderValue": {
        "body": "simUI.setSliderValue(${0:handle},${1:id},${2:value},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setSliderValue", 
        "description": "simUI.setSliderValue(number handle,number id,number value,bool suppressEvents=true)"
    }, 
    "sysCall_beforeInstanceSwitch": {
        "body": "sysCall_beforeInstanceSwitch(${0:switch.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_beforeInstanceSwitch", 
        "description": "sysCall_beforeInstanceSwitch(Called just before an instance switch.)"
    }, 
    "sim.applyMilling": {
        "body": "sim.applyMilling(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.applyMilling", 
        "description": "number result = sim.applyMilling(number objectHandle)Applies changes made during milling operations to a cuttable object (e.g. a shape). This requires some calculation time. Once changes were applied, they cannot be reset anymore. If the milling operation milled away the whole object, then the object is removed from the scene. The calculation structure linked to the object is removed and an updated calculation structure might be calculated (might take some calculation time). See also sim.resetMilling, sim.handleMill and sim.resetMill. objectHandle: handle of the cut object or sim_handle_all to apply changes to all cut objects. objectHandle: handle of the cut object or sim_handle_all to apply changes to all cut objects.  -1 if operation was not successful, 0 if operation was successful but the object was removed from the scene (because entirely cut away) (only available when sim_handle_all is not specified), or 1 if operation was successful and the object still exists in the scene."
    }, 
    "sim.bullet_global_bitcoded": {
        "body": "sim.bullet_global_bitcoded", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_global_bitcoded", 
        "description": "Constants"
    }, 
    "sim.getNavigationMode": {
        "body": "sim.getNavigationMode()", 
        "scope": "source.lua", 
        "prefix": "sim.getNavigationMode", 
        "description": "number navigationMode = sim.getNavigationMode()Retrieves the navigation and selection mode for the mouse. See also sim.setNavigationMode. None navigation mode if operation was successful, -1 otherwise"
    }, 
    "sysCall_br": {
        "body": "sysCall_br(${0:functionality.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_br", 
        "description": "sysCall_br(Called for BlueReality functionality.)"
    }, 
    "sim.isHandleValid": {
        "body": "sim.isHandleValid(${0:generalObjectHandle},${1:generalObjectType=-1})", 
        "scope": "source.lua", 
        "prefix": "sim.isHandleValid", 
        "description": "number result = sim.isHandleValid(number generalObjectHandle,number generalObjectType=-1)Checks whether a general object handle is still valid. When a general object is destroyed (e.g. programmatically or via the user interface), then its related handle is not valid anymore and will trigger an error when used. Use this function to avoid triggering an error. See also sim.getObjectHandle, sim.getCollectionHandle, sim.getCollisionHandle, sim.getDistanceHandle, sim.getMechanismHandle, sim.getIkGroupHandle, sim.getScriptHandle and sim.getObjectUniqueIdentifier. generalOjectHandle: handle of a general-type object (e.g. scene object, collision object, distance object, etc.)generalOjectType: type of the general object. Refer to the general object types. Can be -1, in which case the specified handle is checked for validity in all types (handles of different types never overlap)generalOjectHandle: handle of a general-type object (e.g. scene object, collision object, distance object, etc.)generalOjectType: type of the general object. Refer to the general object types. Can be -1, in which case the specified handle is checked for validity in all types (handles of different types never overlap)generalOjectHandle: handle of a general-type object (e.g. scene object, collision object, distance object, etc.)generalOjectType: type of the general object. Refer to the general object types. Can be -1, in which case the specified handle is checked for validity in all types (handles of different types never overlap) -1 if operation was not successful, 0 if the handle is not valid anymore, or 1 if the handle is still valid."
    }, 
    "sim.boolparam_mirrors_enabled": {
        "body": "sim.boolparam_mirrors_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_mirrors_enabled", 
        "description": "Constants"
    }, 
    "sim.jointmode_ik": {
        "body": "sim.jointmode_ik", 
        "scope": "source.lua", 
        "prefix": "sim.jointmode_ik", 
        "description": "Constants"
    }, 
    "sim.forcefloatparam_error_z": {
        "body": "sim.forcefloatparam_error_z", 
        "scope": "source.lua", 
        "prefix": "sim.forcefloatparam_error_z", 
        "description": "Constants"
    }, 
    "sim.forcefloatparam_error_x": {
        "body": "sim.forcefloatparam_error_x", 
        "scope": "source.lua", 
        "prefix": "sim.forcefloatparam_error_x", 
        "description": "Constants"
    }, 
    "sim.forcefloatparam_error_y": {
        "body": "sim.forcefloatparam_error_y", 
        "scope": "source.lua", 
        "prefix": "sim.forcefloatparam_error_y", 
        "description": "Constants"
    }, 
    "simUI.curve_style.impulse": {
        "body": "simUI.curve_style.impulse", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_style.impulse", 
        "description": "Constants"
    }, 
    "simRRS1.MODIFY_RCS_DATA": {
        "body": "simRRS1.MODIFY_RCS_DATA(${0:rcsHandle},${1:storage},${2:paramId})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.MODIFY_RCS_DATA", 
        "description": "int status= simRRS1.MODIFY_RCS_DATA(bitstring2 rcsHandle,int storage,string paramId)"
    }, 
    "sim.setObjectName": {
        "body": "sim.setObjectName(${0:objectHandle},${1:objectName})", 
        "scope": "source.lua", 
        "prefix": "sim.setObjectName", 
        "description": "number result = sim.setObjectName(number objectHandle,string objectName)Sets the name of an object based on its handle. See also sim.getObjectName. objectHandle: handle of the object. By adding sim.handleflag_altname to the object handle, the object alternative name can be set. By adding sim.handleflag_silenterror to the object handle, errors linked to the naming can be suppressed from output.objectName: name (or alternative name) of the objectobjectHandle: handle of the object. By adding sim.handleflag_altname to the object handle, the object alternative name can be set. By adding sim.handleflag_silenterror to the object handle, errors linked to the naming can be suppressed from output.objectName: name (or alternative name) of the objectobjectHandle: handle of the object. By adding sim.handleflag_altname to the object handle, the object alternative name can be set. By adding sim.handleflag_silenterror to the object handle, errors linked to the naming can be suppressed from output.objectName: name (or alternative name) of the object -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.mainscriptcall_initialization": {
        "body": "sim.mainscriptcall_initialization", 
        "scope": "source.lua", 
        "prefix": "sim.mainscriptcall_initialization", 
        "description": "Constants"
    }, 
    "sim.packDoubleTable": {
        "body": "sim.packDoubleTable(${0:doubleNumbers},${1:startDoubleIndex=0},${2:doubleCount=0})", 
        "scope": "source.lua", 
        "prefix": "sim.packDoubleTable", 
        "description": "string data = sim.packDoubleTable(table doubleNumbers,number startDoubleIndex=0,number doubleCount=0)Packs a table of double floating-point numbers into a string. See also sim.unpackDoubleTable and the other packing/unpacking functions. - -"
    }, 
    "sim.mill_cylinder_subtype": {
        "body": "sim.mill_cylinder_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.mill_cylinder_subtype", 
        "description": "Constants"
    }, 
    "sim.scriptthreadresume_actuation_first": {
        "body": "sim.scriptthreadresume_actuation_first", 
        "scope": "source.lua", 
        "prefix": "sim.scriptthreadresume_actuation_first", 
        "description": "Constants"
    }, 
    "sysCall_jointCallback": {
        "body": "sysCall_jointCallback(${0:step.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_jointCallback", 
        "description": "sysCall_jointCallback(Called after a dynamic simulation step.)"
    }, 
    "simUI.setPlotYRange": {
        "body": "simUI.setPlotYRange(${0:handle},${1:id},${2:ymin},${3:ymax})", 
        "scope": "source.lua", 
        "prefix": "simUI.setPlotYRange", 
        "description": "simUI.setPlotYRange(number handle,number id,number ymin,number ymax)"
    }, 
    "sim.intparam_current_page": {
        "body": "sim.intparam_current_page", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_current_page", 
        "description": "Constants"
    }, 
    "simUI.clearCurve": {
        "body": "simUI.clearCurve(${0:handle},${1:id},${2:name})", 
        "scope": "source.lua", 
        "prefix": "simUI.clearCurve", 
        "description": "simUI.clearCurve(number handle,number id,string name)"
    }, 
    "sim.visionintparam_windowed_pos_x": {
        "body": "sim.visionintparam_windowed_pos_x", 
        "scope": "source.lua", 
        "prefix": "sim.visionintparam_windowed_pos_x", 
        "description": "Constants"
    }, 
    "sim.setObjectPosition": {
        "body": "sim.setObjectPosition(${0:objectHandle},${1:relativeToObjectHandle},${2:position})", 
        "scope": "source.lua", 
        "prefix": "sim.setObjectPosition", 
        "description": "number result = sim.setObjectPosition(number objectHandle,number relativeToObjectHandle,table_3 position)Sets the position (x, y and z-coordinates) of an object. Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling  sim.resetDynamicObject just before). See also sim.getObjectPosition, sim.setObjectOrientation, sim.setObjectMatrix and the other matrix/transformation functions. objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the position is specified. Specify -1 to set the absolute position, sim_handle_parent to set the position relative to the object's parent, or an object handle relative to whose reference frame the position is specified.position: coordinates of the object (x, y and z)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the position is specified. Specify -1 to set the absolute position, sim_handle_parent to set the position relative to the object's parent, or an object handle relative to whose reference frame the position is specified.position: coordinates of the object (x, y and z)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the position is specified. Specify -1 to set the absolute position, sim_handle_parent to set the position relative to the object's parent, or an object handle relative to whose reference frame the position is specified.position: coordinates of the object (x, y and z)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the position is specified. Specify -1 to set the absolute position, sim_handle_parent to set the position relative to the object's parent, or an object handle relative to whose reference frame the position is specified.position: coordinates of the object (x, y and z) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.getDecimatedMesh": {
        "body": "sim.getDecimatedMesh(${0:verticesIn},${1:indicesIn},${2:decimationPercentage})", 
        "scope": "source.lua", 
        "prefix": "sim.getDecimatedMesh", 
        "description": "table verticesOut,table indicesOut = sim.getDecimatedMesh(table verticesIn,table indicesIn,number decimationPercentage)Retrieves a decimated mesh (i.e. a simplified mesh). See also sim.convexDecompose and sim.getQHull. inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.inIndices: a pointer to the input indices (3 values for each triangle).inIndicesL: the number of input triangles times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).decimationPercent: the percentage of the desired decimation (0.1-0.9).reserved1: reserved, set to 0.reserved2: reserved, set to NULL.inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.inIndices: a pointer to the input indices (3 values for each triangle).inIndicesL: the number of input triangles times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).decimationPercent: the percentage of the desired decimation (0.1-0.9).reserved1: reserved, set to 0.reserved2: reserved, set to NULL.inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.inIndices: a pointer to the input indices (3 values for each triangle).inIndicesL: the number of input triangles times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).decimationPercent: the percentage of the desired decimation (0.1-0.9).reserved1: reserved, set to 0.reserved2: reserved, set to NULL.inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.inIndices: a pointer to the input indices (3 values for each triangle).inIndicesL: the number of input triangles times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).decimationPercent: the percentage of the desired decimation (0.1-0.9).reserved1: reserved, set to 0.reserved2: reserved, set to NULL.inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.inIndices: a pointer to the input indices (3 values for each triangle).inIndicesL: the number of input triangles times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).decimationPercent: the percentage of the desired decimation (0.1-0.9).reserved1: reserved, set to 0.reserved2: reserved, set to NULL.inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.inIndices: a pointer to the input indices (3 values for each triangle).inIndicesL: the number of input triangles times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).decimationPercent: the percentage of the desired decimation (0.1-0.9).reserved1: reserved, set to 0.reserved2: reserved, set to NULL.inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.inIndices: a pointer to the input indices (3 values for each triangle).inIndicesL: the number of input triangles times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).decimationPercent: the percentage of the desired decimation (0.1-0.9).reserved1: reserved, set to 0.reserved2: reserved, set to NULL.inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.inIndices: a pointer to the input indices (3 values for each triangle).inIndicesL: the number of input triangles times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).decimationPercent: the percentage of the desired decimation (0.1-0.9).reserved1: reserved, set to 0.reserved2: reserved, set to NULL.inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.inIndices: a pointer to the input indices (3 values for each triangle).inIndicesL: the number of input triangles times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).decimationPercent: the percentage of the desired decimation (0.1-0.9).reserved1: reserved, set to 0.reserved2: reserved, set to NULL.inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.inIndices: a pointer to the input indices (3 values for each triangle).inIndicesL: the number of input triangles times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).decimationPercent: the percentage of the desired decimation (0.1-0.9).reserved1: reserved, set to 0.reserved2: reserved, set to NULL.inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.inIndices: a pointer to the input indices (3 values for each triangle).inIndicesL: the number of input triangles times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).decimationPercent: the percentage of the desired decimation (0.1-0.9).reserved1: reserved, set to 0.reserved2: reserved, set to NULL. -1 or 0 if operation was not successful."
    }, 
    "io.write": {
        "body": "io.write(${0:...})", 
        "scope": "source.lua", 
        "prefix": "io.write", 
        "description": "5.1,5.2,5.3\n\nio.write (...)"
    }, 
    "debug.setupvalue": {
        "body": "debug.setupvalue( ${1:f}, ${2:up}, ${3:value} )", 
        "scope": "source.lua", 
        "prefix": "debug.setupvalue", 
        "description": "5.1,5.2,5.3\n\ndebug.setupvalue (f, up, value)"
    }, 
    "sim.handleflag_rawvalue": {
        "body": "sim.handleflag_rawvalue", 
        "scope": "source.lua", 
        "prefix": "sim.handleflag_rawvalue", 
        "description": "Constants"
    }, 
    "math.asin": {
        "body": "math.asin( ${1:x} )", 
        "scope": "source.lua", 
        "prefix": "math.asin", 
        "description": "5.1,5.2,5.3\n\nmath.asin"
    }, 
    "sim.drawing_25percenttransparency": {
        "body": "sim.drawing_25percenttransparency", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_25percenttransparency", 
        "description": "Constants"
    }, 
    "simRRS1.RESET": {
        "body": "simRRS1.RESET(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.RESET", 
        "description": "int status,int numberOfMessages= simRRS1.RESET(bitstring2 rcsHandle)"
    }, 
    "simOMPL.Algorithm.LazyPRM": {
        "body": "simOMPL.Algorithm.LazyPRM", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.LazyPRM", 
        "description": "Constants"
    }, 
    "print": {
        "body": "print(${1:...})", 
        "scope": "source.lua", 
        "prefix": "print", 
        "description": "5.1,5.2,5.3\n\nprint(...)"
    }, 
    "sim.visionintparam_windowed_size_y": {
        "body": "sim.visionintparam_windowed_size_y", 
        "scope": "source.lua", 
        "prefix": "sim.visionintparam_windowed_size_y", 
        "description": "Constants"
    }, 
    "simUI.setLegendVisibility": {
        "body": "simUI.setLegendVisibility(${0:handle},${1:id},${2:visible})", 
        "scope": "source.lua", 
        "prefix": "simUI.setLegendVisibility", 
        "description": "simUI.setLegendVisibility(number handle,number id,bool visible)"
    }, 
    "sim.banner_clicktriggersevent": {
        "body": "sim.banner_clicktriggersevent", 
        "scope": "source.lua", 
        "prefix": "sim.banner_clicktriggersevent", 
        "description": "Constants"
    }, 
    "sim.forcefloatparam_error_angle": {
        "body": "sim.forcefloatparam_error_angle", 
        "scope": "source.lua", 
        "prefix": "sim.forcefloatparam_error_angle", 
        "description": "Constants"
    }, 
    "simx.auxiliaryConsolePrint": {
        "body": "simx.auxiliaryConsolePrint(${0:clientId},${1:consoleHandle},${2:txt})", 
        "scope": "source.lua", 
        "prefix": "simx.auxiliaryConsolePrint", 
        "description": "number returnCode= simx.auxiliaryConsolePrint(number clientId,number consoleHandle,string txt)Prints to an auxiliary console window. See also simx.auxiliaryConsoleOpen. clientID: the client ID. refer to simx.start.consoleHandle: the handle of the console window, previously returned by the simx.auxiliaryConsoleOpen commandtxt: the text to append, or nil to clear the console windowoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return code"
    }, 
    "simx.copyPasteObjects": {
        "body": "simx.copyPasteObjects(${0:clientId},${1:objectHandles})", 
        "scope": "source.lua", 
        "prefix": "simx.copyPasteObjects", 
        "description": "number returnCode,table newObjectHandles= simx.copyPasteObjects(number clientId,table objectHandles)Copies and pastes objects, together with all their associated calculation objects and child scripts. To copy and paste whole models, you can simply copy and paste the model base object. clientID: the client ID. refer to simx.start.objectHandles: a table containing the handles of the objects to copyoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return codenewObjectHandles: a table of handles of newly created objects. Individual objects of a new model are not returned, but only the model base."
    }, 
    "sim.filtercomponent_pixelchange": {
        "body": "sim.filtercomponent_pixelchange", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_pixelchange", 
        "description": "Constants"
    }, 
    "sim.auxiliaryConsoleShow": {
        "body": "sim.auxiliaryConsoleShow(${0:consoleHandle},${1:showState})", 
        "scope": "source.lua", 
        "prefix": "sim.auxiliaryConsoleShow", 
        "description": "number result = sim.auxiliaryConsoleShow(number consoleHandle,Boolean showState)Shows or hides an auxiliary console window. See also sim.auxiliaryConsoleOpen and sim.auxiliaryConsoleClose. consoleHandle: the handle of the console window, previously returned by the simAuxiliaryConsoleOpen commandshowState: indicates whether the console should be hidden (0) or shown (!=0)consoleHandle: the handle of the console window, previously returned by the simAuxiliaryConsoleOpen commandshowState: indicates whether the console should be hidden (0) or shown (!=0)consoleHandle: the handle of the console window, previously returned by the simAuxiliaryConsoleOpen commandshowState: indicates whether the console should be hidden (0) or shown (!=0) -1 if operation was not successful. 0 if the console doesn't exist (anymore), in which case no error is generated. 1 if the console window's show state was changed."
    }, 
    "sim.handleGraph": {
        "body": "sim.handleGraph(${0:objectHandle},${1:simulationTime})", 
        "scope": "source.lua", 
        "prefix": "sim.handleGraph", 
        "description": "number result = sim.handleGraph(number objectHandle,number simulationTime)Handles a graph object (i.e. records current values of registered data streams). Graphs and data streams can be added/registered while editing a scene. See also sim.resetGraph. graphHandle: handle of the graph object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all graph objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)simulationTime: simulation time. Usually you want to record data stream at the end of a simulation pass to record actualized value: then set simulationTime to simGetSimulationTime()+simGetSimulationTimeStep(). graphHandle: handle of the graph object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all graph objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)simulationTime: simulation time. Usually you want to record data stream at the end of a simulation pass to record actualized value: then set simulationTime to simGetSimulationTime()+simGetSimulationTimeStep(). graphHandle: handle of the graph object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all graph objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)simulationTime: simulation time. Usually you want to record data stream at the end of a simulation pass to record actualized value: then set simulationTime to simGetSimulationTime()+simGetSimulationTimeStep().  -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.scriptthreadresume_custom": {
        "body": "sim.scriptthreadresume_custom", 
        "scope": "source.lua", 
        "prefix": "sim.scriptthreadresume_custom", 
        "description": "Constants"
    }, 
    "simUI.setEditValue": {
        "body": "simUI.setEditValue(${0:handle},${1:id},${2:value},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setEditValue", 
        "description": "simUI.setEditValue(number handle,number id,string value,bool suppressEvents=true)"
    }, 
    "os.date": {
        "body": "os.date(${0:...})", 
        "scope": "source.lua", 
        "prefix": "os.date", 
        "description": "5.1,5.2,5.3\n\nos.date ([format [, time]])"
    }, 
    "sim.getObjectProperty": {
        "body": "sim.getObjectProperty(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectProperty", 
        "description": "number property = sim.getObjectProperty(number objectHandle)Retrieves the main properties of a scene object. See also sim.setObjectProperty, sim.getObjectSpecialProperty and sim.getModelProperty. objectHandle: handle of the objectobjectHandle: handle of the object object property values, -1 if operation was not successful"
    }, 
    "sim.addonscriptcall_suspend": {
        "body": "sim.addonscriptcall_suspend", 
        "scope": "source.lua", 
        "prefix": "sim.addonscriptcall_suspend", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_spherical_qw": {
        "body": "sim.jointfloatparam_spherical_qw", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_spherical_qw", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_spherical_qz": {
        "body": "sim.jointfloatparam_spherical_qz", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_spherical_qz", 
        "description": "Constants"
    }, 
    "sim.dlgret_no": {
        "body": "sim.dlgret_no", 
        "scope": "source.lua", 
        "prefix": "sim.dlgret_no", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_spherical_qx": {
        "body": "sim.jointfloatparam_spherical_qx", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_spherical_qx", 
        "description": "Constants"
    }, 
    "sim.getEngineInt32Parameter": {
        "body": "sim.getEngineInt32Parameter(${0:paramId},${1:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getEngineInt32Parameter", 
        "description": "number int32Param = sim.getEngineInt32Parameter(number paramId,number objectHandle)Retrieves an int32 value from the physics engine properties. See also the other engine properties setter and getter API functions. paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to retrieve a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to retrieve a global engine parameter. If NULL, then the objectHandle argument will be evaluated.ok: an optional pointer to a value that can be used to determine the success of the API call. Can be NULL.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to retrieve a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to retrieve a global engine parameter. If NULL, then the objectHandle argument will be evaluated.ok: an optional pointer to a value that can be used to determine the success of the API call. Can be NULL.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to retrieve a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to retrieve a global engine parameter. If NULL, then the objectHandle argument will be evaluated.ok: an optional pointer to a value that can be used to determine the success of the API call. Can be NULL.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to retrieve a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to retrieve a global engine parameter. If NULL, then the objectHandle argument will be evaluated.ok: an optional pointer to a value that can be used to determine the success of the API call. Can be NULL. value of the requested parameter. This function call doesn't generate any error message."
    }, 
    "sim.vortex_joint_dependentobjectid": {
        "body": "sim.vortex_joint_dependentobjectid", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_dependentobjectid", 
        "description": "Constants"
    }, 
    "simSurfRec.Algorithm.advancingfront": {
        "body": "simSurfRec.Algorithm.advancingfront", 
        "scope": "source.lua", 
        "prefix": "simSurfRec.Algorithm.advancingfront", 
        "description": "Constants"
    }, 
    "pairs": {
        "body": "pairs(${0:...})", 
        "scope": "source.lua", 
        "prefix": "pairs", 
        "description": "5.1,5.2,5.3\n\npairs (t)"
    }, 
    "sim.arrayparam_ambient_light": {
        "body": "sim.arrayparam_ambient_light", 
        "scope": "source.lua", 
        "prefix": "sim.arrayparam_ambient_light", 
        "description": "Constants"
    }, 
    "sim.resetMilling": {
        "body": "sim.resetMilling(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.resetMilling", 
        "description": "number result = sim.resetMilling(number objectHandle)Resets a cuttable object (e.g. a shape) to its initial shape (before it was milled), thus cancelling milling changes. The calculation structure linked to the object is removed and an updated calculation structure might be calculated (might take some calculation time). See also sim.applyMilling, sim.handleMill and sim.resetMill. objectHandle: handle of the cut object or sim_handle_all to reset all cut objects.objectHandle: handle of the cut object or sim_handle_all to reset all cut objects. -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.addDrawingObject": {
        "body": "sim.addDrawingObject(${0:objectType},${1:size},${2:duplicateTolerance},${3:parentObjectHandle},${4:maxItemCount},${5:ambient_diffuse=nil},${6:nil},${7:specular=nil},${8:emission=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.addDrawingObject", 
        "description": "number drawingObjectHandle = sim.addDrawingObject(number objectType,number size,number duplicateTolerance,number parentObjectHandle,number maxItemCount,table_3 ambient_diffuse=nil,nil,table_3 specular=nil,table_3 emission=nil)Adds a drawing object that will be displayed in the scene. Drawing objects are containers that hold several items of a given type. This can be used for several different applications (simulation of paint, simulation of welding seam, display of 3D objects, etc.). Drawing objects created in a simulation script will be automatically removed at simulation end. See also sim.addDrawingObjectItem, sim.removeDrawingObject and the point cloud functionality. objectType: a drawing object type combined with attributessize: size of the item (width of lines or size of points are in pixels, other sizes are in metersduplicateTolerance: if different from 0.0, then a call to simAddDrawingObjectItem will only add the item if there is no other item within duplicateTolerance distance. Useful to avoid adding a too high density of points, is however not appropriate when using a large number of points (slower operation). Applicable only for single vertex items.parentObjectHandle: handle of the scene object where the drawing items should keep attached to (if the scene object moves, the drawing items will also move), or -1 if the drawing items are relative to the world (fixed)maxItemCount: maximum number of items this object can hold.ambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a drawing object type combined with attributessize: size of the item (width of lines or size of points are in pixels, other sizes are in metersduplicateTolerance: if different from 0.0, then a call to simAddDrawingObjectItem will only add the item if there is no other item within duplicateTolerance distance. Useful to avoid adding a too high density of points, is however not appropriate when using a large number of points (slower operation). Applicable only for single vertex items.parentObjectHandle: handle of the scene object where the drawing items should keep attached to (if the scene object moves, the drawing items will also move), or -1 if the drawing items are relative to the world (fixed)maxItemCount: maximum number of items this object can hold.ambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a drawing object type combined with attributessize: size of the item (width of lines or size of points are in pixels, other sizes are in metersduplicateTolerance: if different from 0.0, then a call to simAddDrawingObjectItem will only add the item if there is no other item within duplicateTolerance distance. Useful to avoid adding a too high density of points, is however not appropriate when using a large number of points (slower operation). Applicable only for single vertex items.parentObjectHandle: handle of the scene object where the drawing items should keep attached to (if the scene object moves, the drawing items will also move), or -1 if the drawing items are relative to the world (fixed)maxItemCount: maximum number of items this object can hold.ambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a drawing object type combined with attributessize: size of the item (width of lines or size of points are in pixels, other sizes are in metersduplicateTolerance: if different from 0.0, then a call to simAddDrawingObjectItem will only add the item if there is no other item within duplicateTolerance distance. Useful to avoid adding a too high density of points, is however not appropriate when using a large number of points (slower operation). Applicable only for single vertex items.parentObjectHandle: handle of the scene object where the drawing items should keep attached to (if the scene object moves, the drawing items will also move), or -1 if the drawing items are relative to the world (fixed)maxItemCount: maximum number of items this object can hold.ambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a drawing object type combined with attributessize: size of the item (width of lines or size of points are in pixels, other sizes are in metersduplicateTolerance: if different from 0.0, then a call to simAddDrawingObjectItem will only add the item if there is no other item within duplicateTolerance distance. Useful to avoid adding a too high density of points, is however not appropriate when using a large number of points (slower operation). Applicable only for single vertex items.parentObjectHandle: handle of the scene object where the drawing items should keep attached to (if the scene object moves, the drawing items will also move), or -1 if the drawing items are relative to the world (fixed)maxItemCount: maximum number of items this object can hold.ambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a drawing object type combined with attributessize: size of the item (width of lines or size of points are in pixels, other sizes are in metersduplicateTolerance: if different from 0.0, then a call to simAddDrawingObjectItem will only add the item if there is no other item within duplicateTolerance distance. Useful to avoid adding a too high density of points, is however not appropriate when using a large number of points (slower operation). Applicable only for single vertex items.parentObjectHandle: handle of the scene object where the drawing items should keep attached to (if the scene object moves, the drawing items will also move), or -1 if the drawing items are relative to the world (fixed)maxItemCount: maximum number of items this object can hold.ambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a drawing object type combined with attributessize: size of the item (width of lines or size of points are in pixels, other sizes are in metersduplicateTolerance: if different from 0.0, then a call to simAddDrawingObjectItem will only add the item if there is no other item within duplicateTolerance distance. Useful to avoid adding a too high density of points, is however not appropriate when using a large number of points (slower operation). Applicable only for single vertex items.parentObjectHandle: handle of the scene object where the drawing items should keep attached to (if the scene object moves, the drawing items will also move), or -1 if the drawing items are relative to the world (fixed)maxItemCount: maximum number of items this object can hold.ambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a drawing object type combined with attributessize: size of the item (width of lines or size of points are in pixels, other sizes are in metersduplicateTolerance: if different from 0.0, then a call to simAddDrawingObjectItem will only add the item if there is no other item within duplicateTolerance distance. Useful to avoid adding a too high density of points, is however not appropriate when using a large number of points (slower operation). Applicable only for single vertex items.parentObjectHandle: handle of the scene object where the drawing items should keep attached to (if the scene object moves, the drawing items will also move), or -1 if the drawing items are relative to the world (fixed)maxItemCount: maximum number of items this object can hold.ambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a drawing object type combined with attributessize: size of the item (width of lines or size of points are in pixels, other sizes are in metersduplicateTolerance: if different from 0.0, then a call to simAddDrawingObjectItem will only add the item if there is no other item within duplicateTolerance distance. Useful to avoid adding a too high density of points, is however not appropriate when using a large number of points (slower operation). Applicable only for single vertex items.parentObjectHandle: handle of the scene object where the drawing items should keep attached to (if the scene object moves, the drawing items will also move), or -1 if the drawing items are relative to the world (fixed)maxItemCount: maximum number of items this object can hold.ambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULL handle of the drawing object if successful, -1 otherwise"
    }, 
    "sim.unpackUInt16Table": {
        "body": "sim.unpackUInt16Table(${0:data},${1:startUint16Index=0},${2:uint16Count=0},${3:additionalByteOffset=0})", 
        "scope": "source.lua", 
        "prefix": "sim.unpackUInt16Table", 
        "description": "table uint16Numbers = sim.unpackUInt16Table(string data,number startUint16Index=0,number uint16Count=0,number additionalByteOffset=0)Unpacks a string (or part of it) into a table of uint16 numbers. See also sim.packUInt16Table and the other packing/unpacking functions. - -"
    }, 
    "rawget": {
        "body": "rawget(${0:...})", 
        "scope": "source.lua", 
        "prefix": "rawget", 
        "description": "5.1,5.2,5.3\n\nrawget (table, index)"
    }, 
    "sim.vortex_joint_p1loss": {
        "body": "sim.vortex_joint_p1loss", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p1loss", 
        "description": "Constants"
    }, 
    "simRRS1.CANCEL_FLYBY_CRITERIA": {
        "body": "simRRS1.CANCEL_FLYBY_CRITERIA(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.CANCEL_FLYBY_CRITERIA", 
        "description": "int status= simRRS1.CANCEL_FLYBY_CRITERIA(bitstring2 rcsHandle)"
    }, 
    "sim.buffer_int8": {
        "body": "sim.buffer_int8", 
        "scope": "source.lua", 
        "prefix": "sim.buffer_int8", 
        "description": "Constants"
    }, 
    "simUI.setPosition": {
        "body": "simUI.setPosition(${0:handle},${1:x},${2:y},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setPosition", 
        "description": "simUI.setPosition(number handle,number x,number y,bool suppressEvents=true)"
    }, 
    "sim.boolparam_infotext_visible": {
        "body": "sim.boolparam_infotext_visible", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_infotext_visible", 
        "description": "Constants"
    }, 
    "sim.intparam_event_flags_read": {
        "body": "sim.intparam_event_flags_read", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_event_flags_read", 
        "description": "Constants"
    }, 
    "sim.getNameSuffix": {
        "body": "sim.getNameSuffix(${0:nameWithSuffix})", 
        "scope": "source.lua", 
        "prefix": "sim.getNameSuffix", 
        "description": "number suffix,string name = sim.getNameSuffix(string nameWithSuffix)Returns the name suffix for an object name (e.g. myRobot#42's name suffix is 42), or retrieves the name suffix set for the current script or for c/c++ API calls. See also sim.setNameSuffix, and read the section on accessing general-type objects. nameWithSuffix: full name (e.g. myRobot#42), or NULL to retrieve the name suffix for all c/c++ API callsnameWithSuffix: full name (e.g. myRobot#42), or NULL to retrieve the name suffix for all c/c++ API calls Name suffix of nameWithSuffix, or current name suffix for c/c++ API calls"
    }, 
    "os.execute": {
        "body": "os.execute(${0:...})", 
        "scope": "source.lua", 
        "prefix": "os.execute", 
        "description": "5.1,5.2,5.3\n\nos.execute ([command])"
    }, 
    "sim.filtercomponent_horizontalflip": {
        "body": "sim.filtercomponent_horizontalflip", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_horizontalflip", 
        "description": "Constants"
    }, 
    "simOMPL.Algorithm.BKPIECE1": {
        "body": "simOMPL.Algorithm.BKPIECE1", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.BKPIECE1", 
        "description": "Constants"
    }, 
    "sim.getJointInterval": {
        "body": "sim.getJointInterval(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getJointInterval", 
        "description": "boolean cyclic,table_2 interval = sim.getJointInterval(number objectHandle)Retrieves the interval parameters of a joint. See also sim.setJointInterval. objectHandle: handle of the jointcyclic: indicates whether the joint is cyclic (the joint varies between -pi and +pi in a cyclic manner)interval: interval of the joint. interval[0] is the joint minimum allowed value, interval[1] is the joint range (the maximum allowed value is interval[0]+interval[1]). When the joint is cyclic, then the interval parameters don't have any meaning.objectHandle: handle of the jointcyclic: indicates whether the joint is cyclic (the joint varies between -pi and +pi in a cyclic manner)interval: interval of the joint. interval[0] is the joint minimum allowed value, interval[1] is the joint range (the maximum allowed value is interval[0]+interval[1]). When the joint is cyclic, then the interval parameters don't have any meaning.objectHandle: handle of the jointcyclic: indicates whether the joint is cyclic (the joint varies between -pi and +pi in a cyclic manner)interval: interval of the joint. interval[0] is the joint minimum allowed value, interval[1] is the joint range (the maximum allowed value is interval[0]+interval[1]). When the joint is cyclic, then the interval parameters don't have any meaning.objectHandle: handle of the jointcyclic: indicates whether the joint is cyclic (the joint varies between -pi and +pi in a cyclic manner)interval: interval of the joint. interval[0] is the joint minimum allowed value, interval[1] is the joint range (the maximum allowed value is interval[0]+interval[1]). When the joint is cyclic, then the interval parameters don't have any meaning. -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simUI.curve_scatter_shape.dot": {
        "body": "simUI.curve_scatter_shape.dot", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_scatter_shape.dot", 
        "description": "Constants"
    }, 
    "sim.customizationscriptcall_cleanup": {
        "body": "sim.customizationscriptcall_cleanup", 
        "scope": "source.lua", 
        "prefix": "sim.customizationscriptcall_cleanup", 
        "description": "Constants"
    }, 
    "sim.objfloatparam_abs_x_velocity": {
        "body": "sim.objfloatparam_abs_x_velocity", 
        "scope": "source.lua", 
        "prefix": "sim.objfloatparam_abs_x_velocity", 
        "description": "Constants"
    }, 
    "sim.colorcomponent_ambient_diffuse": {
        "body": "sim.colorcomponent_ambient_diffuse", 
        "scope": "source.lua", 
        "prefix": "sim.colorcomponent_ambient_diffuse", 
        "description": "Constants"
    }, 
    "sim.texturemap_cube": {
        "body": "sim.texturemap_cube", 
        "scope": "source.lua", 
        "prefix": "sim.texturemap_cube", 
        "description": "Constants"
    }, 
    "sim.physics_vortex": {
        "body": "sim.physics_vortex", 
        "scope": "source.lua", 
        "prefix": "sim.physics_vortex", 
        "description": "Constants"
    }, 
    "simx.start": {
        "body": "simx.start(${0:connectionAddress},${1:connectionPort},${2:waitUntilConnected},${3:doNotReconnectOnceDisconnected},${4:timeOutInMs})", 
        "scope": "source.lua", 
        "prefix": "simx.start", 
        "description": "number clientId= simx.start(string connectionAddress,number connectionPort,boolean waitUntilConnected,boolean doNotReconnectOnceDisconnected,number timeOutInMs)Starts a communication thread with the server (i.e. V-REP). A same client may start several communication threads (but only one communication thread for a given IP and port). This should be the very first remote API function called on the client side. Make sure to start an appropriate remote API server service on the server side, that will wait for a connection. See also simx.finish. This is a remote API helper function. connectionAddress: the ip address where the server is located (i.e. V-REP)connectionPort: the port number where to connect. Specify a negative port number in order to use shared memory, instead of socket communication.waitUntilConnected: if true, then the function blocks until connected (or timed out).doNotReconnectOnceDisconnected: if true, then the communication thread will not attempt a second connection if a connection was lost.timeOutInMs:commThreadCycleInMs: indicates how often data packets are sent back and forth. Reducing this number improves responsiveness, and a default value of 5 is recommended. clientID: the client ID, or -1 if the connection to the server was not possible (i.e. a timeout was reached). A call to simx.start should always be followed at the end with a call to simx.finish if simx.start didn't return -1"
    }, 
    "sim.vortex_body_primlinearaxisstaticfrictionscale": {
        "body": "sim.vortex_body_primlinearaxisstaticfrictionscale", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_primlinearaxisstaticfrictionscale", 
        "description": "Constants"
    }, 
    "sim.removeModel": {
        "body": "sim.removeModel(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.removeModel", 
        "description": "number removedObjects = sim.removeModel(number objectHandle)Removes a model from the scene. See also sim.removeObject.Threaded child scripts can only destroy models that do not contain other scripts attached than itself.Object destruction always tries to destroy attached scripts before destroying the object itself. If a script tries to destroy the object it is attached to, then the object will first be destroyed, and the script destruction will be delayed. objectHandle: handle of the model (i.e. object tagged as model) to remove.objectHandle: handle of the model (i.e. object tagged as model) to remove. -1 if operation was not successful, otherwise the number of removed objects (a model might contain several objects)"
    }, 
    "sim.setPathPosition": {
        "body": "sim.setPathPosition(${0:objectHandle},${1:position})", 
        "scope": "source.lua", 
        "prefix": "sim.setPathPosition", 
        "description": "number result = sim.setPathPosition(number objectHandle,number position)Sets the intrinsic position of a path object (i.e. the position along the path). The position is given in meters, but the actual position is dependent on the selected path length calculation method for the given path object.This function is the equivalent of sim.setJointPosition, but for a path object. See also sim.getPathPosition. objectHandle: handle of the path objectposition: linear position on the path given in meters (but dependent on the selected path length calculation method)objectHandle: handle of the path objectposition: linear position on the path given in meters (but dependent on the selected path length calculation method)objectHandle: handle of the path objectposition: linear position on the path given in meters (but dependent on the selected path length calculation method) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.msgbox_buttons_yesnocancel": {
        "body": "sim.msgbox_buttons_yesnocancel", 
        "scope": "source.lua", 
        "prefix": "sim.msgbox_buttons_yesnocancel", 
        "description": "Constants"
    }, 
    "simRRS1.CANCEL_MOTION": {
        "body": "simRRS1.CANCEL_MOTION()", 
        "scope": "source.lua", 
        "prefix": "simRRS1.CANCEL_MOTION", 
        "description": "int status= simRRS1.CANCEL_MOTION()"
    }, 
    "sim.handleProximitySensor": {
        "body": "sim.handleProximitySensor(${0:sensorHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.handleProximitySensor", 
        "description": "number result,number distance,table_3 detectedPoint,number detectedObjectHandle,table_3 normalVector = sim.handleProximitySensor(number sensorHandle)Handles (performs sensing, etc. of) a registered proximity sensor object. See also sim.readProximitySensor, sim.checkProximitySensor, sim.checkProximitySensorEx and sim.resetProximitySensor. sensorHandle: handle of a proximity sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all proximity sensor objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)detectedPoint: coordinates of the closest detected point (x, y and z: detectedPoint[0]-detectedPoint[2]) relative to the sensor reference frame, and distance to the detected point (1 value: detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of the object that was detected. Can be NULLdetectedSurfaceNormalVector: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Can be NULLWhen several proximity sensors are handled at the same time (e.g. with the sim_handle_all argument), then the output values are relative to the closest detection distancesensorHandle: handle of a proximity sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all proximity sensor objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)detectedPoint: coordinates of the closest detected point (x, y and z: detectedPoint[0]-detectedPoint[2]) relative to the sensor reference frame, and distance to the detected point (1 value: detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of the object that was detected. Can be NULLdetectedSurfaceNormalVector: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Can be NULLWhen several proximity sensors are handled at the same time (e.g. with the sim_handle_all argument), then the output values are relative to the closest detection distancesensorHandle: handle of a proximity sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all proximity sensor objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)detectedPoint: coordinates of the closest detected point (x, y and z: detectedPoint[0]-detectedPoint[2]) relative to the sensor reference frame, and distance to the detected point (1 value: detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of the object that was detected. Can be NULLdetectedSurfaceNormalVector: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Can be NULLWhen several proximity sensors are handled at the same time (e.g. with the sim_handle_all argument), then the output values are relative to the closest detection distancesensorHandle: handle of a proximity sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all proximity sensor objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)detectedPoint: coordinates of the closest detected point (x, y and z: detectedPoint[0]-detectedPoint[2]) relative to the sensor reference frame, and distance to the detected point (1 value: detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of the object that was detected. Can be NULLdetectedSurfaceNormalVector: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Can be NULLWhen several proximity sensors are handled at the same time (e.g. with the sim_handle_all argument), then the output values are relative to the closest detection distancesensorHandle: handle of a proximity sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all proximity sensor objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)detectedPoint: coordinates of the closest detected point (x, y and z: detectedPoint[0]-detectedPoint[2]) relative to the sensor reference frame, and distance to the detected point (1 value: detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of the object that was detected. Can be NULLdetectedSurfaceNormalVector: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Can be NULLWhen several proximity sensors are handled at the same time (e.g. with the sim_handle_all argument), then the output values are relative to the closest detection distance 0 if nothing was detected, -1 in case of an error. In a future release, a more detailed return value might be available"
    }, 
    "sim.getClosestPositionOnPath": {
        "body": "sim.getClosestPositionOnPath(${0:pathHandle},${1:positionRelativeToPathFrame})", 
        "scope": "source.lua", 
        "prefix": "sim.getClosestPositionOnPath", 
        "description": "number positionOnPath = sim.getClosestPositionOnPath(number pathHandle,table_3 positionRelativeToPathFrame)Retrieves the intrinsic relative position on a path that is closest to the specified point. The returned value is dependent on the selected path length calculation method for the given path object. See also sim.getPathPosition, sim.getPathLength, sim.getPositionOnPath and sim.getOrientationOnPath. pathHandle: handle of the path objectrelativePosition: a point in coordinates (x, y and z) relative to the path object positionpathPosition: (return value). The intrinsic relative position on the path, a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path (that value is dependent on the selected path length calculation method).pathHandle: handle of the path objectrelativePosition: a point in coordinates (x, y and z) relative to the path object positionpathPosition: (return value). The intrinsic relative position on the path, a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path (that value is dependent on the selected path length calculation method).pathHandle: handle of the path objectrelativePosition: a point in coordinates (x, y and z) relative to the path object positionpathPosition: (return value). The intrinsic relative position on the path, a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path (that value is dependent on the selected path length calculation method).pathHandle: handle of the path objectrelativePosition: a point in coordinates (x, y and z) relative to the path object positionpathPosition: (return value). The intrinsic relative position on the path, a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path (that value is dependent on the selected path length calculation method). -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.vortex_body_normalangularaxisslip": {
        "body": "sim.vortex_body_normalangularaxisslip", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_normalangularaxisslip", 
        "description": "Constants"
    }, 
    "sim.navigation_camerarotatemiddlebutton": {
        "body": "sim.navigation_camerarotatemiddlebutton", 
        "scope": "source.lua", 
        "prefix": "sim.navigation_camerarotatemiddlebutton", 
        "description": "Constants"
    }, 
    "simUI.line_style.dashed": {
        "body": "simUI.line_style.dashed", 
        "scope": "source.lua", 
        "prefix": "simUI.line_style.dashed", 
        "description": "Constants"
    }, 
    "simUI.setWidgetVisibility": {
        "body": "simUI.setWidgetVisibility(${0:handle},${1:id},${2:visibility})", 
        "scope": "source.lua", 
        "prefix": "simUI.setWidgetVisibility", 
        "description": "simUI.setWidgetVisibility(number handle,number id,bool visibility)"
    }, 
    "setmetatable": {
        "body": "setmetatable(${1:table}, ${2:metatable})", 
        "scope": "source.lua", 
        "prefix": "setmetatable", 
        "description": "5.1,5.2,5.3\n\nsetmetatable (table, metatable)"
    }, 
    "sim.simulation_advancing": {
        "body": "sim.simulation_advancing", 
        "scope": "source.lua", 
        "prefix": "sim.simulation_advancing", 
        "description": "Constants"
    }, 
    "sim.interpolateMatrices": {
        "body": "sim.interpolateMatrices(${0:matrixIn1},${1:matrixIn2},${2:interpolFactor})", 
        "scope": "source.lua", 
        "prefix": "sim.interpolateMatrices", 
        "description": "table_12 resultMatrix = sim.interpolateMatrices(table_12 matrixIn1,table_12 matrixIn2,number interpolFactor)Computes the interpolated transformation matrix between matrixIn1 and matrixIn2. Quaternions are used internally. See also the other matrix/transformation functions. matrixIn1: the first input matrixmatrixIn2: the second input matrixinterpolFactor: the interpolation factor, a value between 0.0 and 1.0 (0.0--> matrixOut=matrixIn1, 1.0--> matrixOut=matrixIn2)matrixOut: the output matrix (the result of the interpolation).A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn1: the first input matrixmatrixIn2: the second input matrixinterpolFactor: the interpolation factor, a value between 0.0 and 1.0 (0.0--> matrixOut=matrixIn1, 1.0--> matrixOut=matrixIn2)matrixOut: the output matrix (the result of the interpolation).A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn1: the first input matrixmatrixIn2: the second input matrixinterpolFactor: the interpolation factor, a value between 0.0 and 1.0 (0.0--> matrixOut=matrixIn1, 1.0--> matrixOut=matrixIn2)matrixOut: the output matrix (the result of the interpolation).A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn1: the first input matrixmatrixIn2: the second input matrixinterpolFactor: the interpolation factor, a value between 0.0 and 1.0 (0.0--> matrixOut=matrixIn1, 1.0--> matrixOut=matrixIn2)matrixOut: the output matrix (the result of the interpolation).A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn1: the first input matrixmatrixIn2: the second input matrixinterpolFactor: the interpolation factor, a value between 0.0 and 1.0 (0.0--> matrixOut=matrixIn1, 1.0--> matrixOut=matrixIn2)matrixOut: the output matrix (the result of the interpolation).A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn1: the first input matrixmatrixIn2: the second input matrixinterpolFactor: the interpolation factor, a value between 0.0 and 1.0 (0.0--> matrixOut=matrixIn1, 1.0--> matrixOut=matrixIn2)matrixOut: the output matrix (the result of the interpolation).A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn1: the first input matrixmatrixIn2: the second input matrixinterpolFactor: the interpolation factor, a value between 0.0 and 1.0 (0.0--> matrixOut=matrixIn1, 1.0--> matrixOut=matrixIn2)matrixOut: the output matrix (the result of the interpolation).A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn1: the first input matrixmatrixIn2: the second input matrixinterpolFactor: the interpolation factor, a value between 0.0 and 1.0 (0.0--> matrixOut=matrixIn1, 1.0--> matrixOut=matrixIn2)matrixOut: the output matrix (the result of the interpolation).A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn1: the first input matrixmatrixIn2: the second input matrixinterpolFactor: the interpolation factor, a value between 0.0 and 1.0 (0.0--> matrixOut=matrixIn1, 1.0--> matrixOut=matrixIn2)matrixOut: the output matrix (the result of the interpolation).A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11]) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simx.getFloatSignal": {
        "body": "simx.getFloatSignal(${0:clientId},${1:signalName})", 
        "scope": "source.lua", 
        "prefix": "simx.getFloatSignal", 
        "description": "number returnCode,number signalValue= simx.getFloatSignal(number clientId,string signalName)Gets the value of a float signal. Signals are cleared at simulation start. See also simx.setFloatSignal, simx.clearFloatSignal, simx.getIntegerSignal and simx.getStringSignal. clientID: the client ID. refer to simx.start.signalName: name of the signaloperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls) returnCode: a remote API function return codesignalValue: the value of the signal"
    }, 
    "sim.distcalcmethod_sqrt_dl2_and_dac2": {
        "body": "sim.distcalcmethod_sqrt_dl2_and_dac2", 
        "scope": "source.lua", 
        "prefix": "sim.distcalcmethod_sqrt_dl2_and_dac2", 
        "description": "Constants"
    }, 
    "sim.buttonproperty_editbox": {
        "body": "sim.buttonproperty_editbox", 
        "scope": "source.lua", 
        "prefix": "sim.buttonproperty_editbox", 
        "description": "Constants"
    }, 
    "sim.boolparam_gcs_handling_enabled": {
        "body": "sim.boolparam_gcs_handling_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_gcs_handling_enabled", 
        "description": "Constants"
    }, 
    "simUI.setImageData": {
        "body": "simUI.setImageData(${0:handle},${1:id},${2:data},${3:width},${4:height})", 
        "scope": "source.lua", 
        "prefix": "simUI.setImageData", 
        "description": "simUI.setImageData(number handle,number id,string data,number width,number height)"
    }, 
    "simx.getCollisionHandle": {
        "body": "simx.getCollisionHandle(${0:clientId},${1:collisionObjectName})", 
        "scope": "source.lua", 
        "prefix": "simx.getCollisionHandle", 
        "description": "number returnCode,number collisionHandle= simx.getCollisionHandle(number clientId,string collisionObjectName)Retrieves a collision  object handle based on its name. If the client application is launched from a child script, then you could also let the child script figure out what handle correspond to what collision object, and send the handles as additional arguments to the client application during its launch. See also simx.getObjectGroupData. clientID: the client ID. refer to simx.start.collisionObjectName: name of the collision object. If possibe, don't rely on the automatic name adjustment mechanism, and always specify the full collision object name, including the #: if the collision object is myCollision, specify myCollision#, if the collision object is myCollision#0, specify myCollision#0, etc.operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return codehandle: the handle"
    }, 
    "sim.volume_cylinder": {
        "body": "sim.volume_cylinder", 
        "scope": "source.lua", 
        "prefix": "sim.volume_cylinder", 
        "description": "Constants"
    }, 
    "simx.headeroffset_version": {
        "body": "simx.headeroffset_version", 
        "scope": "source.lua", 
        "prefix": "simx.headeroffset_version", 
        "description": "Constants"
    }, 
    "sim.visionintparam_pov_focal_blur": {
        "body": "sim.visionintparam_pov_focal_blur", 
        "scope": "source.lua", 
        "prefix": "sim.visionintparam_pov_focal_blur", 
        "description": "Constants"
    }, 
    "simUI.removeCurve": {
        "body": "simUI.removeCurve(${0:handle},${1:id},${2:name})", 
        "scope": "source.lua", 
        "prefix": "simUI.removeCurve", 
        "description": "simUI.removeCurve(number handle,number id,string name)"
    }, 
    "sim.drawing_cyclic": {
        "body": "sim.drawing_cyclic", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_cyclic", 
        "description": "Constants"
    }, 
    "sim.vortex_body_primlinearaxisslide": {
        "body": "sim.vortex_body_primlinearaxisslide", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_primlinearaxisslide", 
        "description": "Constants"
    }, 
    "sim.appobj_simulation_type": {
        "body": "sim.appobj_simulation_type", 
        "scope": "source.lua", 
        "prefix": "sim.appobj_simulation_type", 
        "description": "Constants"
    }, 
    "sim.ode_global_internalscalingfactor": {
        "body": "sim.ode_global_internalscalingfactor", 
        "scope": "source.lua", 
        "prefix": "sim.ode_global_internalscalingfactor", 
        "description": "Constants"
    }, 
    "sim.objectspecialproperty_collidable": {
        "body": "sim.objectspecialproperty_collidable", 
        "scope": "source.lua", 
        "prefix": "sim.objectspecialproperty_collidable", 
        "description": "Constants"
    }, 
    "sim.vortex_body_primangularaxisslip": {
        "body": "sim.vortex_body_primangularaxisslip", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_primangularaxisslip", 
        "description": "Constants"
    }, 
    "sim.loadImage": {
        "body": "sim.loadImage(${0:options},${1:filename})", 
        "scope": "source.lua", 
        "prefix": "sim.loadImage", 
        "description": "string image,table_2 resolution = sim.loadImage(number options,string filename)Loads an image from file or memory. See also sim.saveImage, sim.getScaledImage, sim.transformImage and sim.setVisionSensorCharImage. resolution: a pointer that will accept the image resolution.options: bit-coded. If bit0 is set (1), then the returned image is rgba, otherwise it is rgb.filename: the name of the file to read. The file extension indicates the format. If you wish to load an image from a memory buffer, then have filename point to that memory buffer.reserved: Set to NULL if you load an image from file. If you load an image from a memory buffer, this should be to an integer pointer where the first pointed integer is the size of the memory buffer.resolution: a pointer that will accept the image resolution.options: bit-coded. If bit0 is set (1), then the returned image is rgba, otherwise it is rgb.filename: the name of the file to read. The file extension indicates the format. If you wish to load an image from a memory buffer, then have filename point to that memory buffer.reserved: Set to NULL if you load an image from file. If you load an image from a memory buffer, this should be to an integer pointer where the first pointed integer is the size of the memory buffer.resolution: a pointer that will accept the image resolution.options: bit-coded. If bit0 is set (1), then the returned image is rgba, otherwise it is rgb.filename: the name of the file to read. The file extension indicates the format. If you wish to load an image from a memory buffer, then have filename point to that memory buffer.reserved: Set to NULL if you load an image from file. If you load an image from a memory buffer, this should be to an integer pointer where the first pointed integer is the size of the memory buffer.resolution: a pointer that will accept the image resolution.options: bit-coded. If bit0 is set (1), then the returned image is rgba, otherwise it is rgb.filename: the name of the file to read. The file extension indicates the format. If you wish to load an image from a memory buffer, then have filename point to that memory buffer.reserved: Set to NULL if you load an image from file. If you load an image from a memory buffer, this should be to an integer pointer where the first pointed integer is the size of the memory buffer. NULL if operation was not successful, otherwise a buffer containing the image data. The user is in charge of releasing the buffer with simReleaseBuffer."
    }, 
    "simK3.destroy": {
        "body": "simK3.destroy(${0:k3Handle})", 
        "scope": "source.lua", 
        "prefix": "simK3.destroy", 
        "description": "boolean result = simK3.destroy(number k3Handle)"
    }, 
    "os.tmpname": {
        "body": "os.tmpname(${0:...})", 
        "scope": "source.lua", 
        "prefix": "os.tmpname", 
        "description": "5.1,5.2,5.3\n\nos.tmpname ()"
    }, 
    "simRRS1.SELECT_WEAVING_GROUP": {
        "body": "simRRS1.SELECT_WEAVING_GROUP(${0:rcsHandle},${1:groupNo})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SELECT_WEAVING_GROUP", 
        "description": "int status= simRRS1.SELECT_WEAVING_GROUP(bitstring2 rcsHandle,int groupNo)"
    }, 
    "simUI.curve_scatter_shape.disc": {
        "body": "simUI.curve_scatter_shape.disc", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_scatter_shape.disc", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_a0loss": {
        "body": "sim.vortex_joint_a0loss", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a0loss", 
        "description": "Constants"
    }, 
    "sim.proximitysensor_cylinder_subtype": {
        "body": "sim.proximitysensor_cylinder_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.proximitysensor_cylinder_subtype", 
        "description": "Constants"
    }, 
    "simBubble.destroy": {
        "body": "simBubble.destroy(${0:bubbleRobHandle})", 
        "scope": "source.lua", 
        "prefix": "simBubble.destroy", 
        "description": "boolean result = simBubble.destroy(number bubbleRobHandle)"
    }, 
    "sim.getShapeGeomInfo": {
        "body": "sim.getShapeGeomInfo(${0:shapeHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getShapeGeomInfo", 
        "description": "number result,number pureType,table_4 dimensions = sim.getShapeGeomInfo(number shapeHandle)Retrieves geometric information related to a shape. See also sim.getShapeMesh. shapeHandle: handle of the shape. See also simGetObjectHandle.intData (output): pointer to 5 integer values:intData[0]: the pure type of the shape. Undefined if the shape is a compound shape.floatData (output): pointer to 5 float values:floatData[0]: X-size or diameter of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[1]: Y-size of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[2]: Z-size or height of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[3]: Inside scaling. Undefined if the shape is a compound shape or not pure.reserved: reserved for future extensions. Set to NULL.shapeHandle: handle of the shape. See also simGetObjectHandle.intData (output): pointer to 5 integer values:intData[0]: the pure type of the shape. Undefined if the shape is a compound shape.floatData (output): pointer to 5 float values:floatData[0]: X-size or diameter of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[1]: Y-size of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[2]: Z-size or height of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[3]: Inside scaling. Undefined if the shape is a compound shape or not pure.reserved: reserved for future extensions. Set to NULL.shapeHandle: handle of the shape. See also simGetObjectHandle.intData (output): pointer to 5 integer values:intData[0]: the pure type of the shape. Undefined if the shape is a compound shape.floatData (output): pointer to 5 float values:floatData[0]: X-size or diameter of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[1]: Y-size of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[2]: Z-size or height of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[3]: Inside scaling. Undefined if the shape is a compound shape or not pure.reserved: reserved for future extensions. Set to NULL.shapeHandle: handle of the shape. See also simGetObjectHandle.intData (output): pointer to 5 integer values:intData[0]: the pure type of the shape. Undefined if the shape is a compound shape.floatData (output): pointer to 5 float values:floatData[0]: X-size or diameter of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[1]: Y-size of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[2]: Z-size or height of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[3]: Inside scaling. Undefined if the shape is a compound shape or not pure.reserved: reserved for future extensions. Set to NULL.shapeHandle: handle of the shape. See also simGetObjectHandle.intData (output): pointer to 5 integer values:intData[0]: the pure type of the shape. Undefined if the shape is a compound shape.floatData (output): pointer to 5 float values:floatData[0]: X-size or diameter of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[1]: Y-size of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[2]: Z-size or height of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[3]: Inside scaling. Undefined if the shape is a compound shape or not pure.reserved: reserved for future extensions. Set to NULL.shapeHandle: handle of the shape. See also simGetObjectHandle.intData (output): pointer to 5 integer values:intData[0]: the pure type of the shape. Undefined if the shape is a compound shape.floatData (output): pointer to 5 float values:floatData[0]: X-size or diameter of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[1]: Y-size of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[2]: Z-size or height of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[3]: Inside scaling. Undefined if the shape is a compound shape or not pure.reserved: reserved for future extensions. Set to NULL.shapeHandle: handle of the shape. See also simGetObjectHandle.intData (output): pointer to 5 integer values:intData[0]: the pure type of the shape. Undefined if the shape is a compound shape.floatData (output): pointer to 5 float values:floatData[0]: X-size or diameter of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[1]: Y-size of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[2]: Z-size or height of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[3]: Inside scaling. Undefined if the shape is a compound shape or not pure.reserved: reserved for future extensions. Set to NULL.shapeHandle: handle of the shape. See also simGetObjectHandle.intData (output): pointer to 5 integer values:intData[0]: the pure type of the shape. Undefined if the shape is a compound shape.floatData (output): pointer to 5 float values:floatData[0]: X-size or diameter of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[1]: Y-size of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[2]: Z-size or height of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[3]: Inside scaling. Undefined if the shape is a compound shape or not pure.reserved: reserved for future extensions. Set to NULL.shapeHandle: handle of the shape. See also simGetObjectHandle.intData (output): pointer to 5 integer values:intData[0]: the pure type of the shape. Undefined if the shape is a compound shape.floatData (output): pointer to 5 float values:floatData[0]: X-size or diameter of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[1]: Y-size of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[2]: Z-size or height of the pure shape. Undefined if the shape is a compound shape or not pure.floatData[3]: Inside scaling. Undefined if the shape is a compound shape or not pure.reserved: reserved for future extensions. Set to NULL. -1 in case of an error, otherwise bit-coded:bit0 set (1): shape is a compound shapebit1 set (2): shape is purebit2 set (4): shape is convex-1 in case of an error, otherwise bit-coded:bit0 set (1): shape is a compound shapebit1 set (2): shape is purebit2 set (4): shape is convex-1 in case of an error, otherwise bit-coded:bit0 set (1): shape is a compound shapebit1 set (2): shape is purebit2 set (4): shape is convex-1 in case of an error, otherwise bit-coded:bit0 set (1): shape is a compound shapebit1 set (2): shape is purebit2 set (4): shape is convex"
    }, 
    "debug.setuservalue": {
        "body": "debug.setuservalue( ${1:udata}, ${2:value} )", 
        "scope": "source.lua", 
        "prefix": "debug.setuservalue", 
        "description": "5.2,5.3\n\ndebug.setuservalue (udata, value)"
    }, 
    "sim.getObjectPosition": {
        "body": "sim.getObjectPosition(${0:objectHandle},${1:relativeToObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectPosition", 
        "description": "table_3 position = sim.getObjectPosition(number objectHandle,number relativeToObjectHandle)Retrieves the position of an object. See also sim.setObjectPosition, sim.getObjectOrientation, sim.getObjectMatrix and the other matrix/transformation functions. objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the position. Specify -1 to retrieve the absolute position, sim_handle_parent to retrieve the position relative to the object's parent, or an object handle relative to whose reference frame we want the position.position: pointer to 3 values (x, y and z)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the position. Specify -1 to retrieve the absolute position, sim_handle_parent to retrieve the position relative to the object's parent, or an object handle relative to whose reference frame we want the position.position: pointer to 3 values (x, y and z)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the position. Specify -1 to retrieve the absolute position, sim_handle_parent to retrieve the position relative to the object's parent, or an object handle relative to whose reference frame we want the position.position: pointer to 3 values (x, y and z)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the position. Specify -1 to retrieve the absolute position, sim_handle_parent to retrieve the position relative to the object's parent, or an object handle relative to whose reference frame we want the position.position: pointer to 3 values (x, y and z) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simB0.createServiceClient": {
        "body": "simB0.createServiceClient(${0:nodeHandle},${1:service})", 
        "scope": "source.lua", 
        "prefix": "simB0.createServiceClient", 
        "description": "string handle simB0.createServiceClient(string nodeHandle,string service)"
    }, 
    "sim.appobj_distance_type": {
        "body": "sim.appobj_distance_type", 
        "scope": "source.lua", 
        "prefix": "sim.appobj_distance_type", 
        "description": "Constants"
    }, 
    "sim.arrayparam_fog_color": {
        "body": "sim.arrayparam_fog_color", 
        "scope": "source.lua", 
        "prefix": "sim.arrayparam_fog_color", 
        "description": "Constants"
    }, 
    "simRRS1.SELECT_FLYBY_MODE": {
        "body": "simRRS1.SELECT_FLYBY_MODE(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SELECT_FLYBY_MODE", 
        "description": "int status= simRRS1.SELECT_FLYBY_MODE(bitstring2 rcsHandle)"
    }, 
    "sim.object_shape_type": {
        "body": "sim.object_shape_type", 
        "scope": "source.lua", 
        "prefix": "sim.object_shape_type", 
        "description": "Constants"
    }, 
    "sim.mill_cone_subtype": {
        "body": "sim.mill_cone_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.mill_cone_subtype", 
        "description": "Constants"
    }, 
    "sim.createJoint": {
        "body": "sim.createJoint(${0:jointType},${1:jointMode},${2:options},${3:sizes=nil},${4:colorA=nil},${5:colorB=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.createJoint", 
        "description": "number jointHandle = sim.createJoint(number jointType,number jointMode,number options,table_2 sizes=nil,table_12 colorA=nil,table_12 colorB=nil)Creates a joint. See also sim.setJointInterval. jointType: sim_joint_revolute_subtype, sim_joint_prismatic_subtype or sim_joint_spherical_subtypejointMode: a joint mode valueoptions: bit-coded. For now only bit 0 is used (if set (1), the joint operates in hybrid mode)sizes: pointer to 2 values indicating the joint length and diameter. Can be NULL for default valuescolorA: pointer to 4x3 values for joint color A (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuescolorB: pointer to 4x3 values for joint color B (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuesjointType: sim_joint_revolute_subtype, sim_joint_prismatic_subtype or sim_joint_spherical_subtypejointMode: a joint mode valueoptions: bit-coded. For now only bit 0 is used (if set (1), the joint operates in hybrid mode)sizes: pointer to 2 values indicating the joint length and diameter. Can be NULL for default valuescolorA: pointer to 4x3 values for joint color A (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuescolorB: pointer to 4x3 values for joint color B (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuesjointType: sim_joint_revolute_subtype, sim_joint_prismatic_subtype or sim_joint_spherical_subtypejointMode: a joint mode valueoptions: bit-coded. For now only bit 0 is used (if set (1), the joint operates in hybrid mode)sizes: pointer to 2 values indicating the joint length and diameter. Can be NULL for default valuescolorA: pointer to 4x3 values for joint color A (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuescolorB: pointer to 4x3 values for joint color B (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuesjointType: sim_joint_revolute_subtype, sim_joint_prismatic_subtype or sim_joint_spherical_subtypejointMode: a joint mode valueoptions: bit-coded. For now only bit 0 is used (if set (1), the joint operates in hybrid mode)sizes: pointer to 2 values indicating the joint length and diameter. Can be NULL for default valuescolorA: pointer to 4x3 values for joint color A (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuescolorB: pointer to 4x3 values for joint color B (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuesjointType: sim_joint_revolute_subtype, sim_joint_prismatic_subtype or sim_joint_spherical_subtypejointMode: a joint mode valueoptions: bit-coded. For now only bit 0 is used (if set (1), the joint operates in hybrid mode)sizes: pointer to 2 values indicating the joint length and diameter. Can be NULL for default valuescolorA: pointer to 4x3 values for joint color A (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuescolorB: pointer to 4x3 values for joint color B (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuesjointType: sim_joint_revolute_subtype, sim_joint_prismatic_subtype or sim_joint_spherical_subtypejointMode: a joint mode valueoptions: bit-coded. For now only bit 0 is used (if set (1), the joint operates in hybrid mode)sizes: pointer to 2 values indicating the joint length and diameter. Can be NULL for default valuescolorA: pointer to 4x3 values for joint color A (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuescolorB: pointer to 4x3 values for joint color B (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default values -1 if operation was not successful, otherwise the handle of the joint"
    }, 
    "sim.dummyintparam_link_type": {
        "body": "sim.dummyintparam_link_type", 
        "scope": "source.lua", 
        "prefix": "sim.dummyintparam_link_type", 
        "description": "Constants"
    }, 
    "sim.getObjectParent": {
        "body": "sim.getObjectParent(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectParent", 
        "description": "number parentObjectHandle = sim.getObjectParent(number objectHandle)Retrieves the handle of an object's parent object. See also sim.setObjectParent and sim.getObjectChild. objectHandle: handle of the objectobjectHandle: handle of the object handle of parent or -1 if the parent doesn't exist or in case of an error"
    }, 
    "sim.intparam_qt_version": {
        "body": "sim.intparam_qt_version", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_qt_version", 
        "description": "Constants"
    }, 
    "sim.message_scene_loaded": {
        "body": "sim.message_scene_loaded", 
        "scope": "source.lua", 
        "prefix": "sim.message_scene_loaded", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_p0damping": {
        "body": "sim.vortex_joint_p0damping", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p0damping", 
        "description": "Constants"
    }, 
    "sim.vortex_global_constraintangulardamping": {
        "body": "sim.vortex_global_constraintangulardamping", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_global_constraintangulardamping", 
        "description": "Constants"
    }, 
    "sim.banner_followparentvisibility": {
        "body": "sim.banner_followparentvisibility", 
        "scope": "source.lua", 
        "prefix": "sim.banner_followparentvisibility", 
        "description": "Constants"
    }, 
    "simx.getObjectChild": {
        "body": "simx.getObjectChild(${0:clientId},${1:parentObjectHandle},${2:childIndex})", 
        "scope": "source.lua", 
        "prefix": "simx.getObjectChild", 
        "description": "number returnCode,number childObjectHandle= simx.getObjectChild(number clientId,number parentObjectHandle,number childIndex)Retrieves the handle of an object's child object. See also simx.getObjectParent. clientID: the client ID. refer to simx.start.parentObjectHandle: handle of the objectchildIndex: zero-based index of the child's position. To retrieve all children of an object, call the function by increasing the index until the child handle is  -1operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return codechildObjectHandle: the handle of the child object. If the value is -1, there is no child at the given index"
    }, 
    "sim.buffer_float": {
        "body": "sim.buffer_float", 
        "scope": "source.lua", 
        "prefix": "sim.buffer_float", 
        "description": "Constants"
    }, 
    "sim.customizationscriptattribute_cleanupbeforesave": {
        "body": "sim.customizationscriptattribute_cleanupbeforesave", 
        "scope": "source.lua", 
        "prefix": "sim.customizationscriptattribute_cleanupbeforesave", 
        "description": "Constants"
    }, 
    "sim.intparam_settings": {
        "body": "sim.intparam_settings", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_settings", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_motorconstraintfrictioncoeff": {
        "body": "sim.vortex_joint_motorconstraintfrictioncoeff", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_motorconstraintfrictioncoeff", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_kc_k": {
        "body": "sim.jointfloatparam_kc_k", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_kc_k", 
        "description": "Constants"
    }, 
    "sim.simulation_advancing_running": {
        "body": "sim.simulation_advancing_running", 
        "scope": "source.lua", 
        "prefix": "sim.simulation_advancing_running", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_tobuffer2": {
        "body": "sim.filtercomponent_tobuffer2", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_tobuffer2", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_tobuffer1": {
        "body": "sim.filtercomponent_tobuffer1", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_tobuffer1", 
        "description": "Constants"
    }, 
    "sim.intparam_event_flags_read_clear": {
        "body": "sim.intparam_event_flags_read_clear", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_event_flags_read_clear", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_kc_c": {
        "body": "sim.jointfloatparam_kc_c", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_kc_c", 
        "description": "Constants"
    }, 
    "math.pi": {
        "body": "math.pi(${0:...})", 
        "scope": "source.lua", 
        "prefix": "math.pi", 
        "description": "5.1,5.2,5.3\n\nmath.pi"
    }, 
    "sysCall_sensing": {
        "body": "sysCall_sensing(${0:phase.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_sensing", 
        "description": "sysCall_sensing(Called in the sensing phase.)"
    }, 
    "simx.setFloatingParameter": {
        "body": "simx.setFloatingParameter(${0:clientId},${1:paramIdentifier},${2:paramValue})", 
        "scope": "source.lua", 
        "prefix": "simx.setFloatingParameter", 
        "description": "number returnCode= simx.setFloatingParameter(number clientId,number paramIdentifier,number paramValue)Sets a floating point parameter. See also simx.getFloatingParameter, simx.setBooleanParameter, simx.setArrayParameter and simx.setIntegerParameter. clientID: the client ID. refer to simx.start.paramIdentifier: a floating parameter identifierparamValue: the parameter valueoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "simRRS1.SET_MOTION_TIME": {
        "body": "simRRS1.SET_MOTION_TIME(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_MOTION_TIME", 
        "description": "int status= simRRS1.SET_MOTION_TIME(bitstring2 rcsHandle)"
    }, 
    "simROS.getTime": {
        "body": "simROS.getTime(${0:flag=0})", 
        "scope": "source.lua", 
        "prefix": "simROS.getTime", 
        "description": "number time = simROS.getTime(number flag=0)"
    }, 
    "simUI.curve_scatter_shape.diamond": {
        "body": "simUI.curve_scatter_shape.diamond", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_scatter_shape.diamond", 
        "description": "Constants"
    }, 
    "sim.displayattribute_mainselection": {
        "body": "sim.displayattribute_mainselection", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_mainselection", 
        "description": "Constants"
    }, 
    "sim.object_dummy_type": {
        "body": "sim.object_dummy_type", 
        "scope": "source.lua", 
        "prefix": "sim.object_dummy_type", 
        "description": "Constants"
    }, 
    "sim.pauseSimulation": {
        "body": "sim.pauseSimulation()", 
        "scope": "source.lua", 
        "prefix": "sim.pauseSimulation", 
        "description": "number result = sim.pauseSimulation()Requests a pause of a simulation. See also sim.startSimulation, sim.stopSimulation and sim.getSimulationState. See also the simulation state diagram. None -1 in case of an error, 0 if the operation could not be performed. >0 in case of success."
    }, 
    "simOMPL.interpolatePath": {
        "body": "simOMPL.interpolatePath(${0:taskHandle},${1:stateCnt=0})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.interpolatePath", 
        "description": "number result = simOMPL.interpolatePath(number taskHandle,number stateCnt=0)"
    }, 
    "sim.customizationscriptcall_simulationpauselast": {
        "body": "sim.customizationscriptcall_simulationpauselast", 
        "scope": "source.lua", 
        "prefix": "sim.customizationscriptcall_simulationpauselast", 
        "description": "Constants"
    }, 
    "sim.getOctreeVoxels": {
        "body": "sim.getOctreeVoxels(${0:octreeHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getOctreeVoxels", 
        "description": "table voxels = sim.getOctreeVoxels(number octreeHandle)Retrieves voxel positions from an octree. See also the other octree related functions. octreeHandle: the handle of the octree. See also simGetObjectHandleptCnt: a pointer receiving the number of voxels contained in the returned pointer.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleptCnt: a pointer receiving the number of voxels contained in the returned pointer.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleptCnt: a pointer receiving the number of voxels contained in the returned pointer.reserved: reserved for future extensions. Set to NULL NULL if operation was not successful or if the octree doesn't contain any voxels. Otherwise a pointer to the voxel X/Y/Z positions, relative to the octree reference frame"
    }, 
    "simx.headeroffset_server_time": {
        "body": "simx.headeroffset_server_time", 
        "scope": "source.lua", 
        "prefix": "simx.headeroffset_server_time", 
        "description": "Constants"
    }, 
    "simRRS1.GET_EVENT": {
        "body": "simRRS1.GET_EVENT(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.GET_EVENT", 
        "description": "int status,int eventId,real timeTillEvent= simRRS1.GET_EVENT(bitstring2 rcsHandle)"
    }, 
    "simOMPL.Algorithm.pRRT": {
        "body": "simOMPL.Algorithm.pRRT", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.pRRT", 
        "description": "Constants"
    }, 
    "sim.scriptattribute_enabled": {
        "body": "sim.scriptattribute_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.scriptattribute_enabled", 
        "description": "Constants"
    }, 
    "sim.refreshDialogs": {
        "body": "sim.refreshDialogs(${0:refreshDegree})", 
        "scope": "source.lua", 
        "prefix": "sim.refreshDialogs", 
        "description": "number result = sim.refreshDialogs(number refreshDegree)Refreshes V-REP's internal dialogs. Calling sim.refreshDialogs will not trigger a sim_message_eventcallback_refreshdialogs message refreshDegree: refresh degree (0=light, 1=medium, 2=full)refreshDegree: refresh degree (0=light, 1=medium, 2=full) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simx.getObjectFloatParameter": {
        "body": "simx.getObjectFloatParameter(${0:clientId},${1:objectHandle},${2:parameterId})", 
        "scope": "source.lua", 
        "prefix": "simx.getObjectFloatParameter", 
        "description": "number returnCode,number parameterValue= simx.getObjectFloatParameter(number clientId,number objectHandle,number parameterId)Retrieves a floating-point parameter of a object. See also simx.setObjectFloatParameter and simx.getObjectIntParameter. clientID: the client ID. refer to simx.start.objectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersoperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls), or simx.opmode_blocking (depending on the intended usage) returnCode: a remote API function return codeparameterValue: the value of the parameter"
    }, 
    "sim.createHeightfieldShape": {
        "body": "sim.createHeightfieldShape(${0:options},${1:shadingAngle},${2:xPointCount},${3:yPointCount},${4:xSize},${5:heights})", 
        "scope": "source.lua", 
        "prefix": "sim.createHeightfieldShape", 
        "description": "number objectHandle = sim.createHeightfieldShape(number options,number shadingAngle,number xPointCount,number yPointCount,number xSize,table heights)Creates a heightfield shape. See also sim.createPureShape, sim.createMeshShape and sim.addParticleObject. options: bit-coded options:bit 0 set (1): back faces are culledbit 1 set (2): overlay mesh is visiblebit 2 set (4): a simple shape is generated instead of a heightfieldbit 3 set (8): the heightfield is not respondableshadingAngle: the shading anglexPointCount/yPointCount: the number of rows and lines of the heightfield.xSize: the length of the x side of the heightfieldheights: a pointer to xPointCount*yPointCount height values.options: bit-coded options:bit 0 set (1): back faces are culledbit 1 set (2): overlay mesh is visiblebit 2 set (4): a simple shape is generated instead of a heightfieldbit 3 set (8): the heightfield is not respondableshadingAngle: the shading anglexPointCount/yPointCount: the number of rows and lines of the heightfield.xSize: the length of the x side of the heightfieldheights: a pointer to xPointCount*yPointCount height values.options: bit-coded options:bit 0 set (1): back faces are culledbit 1 set (2): overlay mesh is visiblebit 2 set (4): a simple shape is generated instead of a heightfieldbit 3 set (8): the heightfield is not respondableshadingAngle: the shading anglexPointCount/yPointCount: the number of rows and lines of the heightfield.xSize: the length of the x side of the heightfieldheights: a pointer to xPointCount*yPointCount height values.options: bit-coded options:bit 0 set (1): back faces are culledbit 1 set (2): overlay mesh is visiblebit 2 set (4): a simple shape is generated instead of a heightfieldbit 3 set (8): the heightfield is not respondableshadingAngle: the shading anglexPointCount/yPointCount: the number of rows and lines of the heightfield.xSize: the length of the x side of the heightfieldheights: a pointer to xPointCount*yPointCount height values.options: bit-coded options:bit 0 set (1): back faces are culledbit 1 set (2): overlay mesh is visiblebit 2 set (4): a simple shape is generated instead of a heightfieldbit 3 set (8): the heightfield is not respondableshadingAngle: the shading anglexPointCount/yPointCount: the number of rows and lines of the heightfield.xSize: the length of the x side of the heightfieldheights: a pointer to xPointCount*yPointCount height values.options: bit-coded options:bit 0 set (1): back faces are culledbit 1 set (2): overlay mesh is visiblebit 2 set (4): a simple shape is generated instead of a heightfieldbit 3 set (8): the heightfield is not respondableshadingAngle: the shading anglexPointCount/yPointCount: the number of rows and lines of the heightfield.xSize: the length of the x side of the heightfieldheights: a pointer to xPointCount*yPointCount height values.options: bit-coded options:bit 0 set (1): back faces are culledbit 1 set (2): overlay mesh is visiblebit 2 set (4): a simple shape is generated instead of a heightfieldbit 3 set (8): the heightfield is not respondableshadingAngle: the shading anglexPointCount/yPointCount: the number of rows and lines of the heightfield.xSize: the length of the x side of the heightfieldheights: a pointer to xPointCount*yPointCount height values.options: bit-coded options:bit 0 set (1): back faces are culledbit 1 set (2): overlay mesh is visiblebit 2 set (4): a simple shape is generated instead of a heightfieldbit 3 set (8): the heightfield is not respondableshadingAngle: the shading anglexPointCount/yPointCount: the number of rows and lines of the heightfield.xSize: the length of the x side of the heightfieldheights: a pointer to xPointCount*yPointCount height values.options: bit-coded options:bit 0 set (1): back faces are culledbit 1 set (2): overlay mesh is visiblebit 2 set (4): a simple shape is generated instead of a heightfieldbit 3 set (8): the heightfield is not respondableshadingAngle: the shading anglexPointCount/yPointCount: the number of rows and lines of the heightfield.xSize: the length of the x side of the heightfieldheights: a pointer to xPointCount*yPointCount height values.options: bit-coded options:bit 0 set (1): back faces are culledbit 1 set (2): overlay mesh is visiblebit 2 set (4): a simple shape is generated instead of a heightfieldbit 3 set (8): the heightfield is not respondableshadingAngle: the shading anglexPointCount/yPointCount: the number of rows and lines of the heightfield.xSize: the length of the x side of the heightfieldheights: a pointer to xPointCount*yPointCount height values. -1 if operation was not successful, otherwise the handle of the newly created shape"
    }, 
    "simICP.match": {
        "body": "simICP.match(${0:model_handle},${1:template_handle},${2:outlier_treshold=-1})", 
        "scope": "source.lua", 
        "prefix": "simICP.match", 
        "description": "table m = simICP.match(number model_handle,number template_handle,number outlier_treshold=-1)"
    }, 
    "sim.displayattribute_depthpass": {
        "body": "sim.displayattribute_depthpass", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_depthpass", 
        "description": "Constants"
    }, 
    "math.mininteger": {
        "body": "math.mininteger(${0:...})", 
        "scope": "source.lua", 
        "prefix": "math.mininteger", 
        "description": "5.3\n\nmath.mininteger"
    }, 
    "sim.boolparam_fog_enabled": {
        "body": "sim.boolparam_fog_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_fog_enabled", 
        "description": "Constants"
    }, 
    "simROS.setParamInt": {
        "body": "simROS.setParamInt(${0:name},${1:value})", 
        "scope": "source.lua", 
        "prefix": "simROS.setParamInt", 
        "description": "simROS.setParamInt(string name,number value)"
    }, 
    "sim.drawing_lines": {
        "body": "sim.drawing_lines", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_lines", 
        "description": "Constants"
    }, 
    "string.upper": {
        "body": "string.upper( ${1:s} )", 
        "scope": "source.lua", 
        "prefix": "string.upper", 
        "description": "5.1,5.2,5.3\n\nstring.upper"
    }, 
    "simRRS1.SELECT_POINT_ACCURACY": {
        "body": "simRRS1.SELECT_POINT_ACCURACY(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SELECT_POINT_ACCURACY", 
        "description": "int status= simRRS1.SELECT_POINT_ACCURACY(bitstring2 rcsHandle)"
    }, 
    "sim.setVisionSensorFilter": {
        "body": "sim.setVisionSensorFilter(${0:sensorHandle},${1:filterIndex},${2:byteVals},${3:intVals},${4:floatVals},${5:customBuffer})", 
        "scope": "source.lua", 
        "prefix": "sim.setVisionSensorFilter", 
        "description": "number filterType = sim.setVisionSensorFilter(number sensorHandle,number filterIndex,number optionstable byteVals,table intVals,table floatVals,string customBuffer)Sets the parameters and settings of a specific filter component of a vision sensor. See also sim.getVisionSensorFilter and the other vision sensor related API functions. visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values indicating the sizes of the provided buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component.ints: a buffer of ints values representing the int parameters of the filter component.floats: a buffer of floats values representing the float parameters of the filter component.custom: a buffer of bytes values representing the custom parameters of the filter component.visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values indicating the sizes of the provided buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component.ints: a buffer of ints values representing the int parameters of the filter component.floats: a buffer of floats values representing the float parameters of the filter component.custom: a buffer of bytes values representing the custom parameters of the filter component.visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values indicating the sizes of the provided buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component.ints: a buffer of ints values representing the int parameters of the filter component.floats: a buffer of floats values representing the float parameters of the filter component.custom: a buffer of bytes values representing the custom parameters of the filter component.visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values indicating the sizes of the provided buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component.ints: a buffer of ints values representing the int parameters of the filter component.floats: a buffer of floats values representing the float parameters of the filter component.custom: a buffer of bytes values representing the custom parameters of the filter component.visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values indicating the sizes of the provided buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component.ints: a buffer of ints values representing the int parameters of the filter component.floats: a buffer of floats values representing the float parameters of the filter component.custom: a buffer of bytes values representing the custom parameters of the filter component.visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values indicating the sizes of the provided buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component.ints: a buffer of ints values representing the int parameters of the filter component.floats: a buffer of floats values representing the float parameters of the filter component.custom: a buffer of bytes values representing the custom parameters of the filter component.visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values indicating the sizes of the provided buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component.ints: a buffer of ints values representing the int parameters of the filter component.floats: a buffer of floats values representing the float parameters of the filter component.custom: a buffer of bytes values representing the custom parameters of the filter component.visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values indicating the sizes of the provided buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component.ints: a buffer of ints values representing the int parameters of the filter component.floats: a buffer of floats values representing the float parameters of the filter component.custom: a buffer of bytes values representing the custom parameters of the filter component.visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values indicating the sizes of the provided buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component.ints: a buffer of ints values representing the int parameters of the filter component.floats: a buffer of floats values representing the float parameters of the filter component.custom: a buffer of bytes values representing the custom parameters of the filter component. -1 in case of an error, 0 if the filterIndex is not valid, otherwise the type of filter component pointed by the filterIndex."
    }, 
    "sim.setScriptText": {
        "body": "sim.setScriptText(${0:scriptHandle},${1:scriptText})", 
        "scope": "source.lua", 
        "prefix": "sim.setScriptText", 
        "description": "number result = sim.setScriptText(number scriptHandle,string scriptText)Sets a new content for a script (i.e. attaches a new Lua code). During a simulation, the new script content might not be taken into consideration if a previous code was already executed at least once. Use with care when simulation is running. See also simGetScriptText, sim.addScript and sim.associateScriptWithObject. scriptHandle: handle of a scriptscriptText: pointer to a script buffer (0-terminated buffer). This function will copy the buffer content, so that it can immediately be released after this callscriptHandle: handle of a scriptscriptText: pointer to a script buffer (0-terminated buffer). This function will copy the buffer content, so that it can immediately be released after this callscriptHandle: handle of a scriptscriptText: pointer to a script buffer (0-terminated buffer). This function will copy the buffer content, so that it can immediately be released after this call -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.visionfloatparam_near_clipping": {
        "body": "sim.visionfloatparam_near_clipping", 
        "scope": "source.lua", 
        "prefix": "sim.visionfloatparam_near_clipping", 
        "description": "Constants"
    }, 
    "sim.vortex_body_primangularaxisfriction": {
        "body": "sim.vortex_body_primangularaxisfriction", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_primangularaxisfriction", 
        "description": "Constants"
    }, 
    "sim.getRotationAxis": {
        "body": "sim.getRotationAxis(${0:matrixStart},${1:matrixGoal})", 
        "scope": "source.lua", 
        "prefix": "sim.getRotationAxis", 
        "description": "table_3 axis,number angle = sim.getRotationAxis(table_12 matrixStart,table_12 matrixGoal)Retrieves an axis and rotation angle that brings one transformation matrix onto another one. The translation part of the transformation matrices is ignored. This function, when used in combination with sim.rotateAroundAxis, can be used to build interpolations between transformation matrices. See also sim.getObjectMatrix, sim.setObjectMatrix and the other matrix/transformation functions. matrixStart: the start transformation matrixmatrixGoal: the goal transformation matrixaxis: the returned rotation axis in absolute coordinatesangle: the returned rotation anglematrixStart: the start transformation matrixmatrixGoal: the goal transformation matrixaxis: the returned rotation axis in absolute coordinatesangle: the returned rotation anglematrixStart: the start transformation matrixmatrixGoal: the goal transformation matrixaxis: the returned rotation axis in absolute coordinatesangle: the returned rotation anglematrixStart: the start transformation matrixmatrixGoal: the goal transformation matrixaxis: the returned rotation axis in absolute coordinatesangle: the returned rotation anglematrixStart: the start transformation matrixmatrixGoal: the goal transformation matrixaxis: the returned rotation axis in absolute coordinatesangle: the returned rotation angle -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.addonscriptcall_restarting": {
        "body": "sim.addonscriptcall_restarting", 
        "scope": "source.lua", 
        "prefix": "sim.addonscriptcall_restarting", 
        "description": "Constants"
    }, 
    "sim.unpackUInt8Table": {
        "body": "sim.unpackUInt8Table(${0:data},${1:startUint8Index=0},${2:uint8count=0})", 
        "scope": "source.lua", 
        "prefix": "sim.unpackUInt8Table", 
        "description": "table uint8Numbers = sim.unpackUInt8Table(string data,number startUint8Index=0,number uint8count=0)Unpacks a string (or part of it) into a table of uint8 numbers. See also sim.packUInt8Table and the other packing/unpacking functions. - -"
    }, 
    "sim.pure_primitive_heightfield": {
        "body": "sim.pure_primitive_heightfield", 
        "scope": "source.lua", 
        "prefix": "sim.pure_primitive_heightfield", 
        "description": "Constants"
    }, 
    "math.rad": {
        "body": "math.rad(${0:...})", 
        "scope": "source.lua", 
        "prefix": "math.rad", 
        "description": "5.1,5.2,5.3\n\nmath.rad (x)"
    }, 
    "sim.jointfloatparam_vortex_dep_offset": {
        "body": "sim.jointfloatparam_vortex_dep_offset", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_vortex_dep_offset", 
        "description": "Constants"
    }, 
    "sim.drawing_points": {
        "body": "sim.drawing_points", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_points", 
        "description": "Constants"
    }, 
    "sim.navigation_createpathpoint": {
        "body": "sim.navigation_createpathpoint", 
        "scope": "source.lua", 
        "prefix": "sim.navigation_createpathpoint", 
        "description": "Constants"
    }, 
    "simROS.shutdownServiceClient": {
        "body": "simROS.shutdownServiceClient(${0:serviceClientHandle})", 
        "scope": "source.lua", 
        "prefix": "simROS.shutdownServiceClient", 
        "description": "simROS.shutdownServiceClient(number serviceClientHandle)"
    }, 
    "sim.bullet_joint_stoperp": {
        "body": "sim.bullet_joint_stoperp", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_joint_stoperp", 
        "description": "Constants"
    }, 
    "sim.shapeintparam_convex_check": {
        "body": "sim.shapeintparam_convex_check", 
        "scope": "source.lua", 
        "prefix": "sim.shapeintparam_convex_check", 
        "description": "Constants"
    }, 
    "sim.setObjectSizeValues": {
        "body": "sim.setObjectSizeValues(${0:objectHandle},${1:sizeValues})", 
        "scope": "source.lua", 
        "prefix": "sim.setObjectSizeValues", 
        "description": "number result = sim.setObjectSizeValues(number objectHandle,table_3 sizeValues)Sets the x, y and z size values of a scene object. The size values are different from the real object sizes. Use this to be able to react to scaling operations. See also sim.getObjectSizeValues. objectHandle: handle of the scene objectsizeValues (input): a pointer to 3 size values (x, y and z)objectHandle: handle of the scene objectsizeValues (input): a pointer to 3 size values (x, y and z) -1 in case of an error"
    }, 
    "package.searchpath": {
        "body": "package.searchpath(${0:...})", 
        "scope": "source.lua", 
        "prefix": "package.searchpath", 
        "description": "5.2,5.3\n\npackage.searchpath (name, path [, sep [, rep]])"
    }, 
    "simRemoteApi.reset": {
        "body": "simRemoteApi.reset()", 
        "scope": "source.lua", 
        "prefix": "simRemoteApi.reset", 
        "description": "number result= simRemoteApi.reset()"
    }, 
    "sim.vortex_body_primangularaxisslide": {
        "body": "sim.vortex_body_primangularaxisslide", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_primangularaxisslide", 
        "description": "Constants"
    }, 
    "sim.getEngineBoolParameter": {
        "body": "sim.getEngineBoolParameter(${0:paramId},${1:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getEngineBoolParameter", 
        "description": "boolean boolParam = sim.getEngineBoolParameter(number paramId,number objectHandle)Retrieves a Boolean value from the physics engine properties. See also the other engine properties setter and getter API functions. paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to retrieve a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to retrieve a global engine parameter. If NULL, then the objectHandle argument will be evaluated.ok: an optional pointer to a value that can be used to determine the success of the API call. Can be NULL.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to retrieve a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to retrieve a global engine parameter. If NULL, then the objectHandle argument will be evaluated.ok: an optional pointer to a value that can be used to determine the success of the API call. Can be NULL.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to retrieve a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to retrieve a global engine parameter. If NULL, then the objectHandle argument will be evaluated.ok: an optional pointer to a value that can be used to determine the success of the API call. Can be NULL.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to retrieve a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to retrieve a global engine parameter. If NULL, then the objectHandle argument will be evaluated.ok: an optional pointer to a value that can be used to determine the success of the API call. Can be NULL. value of the requested parameter. This function call doesn't generate any error message."
    }, 
    "sim.bullet_body_autoshrinkconvex": {
        "body": "sim.bullet_body_autoshrinkconvex", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_body_autoshrinkconvex", 
        "description": "Constants"
    }, 
    "sim.boolparam_objproperties_toolbarbutton_enabled": {
        "body": "sim.boolparam_objproperties_toolbarbutton_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_objproperties_toolbarbutton_enabled", 
        "description": "Constants"
    }, 
    "sim.drawing_persistent": {
        "body": "sim.drawing_persistent", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_persistent", 
        "description": "Constants"
    }, 
    "sim.getJointTargetVelocity": {
        "body": "sim.getJointTargetVelocity(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getJointTargetVelocity", 
        "description": "number targetVelocity = sim.getJointTargetVelocity(number objectHandle)Retrieves the intrinsic target velocity of a non-spherical joint. See also sim.setJointTargetVelocity. objectHandle: handle of the joint objecttargetVelocity (output): target velocity of the joint (linear or angular velocity depending on the joint-type). objectHandle: handle of the joint objecttargetVelocity (output): target velocity of the joint (linear or angular velocity depending on the joint-type).  -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.pathproperty_show_orientation": {
        "body": "sim.pathproperty_show_orientation", 
        "scope": "source.lua", 
        "prefix": "sim.pathproperty_show_orientation", 
        "description": "Constants"
    }, 
    "sim.removeDrawingObject": {
        "body": "sim.removeDrawingObject(${0:drawingObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.removeDrawingObject", 
        "description": "number result = sim.removeDrawingObject(number drawingObjectHandle)Removes a previously added drawing object. See also sim.addDrawingObject and sim.addDrawingObjectItem objectHandle: handle of a previously added drawing object. sim_handle_all removes all drawing objects from the sceneobjectHandle: handle of a previously added drawing object. sim_handle_all removes all drawing objects from the scene -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simUI.getItem": {
        "body": "simUI.getItem(${0:handle},${1:id},${2:row},${3:column})", 
        "scope": "source.lua", 
        "prefix": "simUI.getItem", 
        "description": "string text = simUI.getItem(number handle,number id,number row,number column)"
    }, 
    "simRRS1.SET_FLYBY_CRITERIA_PARAMETER": {
        "body": "simRRS1.SET_FLYBY_CRITERIA_PARAMETER(${0:rcsHandle},${1:paramNumber},${2:jointNr})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_FLYBY_CRITERIA_PARAMETER", 
        "description": "int status= simRRS1.SET_FLYBY_CRITERIA_PARAMETER(bitstring2 rcsHandle,int paramNumber,int jointNr)"
    }, 
    "simUI.replot": {
        "body": "simUI.replot(${0:handle},${1:id})", 
        "scope": "source.lua", 
        "prefix": "simUI.replot", 
        "description": "simUI.replot(number handle,number id)"
    }, 
    "sim.appobj_motionplanning_type": {
        "body": "sim.appobj_motionplanning_type", 
        "scope": "source.lua", 
        "prefix": "sim.appobj_motionplanning_type", 
        "description": "Constants"
    }, 
    "sim.getSimulationState": {
        "body": "sim.getSimulationState()", 
        "scope": "source.lua", 
        "prefix": "sim.getSimulationState", 
        "description": "number simulationState = sim.getSimulationState()Retrieves current simulation state. See also the simulation state diagram. None The current state of the simulation (sim_simulation_stopped, sim_simulation_paused, etc. (see the simulation state values)), or -1 in case of an error"
    }, 
    "sim.setBoolParameter": {
        "body": "sim.setBoolParameter(${0:parameter},${1:boolState})", 
        "scope": "source.lua", 
        "prefix": "sim.setBoolParameter", 
        "description": "number result = sim.setBoolParameter(number parameter,boolean boolState)Sets a boolean parameter. See also sim.getBoolParameter, sim.setInt32Parameter, sim.setArrayParameter and sim.setFloatParameter. parameter: Boolean parameter identifierboolState: new boolean state for the parameterparameter: Boolean parameter identifierboolState: new boolean state for the parameterparameter: Boolean parameter identifierboolState: new boolean state for the parameter -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.newton_joint_dependencyoffset": {
        "body": "sim.newton_joint_dependencyoffset", 
        "scope": "source.lua", 
        "prefix": "sim.newton_joint_dependencyoffset", 
        "description": "Constants"
    }, 
    "sysCall_contactCallback": {
        "body": "sysCall_contactCallback(${0:contacting.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_contactCallback", 
        "description": "sysCall_contactCallback(Called by the physics engine when two respondable shapes are contacting.)"
    }, 
    "sim.childscriptcall_initialization": {
        "body": "sim.childscriptcall_initialization", 
        "scope": "source.lua", 
        "prefix": "sim.childscriptcall_initialization", 
        "description": "Constants"
    }, 
    "sim.volume_ray": {
        "body": "sim.volume_ray", 
        "scope": "source.lua", 
        "prefix": "sim.volume_ray", 
        "description": "Constants"
    }, 
    "sim.floatingViewRemove": {
        "body": "sim.floatingViewRemove(${0:floatingViewHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.floatingViewRemove", 
        "description": "number result = sim.floatingViewRemove(number floatingViewHandle)Removes a floating view previously added with sim.floatingViewAdd.  floatingViewHandle: handle of the floating view to be removedfloatingViewHandle: handle of the floating view to be removed -1 in case of an error, 0 if the floating view could not be found (e.g. because closed by the user), or 1 if the floating view was closed."
    }, 
    "sim.ode_body_lineardamping": {
        "body": "sim.ode_body_lineardamping", 
        "scope": "source.lua", 
        "prefix": "sim.ode_body_lineardamping", 
        "description": "Constants"
    }, 
    "sim.object_graph_type": {
        "body": "sim.object_graph_type", 
        "scope": "source.lua", 
        "prefix": "sim.object_graph_type", 
        "description": "Constants"
    }, 
    "sim.camerafloatparam_pov_aperture": {
        "body": "sim.camerafloatparam_pov_aperture", 
        "scope": "source.lua", 
        "prefix": "sim.camerafloatparam_pov_aperture", 
        "description": "Constants"
    }, 
    "simUI.isNodeValid": {
        "body": "simUI.isNodeValid(${0:handle},${1:id},${2:nodeId})", 
        "scope": "source.lua", 
        "prefix": "simUI.isNodeValid", 
        "description": "bool valid = simUI.isNodeValid(number handle,number id,number nodeId)"
    }, 
    "sim.displayattribute_thickEdges": {
        "body": "sim.displayattribute_thickEdges", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_thickEdges", 
        "description": "Constants"
    }, 
    "simCHAI3D.start": {
        "body": "simCHAI3D.start(${0:deviceIndex},${1:toolRadius},${2:workspaceRadius})", 
        "scope": "source.lua", 
        "prefix": "simCHAI3D.start", 
        "description": "number result = simCHAI3D.start(number deviceIndex,number toolRadius,number workspaceRadius)"
    }, 
    "sim.vortex_joint_p0frictionmaxforce": {
        "body": "sim.vortex_joint_p0frictionmaxforce", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p0frictionmaxforce", 
        "description": "Constants"
    }, 
    "coroutine.running": {
        "body": "coroutine.running( )", 
        "scope": "source.lua", 
        "prefix": "coroutine.running", 
        "description": "5.1,5.2,5.3\n\ncoroutine.running"
    }, 
    "utf8.charpattern": {
        "body": "utf8.charpattern(${0:...})", 
        "scope": "source.lua", 
        "prefix": "utf8.charpattern", 
        "description": "5.3\n\nutf8.charpattern"
    }, 
    "sim.createPath": {
        "body": "sim.createPath(${0:attributes},${1:intParams=nil},${2:floatParams=nil},${3:color=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.createPath", 
        "description": "number pathHandle = sim.createPath(number attributes,table_3 intParams=nil,table_3 floatParams=nil,table_12 color=nil)Creates a path object. See also sim.insertPathCtrlPoints and sim.cutPathCtrlPoints. attributes: a combination of path properties, or -1 for default attributesintParams (input): NULL for default values, or 3 integer values:intParams[0]: line size of the pathintParams[1]: the path length calculation methodintParams[2]: reserved. Set to 0floatParams (input): NULL for default values, or 3 float values:floatParams[0]: control point sizefloatParams[1]: the angular to linear conversion coefficientfloatParams[2]: the virtual distance scaling factorcolor (input): pointer to 4x3 values representing the colors of the path (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuesattributes: a combination of path properties, or -1 for default attributesintParams (input): NULL for default values, or 3 integer values:intParams[0]: line size of the pathintParams[1]: the path length calculation methodintParams[2]: reserved. Set to 0floatParams (input): NULL for default values, or 3 float values:floatParams[0]: control point sizefloatParams[1]: the angular to linear conversion coefficientfloatParams[2]: the virtual distance scaling factorcolor (input): pointer to 4x3 values representing the colors of the path (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuesattributes: a combination of path properties, or -1 for default attributesintParams (input): NULL for default values, or 3 integer values:intParams[0]: line size of the pathintParams[1]: the path length calculation methodintParams[2]: reserved. Set to 0floatParams (input): NULL for default values, or 3 float values:floatParams[0]: control point sizefloatParams[1]: the angular to linear conversion coefficientfloatParams[2]: the virtual distance scaling factorcolor (input): pointer to 4x3 values representing the colors of the path (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuesattributes: a combination of path properties, or -1 for default attributesintParams (input): NULL for default values, or 3 integer values:intParams[0]: line size of the pathintParams[1]: the path length calculation methodintParams[2]: reserved. Set to 0floatParams (input): NULL for default values, or 3 float values:floatParams[0]: control point sizefloatParams[1]: the angular to linear conversion coefficientfloatParams[2]: the virtual distance scaling factorcolor (input): pointer to 4x3 values representing the colors of the path (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuesattributes: a combination of path properties, or -1 for default attributesintParams (input): NULL for default values, or 3 integer values:intParams[0]: line size of the pathintParams[1]: the path length calculation methodintParams[2]: reserved. Set to 0floatParams (input): NULL for default values, or 3 float values:floatParams[0]: control point sizefloatParams[1]: the angular to linear conversion coefficientfloatParams[2]: the virtual distance scaling factorcolor (input): pointer to 4x3 values representing the colors of the path (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuesattributes: a combination of path properties, or -1 for default attributesintParams (input): NULL for default values, or 3 integer values:intParams[0]: line size of the pathintParams[1]: the path length calculation methodintParams[2]: reserved. Set to 0floatParams (input): NULL for default values, or 3 float values:floatParams[0]: control point sizefloatParams[1]: the angular to linear conversion coefficientfloatParams[2]: the virtual distance scaling factorcolor (input): pointer to 4x3 values representing the colors of the path (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuesattributes: a combination of path properties, or -1 for default attributesintParams (input): NULL for default values, or 3 integer values:intParams[0]: line size of the pathintParams[1]: the path length calculation methodintParams[2]: reserved. Set to 0floatParams (input): NULL for default values, or 3 float values:floatParams[0]: control point sizefloatParams[1]: the angular to linear conversion coefficientfloatParams[2]: the virtual distance scaling factorcolor (input): pointer to 4x3 values representing the colors of the path (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuesattributes: a combination of path properties, or -1 for default attributesintParams (input): NULL for default values, or 3 integer values:intParams[0]: line size of the pathintParams[1]: the path length calculation methodintParams[2]: reserved. Set to 0floatParams (input): NULL for default values, or 3 float values:floatParams[0]: control point sizefloatParams[1]: the angular to linear conversion coefficientfloatParams[2]: the virtual distance scaling factorcolor (input): pointer to 4x3 values representing the colors of the path (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuesattributes: a combination of path properties, or -1 for default attributesintParams (input): NULL for default values, or 3 integer values:intParams[0]: line size of the pathintParams[1]: the path length calculation methodintParams[2]: reserved. Set to 0floatParams (input): NULL for default values, or 3 float values:floatParams[0]: control point sizefloatParams[1]: the angular to linear conversion coefficientfloatParams[2]: the virtual distance scaling factorcolor (input): pointer to 4x3 values representing the colors of the path (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuesattributes: a combination of path properties, or -1 for default attributesintParams (input): NULL for default values, or 3 integer values:intParams[0]: line size of the pathintParams[1]: the path length calculation methodintParams[2]: reserved. Set to 0floatParams (input): NULL for default values, or 3 float values:floatParams[0]: control point sizefloatParams[1]: the angular to linear conversion coefficientfloatParams[2]: the virtual distance scaling factorcolor (input): pointer to 4x3 values representing the colors of the path (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default values -1 if operation was not successful, otherwise the handle of the newly created path"
    }, 
    "sim.filtercomponent_shift": {
        "body": "sim.filtercomponent_shift", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_shift", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_frombuffer1": {
        "body": "sim.filtercomponent_frombuffer1", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_frombuffer1", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_frombuffer2": {
        "body": "sim.filtercomponent_frombuffer2", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_frombuffer2", 
        "description": "Constants"
    }, 
    "sim.vortex_body_secangularaxisslip": {
        "body": "sim.vortex_body_secangularaxisslip", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_secangularaxisslip", 
        "description": "Constants"
    }, 
    "sim.navigation_cameraangle": {
        "body": "sim.navigation_cameraangle", 
        "scope": "source.lua", 
        "prefix": "sim.navigation_cameraangle", 
        "description": "Constants"
    }, 
    "sim.shapeintparam_edge_borders_hidden": {
        "body": "sim.shapeintparam_edge_borders_hidden", 
        "scope": "source.lua", 
        "prefix": "sim.shapeintparam_edge_borders_hidden", 
        "description": "Constants"
    }, 
    "bit32.arshift": {
        "body": "bit32.arshift(${0:...})", 
        "scope": "source.lua", 
        "prefix": "bit32.arshift", 
        "description": "5.2\n\nbit32.arshift (x, disp)"
    }, 
    "sim.intparam_dynamic_warning_disabled_mask": {
        "body": "sim.intparam_dynamic_warning_disabled_mask", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_dynamic_warning_disabled_mask", 
        "description": "Constants"
    }, 
    "sim.auxiliaryConsolePrint": {
        "body": "sim.auxiliaryConsolePrint(${0:consoleHandle},${1:text})", 
        "scope": "source.lua", 
        "prefix": "sim.auxiliaryConsolePrint", 
        "description": "number result = sim.auxiliaryConsolePrint(number consoleHandle,string text)Prints to an auxiliary console window. See also sim.auxiliaryConsoleOpen.  consoleHandle: the handle of the console window, previously returned by the simAuxiliaryConsoleOpen commandtext: the text to append, or NULL to clear the console windowconsoleHandle: the handle of the console window, previously returned by the simAuxiliaryConsoleOpen commandtext: the text to append, or NULL to clear the console windowconsoleHandle: the handle of the console window, previously returned by the simAuxiliaryConsoleOpen commandtext: the text to append, or NULL to clear the console window -1 if operation was not successful. 0 if the console doesn't exist (anymore), in which case no error is generated. 1 if the operation was successful."
    }, 
    "sim.light_omnidirectional_subtype": {
        "body": "sim.light_omnidirectional_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.light_omnidirectional_subtype", 
        "description": "Constants"
    }, 
    "sim.texturemap_plane": {
        "body": "sim.texturemap_plane", 
        "scope": "source.lua", 
        "prefix": "sim.texturemap_plane", 
        "description": "Constants"
    }, 
    "sim.getPointCloudPoints": {
        "body": "sim.getPointCloudPoints(${0:pointCloudHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getPointCloudPoints", 
        "description": "table points = sim.getPointCloudPoints(number pointCloudHandle)Retrieves point positions from a point cloud. See also the other point cloud related functions. pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleptCnt: a pointer receiving the number of points contained in the returned pointer.reserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleptCnt: a pointer receiving the number of points contained in the returned pointer.reserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleptCnt: a pointer receiving the number of points contained in the returned pointer.reserved: reserved for future extensions. Set to NULL NULL if operation was not successful or if the point cloud doesn't contain any points. Otherwise a pointer to the point X/Y/Z positions, relative to the point cloud reference frame"
    }, 
    "sim.visionfloatparam_perspective_angle": {
        "body": "sim.visionfloatparam_perspective_angle", 
        "scope": "source.lua", 
        "prefix": "sim.visionfloatparam_perspective_angle", 
        "description": "Constants"
    }, 
    "sim.object_visionsensor_type": {
        "body": "sim.object_visionsensor_type", 
        "scope": "source.lua", 
        "prefix": "sim.object_visionsensor_type", 
        "description": "Constants"
    }, 
    "table.insert": {
        "body": "table.insert( ${1:list},${2: [pos,]}${3: value} )", 
        "scope": "source.lua", 
        "prefix": "table.insert", 
        "description": "5.1,5.2,5.3\n\ntable.insert"
    }, 
    "sim.vortex_joint_a1stiffness": {
        "body": "sim.vortex_joint_a1stiffness", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a1stiffness", 
        "description": "Constants"
    }, 
    "debug.getregistry": {
        "body": "debug.getregistry()", 
        "scope": "source.lua", 
        "prefix": "debug.getregistry", 
        "description": "5.1,5.2,5.3\n\ndebug.getregistry ()"
    }, 
    "sim.buttonproperty_verticallycentered": {
        "body": "sim.buttonproperty_verticallycentered", 
        "scope": "source.lua", 
        "prefix": "sim.buttonproperty_verticallycentered", 
        "description": "Constants"
    }, 
    "simOMPL.Algorithm.LazyRRT": {
        "body": "simOMPL.Algorithm.LazyRRT", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.LazyRRT", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_colorsegmentation": {
        "body": "sim.filtercomponent_colorsegmentation", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_colorsegmentation", 
        "description": "Constants"
    }, 
    "coroutine.resume": {
        "body": "coroutine.resume( ${1:co}${2:[, val1, \\u00b7\\u00b7\\u00b7]} )", 
        "scope": "source.lua", 
        "prefix": "coroutine.resume", 
        "description": "5.1,5.2,5.3\n\ncoroutine.resume"
    }, 
    "sim.displayattribute_noparticles": {
        "body": "sim.displayattribute_noparticles", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_noparticles", 
        "description": "Constants"
    }, 
    "sim.callbackid_dynstep": {
        "body": "sim.callbackid_dynstep", 
        "scope": "source.lua", 
        "prefix": "sim.callbackid_dynstep", 
        "description": "Constants"
    }, 
    "io.output": {
        "body": "io.output(${0:...})", 
        "scope": "source.lua", 
        "prefix": "io.output", 
        "description": "5.1,5.2,5.3\n\nio.output ([file])"
    }, 
    "simx.getJointMatrix": {
        "body": "simx.getJointMatrix(${0:clientId},${1:jointHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.getJointMatrix", 
        "description": "number returnCode,table_12 matrix= simx.getJointMatrix(number clientId,number jointHandle)Retrieves the intrinsic transformation matrix of a joint (the transformation caused by the joint movement). See also simx.setSphericalJointMatrix. clientID: the client ID. refer to simx.start.jointHandle: handle of the jointoperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls) returnCode: a remote API function return codematrix: 12 number values. See the regular API equivalent function for details."
    }, 
    "simUI.setPlotYLabel": {
        "body": "simUI.setPlotYLabel(${0:handle},${1:id},${2:label})", 
        "scope": "source.lua", 
        "prefix": "simUI.setPlotYLabel", 
        "description": "simUI.setPlotYLabel(number handle,number id,string label)"
    }, 
    "sim.createCollection": {
        "body": "sim.createCollection(${0:collectionName},${1:options})", 
        "scope": "source.lua", 
        "prefix": "sim.createCollection", 
        "description": "number collectionHandle = sim.createCollection(string collectionName,number options)Creates a new collection. See also sim.removeCollection and sim.addObjectToCollection.  collectionName: the name of the collection. Use an empty string for a default name.options: bit-coded options:bit 0 set (1): collection overrides collidable, measurable, renderable, cuttable and detectable properties.collectionName: the name of the collection. Use an empty string for a default name.options: bit-coded options:bit 0 set (1): collection overrides collidable, measurable, renderable, cuttable and detectable properties.collectionName: the name of the collection. Use an empty string for a default name.options: bit-coded options:bit 0 set (1): collection overrides collidable, measurable, renderable, cuttable and detectable properties. -1 if operation was not successful, otherwise the handle of the new collection."
    }, 
    "simUI.getCheckboxValue": {
        "body": "simUI.getCheckboxValue(${0:handle},${1:id})", 
        "scope": "source.lua", 
        "prefix": "simUI.getCheckboxValue", 
        "description": "number value = simUI.getCheckboxValue(number handle,number id)"
    }, 
    "utf8.codes": {
        "body": "utf8.codes(${0:...})", 
        "scope": "source.lua", 
        "prefix": "utf8.codes", 
        "description": "5.3\n\nutf8.codes (s)"
    }, 
    "sim.boolparam_display_enabled": {
        "body": "sim.boolparam_display_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_display_enabled", 
        "description": "Constants"
    }, 
    "sim.pathproperty_show_line": {
        "body": "sim.pathproperty_show_line", 
        "scope": "source.lua", 
        "prefix": "sim.pathproperty_show_line", 
        "description": "Constants"
    }, 
    "simROS.getParamString": {
        "body": "simROS.getParamString(${0:name},${1:defaultValue=''})", 
        "scope": "source.lua", 
        "prefix": "simROS.getParamString", 
        "description": "bool exists,string value = simROS.getParamString(string name,string defaultValue='')"
    }, 
    "simx.removeObject": {
        "body": "simx.removeObject(${0:clientId},${1:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.removeObject", 
        "description": "number returnCode= simx.removeObject(number clientId,number objectHandle)Removes a scene object. See also simx.removeModel. clientID: the client ID. refer to simx.start.objectHandle: handle of the object to removeoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot (or simx.opmode_blocking) returnCode: a remote API function return code"
    }, 
    "sim.intparam_speedmodifier": {
        "body": "sim.intparam_speedmodifier", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_speedmodifier", 
        "description": "Constants"
    }, 
    "simMTB.startServer": {
        "body": "simMTB.startServer(${0:mtbServerExecutable},${1:portNumber},${2:program},${3:jointPositions})", 
        "scope": "source.lua", 
        "prefix": "simMTB.startServer", 
        "description": "number mtbServerHandle,string message= simMTB.startServer(string mtbServerExecutable,number portNumber,charBuffer program,table_4 jointPositions)"
    }, 
    "sim.getObjectSpecialProperty": {
        "body": "sim.getObjectSpecialProperty(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectSpecialProperty", 
        "description": "number property = sim.getObjectSpecialProperty(number objectHandle)Retrieves the special properties of a scene object. See also sim.setObjectSpecialProperty, sim.getObjectProperty and sim.getModelProperty. objectHandle: handle of the objectobjectHandle: handle of the object object special property values, -1 if operation was not successful"
    }, 
    "sim.boolXor32": {
        "body": "sim.boolXor32(${0:value1},${1:value2})", 
        "scope": "source.lua", 
        "prefix": "sim.boolXor32", 
        "description": "number result = sim.boolXor32(number value1,number value2)Performs a 32-bit Boolean exclusive-OR operation between two numbers. See also sim.boolAnd32 and sim.boolOr32. - -"
    }, 
    "simx.return_local_error_flag": {
        "body": "simx.return_local_error_flag", 
        "scope": "source.lua", 
        "prefix": "simx.return_local_error_flag", 
        "description": "Constants"
    }, 
    "simRRS1.SET_JOINT_JERKS": {
        "body": "simRRS1.SET_JOINT_JERKS(${0:rcsHandle},${1:allJointFlags},${2:jointFlags},${3:jerkPercent})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_JOINT_JERKS", 
        "description": "int status= simRRS1.SET_JOINT_JERKS(bitstring2 rcsHandle,int allJointFlags,bitstring jointFlags,real_32 jerkPercent)"
    }, 
    "simx.return_timeout_flag": {
        "body": "simx.return_timeout_flag", 
        "scope": "source.lua", 
        "prefix": "simx.return_timeout_flag", 
        "description": "Constants"
    }, 
    "sim.shapefloatparam_texture_z": {
        "body": "sim.shapefloatparam_texture_z", 
        "scope": "source.lua", 
        "prefix": "sim.shapefloatparam_texture_z", 
        "description": "Constants"
    }, 
    "sim.setShapeColor": {
        "body": "sim.setShapeColor(${0:shapeHandle},${1:colorName},${2:colorComponent},${3:rgbData})", 
        "scope": "source.lua", 
        "prefix": "sim.setShapeColor", 
        "description": "number result = sim.setShapeColor(number shapeHandle,string colorName,number colorComponent,table_3 rgbData)Sets the color (or transforms it) of one or several shapes. See also sim.getShapeColor.  shapeHandle: handle of the shape, or sim_handle_all if the command should be directed at all shapescolorName: name of a color. Can be NULL, but if a name is provided, only shapes (or sub-entities of them) with a same color name will be modified. By specifying special names, the color can directly be transformed in the Hue-Saturation-Lightness (HSL) space:@0: all specified shape outside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.@1: all specified shape inside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.@2: all specified shape edge colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.colorComponent: a color componentrgbData: red, green and blue components of the color (3 values), or the transparency value (1 value)shapeHandle: handle of the shape, or sim_handle_all if the command should be directed at all shapescolorName: name of a color. Can be NULL, but if a name is provided, only shapes (or sub-entities of them) with a same color name will be modified. By specifying special names, the color can directly be transformed in the Hue-Saturation-Lightness (HSL) space:@0: all specified shape outside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.@1: all specified shape inside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.@2: all specified shape edge colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.colorComponent: a color componentrgbData: red, green and blue components of the color (3 values), or the transparency value (1 value)shapeHandle: handle of the shape, or sim_handle_all if the command should be directed at all shapescolorName: name of a color. Can be NULL, but if a name is provided, only shapes (or sub-entities of them) with a same color name will be modified. By specifying special names, the color can directly be transformed in the Hue-Saturation-Lightness (HSL) space:@0: all specified shape outside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.@1: all specified shape inside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.@2: all specified shape edge colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.colorComponent: a color componentrgbData: red, green and blue components of the color (3 values), or the transparency value (1 value)shapeHandle: handle of the shape, or sim_handle_all if the command should be directed at all shapescolorName: name of a color. Can be NULL, but if a name is provided, only shapes (or sub-entities of them) with a same color name will be modified. By specifying special names, the color can directly be transformed in the Hue-Saturation-Lightness (HSL) space:@0: all specified shape outside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.@1: all specified shape inside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.@2: all specified shape edge colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.colorComponent: a color componentrgbData: red, green and blue components of the color (3 values), or the transparency value (1 value)shapeHandle: handle of the shape, or sim_handle_all if the command should be directed at all shapescolorName: name of a color. Can be NULL, but if a name is provided, only shapes (or sub-entities of them) with a same color name will be modified. By specifying special names, the color can directly be transformed in the Hue-Saturation-Lightness (HSL) space:@0: all specified shape outside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.@1: all specified shape inside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.@2: all specified shape edge colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.colorComponent: a color componentrgbData: red, green and blue components of the color (3 values), or the transparency value (1 value)shapeHandle: handle of the shape, or sim_handle_all if the command should be directed at all shapescolorName: name of a color. Can be NULL, but if a name is provided, only shapes (or sub-entities of them) with a same color name will be modified. By specifying special names, the color can directly be transformed in the Hue-Saturation-Lightness (HSL) space:@0: all specified shape outside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.@1: all specified shape inside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.@2: all specified shape edge colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.colorComponent: a color componentrgbData: red, green and blue components of the color (3 values), or the transparency value (1 value)shapeHandle: handle of the shape, or sim_handle_all if the command should be directed at all shapescolorName: name of a color. Can be NULL, but if a name is provided, only shapes (or sub-entities of them) with a same color name will be modified. By specifying special names, the color can directly be transformed in the Hue-Saturation-Lightness (HSL) space:@0: all specified shape outside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.@1: all specified shape inside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.@2: all specified shape edge colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.colorComponent: a color componentrgbData: red, green and blue components of the color (3 values), or the transparency value (1 value)shapeHandle: handle of the shape, or sim_handle_all if the command should be directed at all shapescolorName: name of a color. Can be NULL, but if a name is provided, only shapes (or sub-entities of them) with a same color name will be modified. By specifying special names, the color can directly be transformed in the Hue-Saturation-Lightness (HSL) space:@0: all specified shape outside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.@1: all specified shape inside colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.@2: all specified shape edge colors will be transformed such as: HSL={H+rgbData[0],S+rgbData[1],L+rgbData[2]}, where H operates in a cyclic manner.colorComponent: a color componentrgbData: red, green and blue components of the color (3 values), or the transparency value (1 value) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simSurfRec.reconstruct": {
        "body": "simSurfRec.reconstruct(${0:pointCloudHandle},${1:algorithm=sim_surfacereconstruction_algorithm_scalespace},${2:perimeterBound=0.0})", 
        "scope": "source.lua", 
        "prefix": "simSurfRec.reconstruct", 
        "description": "number shapeHandle,number neighborhoodSquaredRadius = simSurfRec.reconstruct(number pointCloudHandle,number algorithm=sim_surfacereconstruction_algorithm_scalespace,number perimeterBound=0.0)"
    }, 
    "simUI.restoreState": {
        "body": "simUI.restoreState(${0:handle},${1:id},${2:state})", 
        "scope": "source.lua", 
        "prefix": "simUI.restoreState", 
        "description": "simUI.restoreState(number handle,number id,string state)"
    }, 
    "sim.readCollision": {
        "body": "sim.readCollision(${0:collisionObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.readCollision", 
        "description": "number collisionState,table_2 collidingObjectHandles = sim.readCollision(number collisionObjectHandle)Reads the collision state of a registered collision object. This function doesn't perform collision detection, it merely reads the result from a previous call to sim.handleCollision (sim.handleCollision is called in the default main script). See also sim.resetCollision, sim.checkCollision and sim.checkCollisionEx. collisionObjectHandle: handle of the collision object collision state (0 or 1), or -1 if operation was not successful."
    }, 
    "simUI.setColumnCount": {
        "body": "simUI.setColumnCount(${0:handle},${1:id},${2:count},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setColumnCount", 
        "description": "simUI.setColumnCount(number handle,number id,number count,bool suppressEvents=true)"
    }, 
    "sim.buttonproperty_rollupaction": {
        "body": "sim.buttonproperty_rollupaction", 
        "scope": "source.lua", 
        "prefix": "sim.buttonproperty_rollupaction", 
        "description": "Constants"
    }, 
    "simOMPL.Algorithm.SPARStwo": {
        "body": "simOMPL.Algorithm.SPARStwo", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.SPARStwo", 
        "description": "Constants"
    }, 
    "sim.setObjectInt32Parameter": {
        "body": "sim.setObjectInt32Parameter(${0:objectHandle},${1:parameterID},${2:parameter})", 
        "scope": "source.lua", 
        "prefix": "sim.setObjectInt32Parameter", 
        "description": "number result = sim.setObjectInt32Parameter(number objectHandle,number parameterID,number parameter)Sets an int32 parameter of a scene object or calculation object. See also sim.getObjectInt32Parameter, sim.setObjectFloatParameter and sim.setObjectStringParameter objectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: parameter valueobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: parameter valueobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: parameter valueobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: parameter value -1 in case of an error, 0 if the parameter could not be set (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful"
    }, 
    "string.gsub": {
        "body": "string.gsub( ${1:s},${2:pattern},${3:repl}${4:[, n]} )", 
        "scope": "source.lua", 
        "prefix": "string.gsub", 
        "description": "5.1,5.2,5.3\n\nstring.gsub"
    }, 
    "sim.banner_facingcamera": {
        "body": "sim.banner_facingcamera", 
        "scope": "source.lua", 
        "prefix": "sim.banner_facingcamera", 
        "description": "Constants"
    }, 
    "sim.removeBanner": {
        "body": "sim.removeBanner(${0:bannerID})", 
        "scope": "source.lua", 
        "prefix": "sim.removeBanner", 
        "description": "number result = sim.removeBanner(number bannerID)Removes a previously added banner. See also sim.addBanner bannerID: handle of a previously added banner. sim_handle_all removes all banners from the scene. If you or-combine the bannerID with sim_handleflag_togglevisibility, then you can toggle the banner's visibility without removing it: in that case, the return value is the new visibility stae of the banner.bannerID: handle of a previously added banner. sim_handle_all removes all banners from the scene. If you or-combine the bannerID with sim_handleflag_togglevisibility, then you can toggle the banner's visibility without removing it: in that case, the return value is the new visibility stae of the banner. -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simx.getInMessageInfo": {
        "body": "simx.getInMessageInfo(${0:clientId})", 
        "scope": "source.lua", 
        "prefix": "simx.getInMessageInfo", 
        "description": "number result,number info= simx.getInMessageInfo(number clientId)Retrieves information about the last received message from the server. This is a remote API helper function. See also simx.getOutMessageInfo.If the client didn't receive any command reply from the server for a while, the data retrieved with this function won't be up-to-date. In order to avoid this, you should start at least one streaming command, which will guarantee regular message income. clientID: the client ID. refer to simx.start.infoType: an inbox message info type result: -1 in case of an errorinfo: the requested information"
    }, 
    "string.match": {
        "body": "string.match( ${1:s},${2:pattern}${3:[, init]} )", 
        "scope": "source.lua", 
        "prefix": "string.match", 
        "description": "5.1,5.2,5.3\n\nstring.match"
    }, 
    "simUI.setSpinboxValue": {
        "body": "simUI.setSpinboxValue(${0:handle},${1:id},${2:value},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setSpinboxValue", 
        "description": "simUI.setSpinboxValue(number handle,number id,number value,bool suppressEvents=true)"
    }, 
    "utf8.offset": {
        "body": "utf8.offset(${0:...})", 
        "scope": "source.lua", 
        "prefix": "utf8.offset", 
        "description": "5.3\n\nutf8.offset (s, n [, i])"
    }, 
    "sim.customizationscriptcall_lastbeforesimulation": {
        "body": "sim.customizationscriptcall_lastbeforesimulation", 
        "scope": "source.lua", 
        "prefix": "sim.customizationscriptcall_lastbeforesimulation", 
        "description": "Constants"
    }, 
    "sim.getPage": {
        "body": "sim.getPage()", 
        "scope": "source.lua", 
        "prefix": "sim.getPage", 
        "description": "number pageIndex = sim.getPage()Retrieves the current page index (view). See also sim.setPage. None page index or -1 in case of an error"
    }, 
    "sim.pathproperty_automatic_orientation": {
        "body": "sim.pathproperty_automatic_orientation", 
        "scope": "source.lua", 
        "prefix": "sim.pathproperty_automatic_orientation", 
        "description": "Constants"
    }, 
    "sim.getArrayParameter": {
        "body": "sim.getArrayParameter(${0:parameter})", 
        "scope": "source.lua", 
        "prefix": "sim.getArrayParameter", 
        "description": "table arrayOfValues = sim.getArrayParameter(number parameter)Retrieves 3 values from an array. See the array parameter identifiers. See also sim.setArrayParameter, sim.getBoolParameter, sim.getInt32Parameter, sim.getFloatParameter and sim.getStringParameter. parameter: array parameter identifierparameterValues: a simFloat pointer  (simVoid is kept for backward compatibility). The 3 values will be copied to that locationparameter: array parameter identifierparameterValues: a simFloat pointer  (simVoid is kept for backward compatibility). The 3 values will be copied to that location -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.objintparam_visibility_layer": {
        "body": "sim.objintparam_visibility_layer", 
        "scope": "source.lua", 
        "prefix": "sim.objintparam_visibility_layer", 
        "description": "Constants"
    }, 
    "sim.getShapeColor": {
        "body": "sim.getShapeColor(${0:shapeHandle},${1:colorName},${2:colorComponent})", 
        "scope": "source.lua", 
        "prefix": "sim.getShapeColor", 
        "description": "number result,table_3 rgbData = sim.getShapeColor(number shapeHandle,string colorName,number colorComponent)Retrieves the color of a shapes. See also sim.setShapeColor.  shapeHandle: handle of the shapecolorName: name of a color. If a name is provided, a specific color component will be retrieved (e.g. if a shape is a compound shape. Can be NULL.colorComponent: a color component.rgbData (output): red, green and blue components of the color (3 values), or the transparency value (1 value)shapeHandle: handle of the shapecolorName: name of a color. If a name is provided, a specific color component will be retrieved (e.g. if a shape is a compound shape. Can be NULL.colorComponent: a color component.rgbData (output): red, green and blue components of the color (3 values), or the transparency value (1 value)shapeHandle: handle of the shapecolorName: name of a color. If a name is provided, a specific color component will be retrieved (e.g. if a shape is a compound shape. Can be NULL.colorComponent: a color component.rgbData (output): red, green and blue components of the color (3 values), or the transparency value (1 value)shapeHandle: handle of the shapecolorName: name of a color. If a name is provided, a specific color component will be retrieved (e.g. if a shape is a compound shape. Can be NULL.colorComponent: a color component.rgbData (output): red, green and blue components of the color (3 values), or the transparency value (1 value)shapeHandle: handle of the shapecolorName: name of a color. If a name is provided, a specific color component will be retrieved (e.g. if a shape is a compound shape. Can be NULL.colorComponent: a color component.rgbData (output): red, green and blue components of the color (3 values), or the transparency value (1 value) -1 if operation was not successful. 0 if the color name was not found in the shape. Otherwise, the operation was successful"
    }, 
    "simK3.getEncoder": {
        "body": "simK3.getEncoder(${0:k3Handle},${1:index})", 
        "scope": "source.lua", 
        "prefix": "simK3.getEncoder", 
        "description": "number encoderValue = simK3.getEncoder(number k3Handle,number index)"
    }, 
    "sysCall_beforeSimulation": {
        "body": "sysCall_beforeSimulation(${0:starts.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_beforeSimulation", 
        "description": "sysCall_beforeSimulation(Called just before simulation starts.)"
    }, 
    "sim.getShapeMassAndInertia": {
        "body": "sim.getShapeMassAndInertia(${0:shapeHandle},${1:transformation=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.getShapeMassAndInertia", 
        "description": "number mass,table_9 inertiaMatrix,table_3 centerOfMass = sim.getShapeMassAndInertia(number shapeHandle,table_12 transformation=nil)Retrieves mass and inertia information from a shape. See also sim.setShapeMassAndInertia, sim.getObjectMatrix, sim.buildMatrix and sim.computeMassAndInertia. shapeHandle: handle of the shape objectmass: the mass of the objectinertia matrix (output): the inertia matrix or tensor (9 values), expressed relative to the center of mass. The returned matrix is relative to the orientational frame of transformation (see further below). centerOfMass (output): the position of the center of mass, relative to the specified transformation (see next item).transformation: the transformation matrix (12 values) relative to which we want the data. Can be NULL, in which case the returned data is relative to the absolute reference frame. See here to see how matrix transformations are specified in V-REP.shapeHandle: handle of the shape objectmass: the mass of the objectinertia matrix (output): the inertia matrix or tensor (9 values), expressed relative to the center of mass. The returned matrix is relative to the orientational frame of transformation (see further below). centerOfMass (output): the position of the center of mass, relative to the specified transformation (see next item).transformation: the transformation matrix (12 values) relative to which we want the data. Can be NULL, in which case the returned data is relative to the absolute reference frame. See here to see how matrix transformations are specified in V-REP.shapeHandle: handle of the shape objectmass: the mass of the objectinertia matrix (output): the inertia matrix or tensor (9 values), expressed relative to the center of mass. The returned matrix is relative to the orientational frame of transformation (see further below). centerOfMass (output): the position of the center of mass, relative to the specified transformation (see next item).transformation: the transformation matrix (12 values) relative to which we want the data. Can be NULL, in which case the returned data is relative to the absolute reference frame. See here to see how matrix transformations are specified in V-REP.shapeHandle: handle of the shape objectmass: the mass of the objectinertia matrix (output): the inertia matrix or tensor (9 values), expressed relative to the center of mass. The returned matrix is relative to the orientational frame of transformation (see further below). centerOfMass (output): the position of the center of mass, relative to the specified transformation (see next item).transformation: the transformation matrix (12 values) relative to which we want the data. Can be NULL, in which case the returned data is relative to the absolute reference frame. See here to see how matrix transformations are specified in V-REP.shapeHandle: handle of the shape objectmass: the mass of the objectinertia matrix (output): the inertia matrix or tensor (9 values), expressed relative to the center of mass. The returned matrix is relative to the orientational frame of transformation (see further below). centerOfMass (output): the position of the center of mass, relative to the specified transformation (see next item).transformation: the transformation matrix (12 values) relative to which we want the data. Can be NULL, in which case the returned data is relative to the absolute reference frame. See here to see how matrix transformations are specified in V-REP.shapeHandle: handle of the shape objectmass: the mass of the objectinertia matrix (output): the inertia matrix or tensor (9 values), expressed relative to the center of mass. The returned matrix is relative to the orientational frame of transformation (see further below). centerOfMass (output): the position of the center of mass, relative to the specified transformation (see next item).transformation: the transformation matrix (12 values) relative to which we want the data. Can be NULL, in which case the returned data is relative to the absolute reference frame. See here to see how matrix transformations are specified in V-REP. -1 in case of an error"
    }, 
    "simUI.expandToDepth": {
        "body": "simUI.expandToDepth(${0:handle},${1:id},${2:depth},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.expandToDepth", 
        "description": "simUI.expandToDepth(number handle,number id,number depth,bool suppressEvents=true)"
    }, 
    "sim.buffer_int32": {
        "body": "sim.buffer_int32", 
        "scope": "source.lua", 
        "prefix": "sim.buffer_int32", 
        "description": "Constants"
    }, 
    "sim.getObjectSizeFactor": {
        "body": "sim.getObjectSizeFactor(${0:ObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectSizeFactor", 
        "description": "number sizeFactor = sim.getObjectSizeFactor(number ObjectHandle)Retrieves the size factor of a scene object. The size factor is different from the real object size. Use this to be able to react to scaling operations. See also sim.getObjectSizeValues. objectHandle: handle of the scene objectobjectHandle: handle of the scene object size factor or negative value in case of an error"
    }, 
    "simx.setJointTargetPosition": {
        "body": "simx.setJointTargetPosition(${0:clientId},${1:jointHandle},${2:targetPosition})", 
        "scope": "source.lua", 
        "prefix": "simx.setJointTargetPosition", 
        "description": "number returnCode= simx.setJointTargetPosition(number clientId,number jointHandle,number targetPosition)Sets the target position of a joint if the joint is in torque/force mode (also make sure that the joint's motor and position control are enabled). See also simx.setJointPosition. clientID: the client ID. refer to simx.start.jointHandle: handle of the jointtargetPosition: target position of the joint (angular or linear value depending on the joint type)operationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_oneshot or simx.opmode_streaming returnCode: a remote API function return code"
    }, 
    "simUI.addNode": {
        "body": "simUI.addNode(${0:handle},${1:id},${2:x},${3:y},${4:text},${5:inlets},${6:outlets})", 
        "scope": "source.lua", 
        "prefix": "simUI.addNode", 
        "description": "number nodeId = simUI.addNode(number handle,number id,number x,number y,string text,number inlets,number outlets)"
    }, 
    "math.math.randomseed": {
        "body": "math.math.randomseed( ${1:x} )", 
        "scope": "source.lua", 
        "prefix": "math.math.randomseed", 
        "description": "math.math.randomseed"
    }, 
    "sim.buttonproperty_slider": {
        "body": "sim.buttonproperty_slider", 
        "scope": "source.lua", 
        "prefix": "sim.buttonproperty_slider", 
        "description": "Constants"
    }, 
    "sim.bullet_global_collisionmarginfactor": {
        "body": "sim.bullet_global_collisionmarginfactor", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_global_collisionmarginfactor", 
        "description": "Constants"
    }, 
    "sim.getObjectFloatParameter": {
        "body": "sim.getObjectFloatParameter(${0:objectHandle},${1:parameterID})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectFloatParameter", 
        "description": "number result,number parameter = sim.getObjectFloatParameter(number objectHandle,number parameterID)Retrieves a floating-point parameter of a scene object or calculation object. See also sim.setObjectFloatParameter, sim.getObjectInt32Parameter and sim.getObjectStringParameter objectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: retrieved parameterobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: retrieved parameterobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: retrieved parameterobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: retrieved parameter -1 in case of an error, 0 if the parameter could not be retrieved (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful"
    }, 
    "sim.ode_body_softerp": {
        "body": "sim.ode_body_softerp", 
        "scope": "source.lua", 
        "prefix": "sim.ode_body_softerp", 
        "description": "Constants"
    }, 
    "sim.setLinkDummy": {
        "body": "sim.setLinkDummy(${0:dummyHandle},${1:linkDummyHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.setLinkDummy", 
        "description": "number result = sim.setLinkDummy(number dummyHandle,number linkDummyHandle)Defines (or breaks) a dummy-dummy link pair. Useful to create dynamic loop closure constraints on the fly (among others). See also sim.getLinkDummy. dummyHandle: handle of the first dummy in the dummy-dummy link pair.linkedDummyHandle: handle of the second dummy in the dummy-dummy link pair. Set to -1 to unlink the first dummy.dummyHandle: handle of the first dummy in the dummy-dummy link pair.linkedDummyHandle: handle of the second dummy in the dummy-dummy link pair. Set to -1 to unlink the first dummy.dummyHandle: handle of the first dummy in the dummy-dummy link pair.linkedDummyHandle: handle of the second dummy in the dummy-dummy link pair. Set to -1 to unlink the first dummy. -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.boolparam_hierarchy_visible": {
        "body": "sim.boolparam_hierarchy_visible", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_hierarchy_visible", 
        "description": "Constants"
    }, 
    "sim.mirrorfloatparam_width": {
        "body": "sim.mirrorfloatparam_width", 
        "scope": "source.lua", 
        "prefix": "sim.mirrorfloatparam_width", 
        "description": "Constants"
    }, 
    "simCHAI3D.readForce": {
        "body": "simCHAI3D.readForce(${0:deviceIndex})", 
        "scope": "source.lua", 
        "prefix": "simCHAI3D.readForce", 
        "description": "table_3 force = simCHAI3D.readForce(number deviceIndex)"
    }, 
    "simx.headeroffset_server_state": {
        "body": "simx.headeroffset_server_state", 
        "scope": "source.lua", 
        "prefix": "simx.headeroffset_server_state", 
        "description": "Constants"
    }, 
    "sim.vortex_body_angularvelocitydamping": {
        "body": "sim.vortex_body_angularvelocitydamping", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_angularvelocitydamping", 
        "description": "Constants"
    }, 
    "sim.boolparam_browser_visible": {
        "body": "sim.boolparam_browser_visible", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_browser_visible", 
        "description": "Constants"
    }, 
    "simRRS1.SELECT_DOMINANT_INTERPOLATION": {
        "body": "simRRS1.SELECT_DOMINANT_INTERPOLATION(${0:rcsHandle},${1:dominantIntType})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SELECT_DOMINANT_INTERPOLATION", 
        "description": "int status= simRRS1.SELECT_DOMINANT_INTERPOLATION(bitstring2 rcsHandle,int dominantIntType)"
    }, 
    "sim.setJointPosition": {
        "body": "sim.setJointPosition(${0:objectHandle},${1:position})", 
        "scope": "source.lua", 
        "prefix": "sim.setJointPosition", 
        "description": "number result = sim.setJointPosition(number objectHandle,number position)Sets the intrinsic position of a joint. May have no effect depending on the joint mode. This function cannot be used with spherical joints (use sim.setSphericalJointMatrix instead). See also sim.getJointPosition and sim.setJointTargetPosition. objectHandle: handle of the joint objectposition: position of the joint (angular or linear value depending on the joint type)objectHandle: handle of the joint objectposition: position of the joint (angular or linear value depending on the joint type)objectHandle: handle of the joint objectposition: position of the joint (angular or linear value depending on the joint type) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.modifyPointCloud": {
        "body": "sim.modifyPointCloud(${0:pointCloudHandle},${1:operation})", 
        "scope": "source.lua", 
        "prefix": "sim.modifyPointCloud", 
        "description": "number result = sim.modifyPointCloud(number pointCloudHandle,number operation)"
    }, 
    "sim.childscriptcall_threaded": {
        "body": "sim.childscriptcall_threaded", 
        "scope": "source.lua", 
        "prefix": "sim.childscriptcall_threaded", 
        "description": "Constants"
    }, 
    "sim.bullet_joint_stopcfm": {
        "body": "sim.bullet_joint_stopcfm", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_joint_stopcfm", 
        "description": "Constants"
    }, 
    "simx.readForceSensor": {
        "body": "simx.readForceSensor(${0:clientId},${1:forceSensorHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.readForceSensor", 
        "description": "number returnCode,number state,table_3 force,table_3 torque= simx.readForceSensor(number clientId,number forceSensorHandle)Reads the force and torque applied to a force sensor (filtered values are read), and its current state ('unbroken' or 'broken'). See also simx.breakForceSensor,  simx.getJointForce and simx.getObjectGroupData. clientID: the client ID. refer to simx.start.forceSensorHandle: handle of the force sensoroperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls) returnCode: a remote API function return codestate: the state of the force sensor:forceVector: the force vectortorqueVector: the torque vector"
    }, 
    "sim.particle_painttag": {
        "body": "sim.particle_painttag", 
        "scope": "source.lua", 
        "prefix": "sim.particle_painttag", 
        "description": "Constants"
    }, 
    "sim.object_proximitysensor_type": {
        "body": "sim.object_proximitysensor_type", 
        "scope": "source.lua", 
        "prefix": "sim.object_proximitysensor_type", 
        "description": "Constants"
    }, 
    "sim.displayattribute_colorcodedtriangles": {
        "body": "sim.displayattribute_colorcodedtriangles", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_colorcodedtriangles", 
        "description": "Constants"
    }, 
    "sim.removeCollection": {
        "body": "sim.removeCollection(${0:collectionHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.removeCollection", 
        "description": "number result = sim.removeCollection(number collectionHandle)Removes a collection from the scene, including the objects it contains. If you just want to remove the collection, but not the objects it contains, call sim.emptyCollection beforehand. See also sim.createCollection and sim.addObjectToCollection.  collectionHandle: handle of the collection to remove. sim_handle_all removes all collections from the scenecollectionHandle: handle of the collection to remove. sim_handle_all removes all collections from the scene -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simOMPL.setStateValidityCheckingResolution": {
        "body": "simOMPL.setStateValidityCheckingResolution(${0:taskHandle},${1:resolution})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.setStateValidityCheckingResolution", 
        "description": "number result = simOMPL.setStateValidityCheckingResolution(number taskHandle,number resolution)"
    }, 
    "simB0.cleanup": {
        "body": "simB0.cleanup(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "simB0.cleanup", 
        "description": "simB0.cleanup(string handle)"
    }, 
    "sim.vortex_joint_a2frictionloss": {
        "body": "sim.vortex_joint_a2frictionloss", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a2frictionloss", 
        "description": "Constants"
    }, 
    "sim.msgbox_return_yes": {
        "body": "sim.msgbox_return_yes", 
        "scope": "source.lua", 
        "prefix": "sim.msgbox_return_yes", 
        "description": "Constants"
    }, 
    "simB0.createServiceServer": {
        "body": "simB0.createServiceServer(${0:nodeHandle},${1:service},${2:callback=''})", 
        "scope": "source.lua", 
        "prefix": "simB0.createServiceServer", 
        "description": "string handle simB0.createServiceServer(string nodeHandle,string service,string callback='')"
    }, 
    "debug.upvalueid": {
        "body": "debug.upvalueid( ${1:f}, ${2:n})", 
        "scope": "source.lua", 
        "prefix": "debug.upvalueid", 
        "description": "5.2,5.3\n\ndebug.upvalueid (f, n)"
    }, 
    "sim.visionintparam_render_mode": {
        "body": "sim.visionintparam_render_mode", 
        "scope": "source.lua", 
        "prefix": "sim.visionintparam_render_mode", 
        "description": "Constants"
    }, 
    "sim.newton_body_angulardrag": {
        "body": "sim.newton_body_angulardrag", 
        "scope": "source.lua", 
        "prefix": "sim.newton_body_angulardrag", 
        "description": "Constants"
    }, 
    "math.ceil": {
        "body": "math.ceil( ${1:x} )", 
        "scope": "source.lua", 
        "prefix": "math.ceil", 
        "description": "5.1,5.2,5.3\n\nmath.ceil"
    }, 
    "simx.getObjectParent": {
        "body": "simx.getObjectParent(${0:clientId},${1:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.getObjectParent", 
        "description": "number returnCode,number parentObjectHandle= simx.getObjectParent(number clientId,number objectHandle)Retrieves the handle of an object's parent object. See also simx.getObjectChild and simx.getObjectGroupData. clientID: the client ID. refer to simx.start.objectHandle: handle of the objectoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return codeparentObjectHandle: the handle of the parent object. If the value is -1, the object has no parent"
    }, 
    "sim.handleflag_resettorque": {
        "body": "sim.handleflag_resettorque", 
        "scope": "source.lua", 
        "prefix": "sim.handleflag_resettorque", 
        "description": "Constants"
    }, 
    "sim.objfloatparam_objbbox_min_x": {
        "body": "sim.objfloatparam_objbbox_min_x", 
        "scope": "source.lua", 
        "prefix": "sim.objfloatparam_objbbox_min_x", 
        "description": "Constants"
    }, 
    "sim.stringparam_application_path": {
        "body": "sim.stringparam_application_path", 
        "scope": "source.lua", 
        "prefix": "sim.stringparam_application_path", 
        "description": "Constants"
    }, 
    "sim.getCollectionName": {
        "body": "sim.getCollectionName(${0:collectionHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getCollectionName", 
        "description": "string collectionName = sim.getCollectionName(number collectionHandle)Retrieves the name of a collection based on its handle. See also sim.setCollectionName. collectionHandle: handle of the collectioncollectionHandle: handle of the collection pointer to the name of the collection or NULL if an error occurred. The user is in charge of destroying the returned buffer with simReleaseBuffer"
    }, 
    "getfenv": {
        "body": "getfenv(${0:...})", 
        "scope": "source.lua", 
        "prefix": "getfenv", 
        "description": "5.1\n\ngetfenv ([f])"
    }, 
    "sim.intparam_motionplanning_seed": {
        "body": "sim.intparam_motionplanning_seed", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_motionplanning_seed", 
        "description": "Constants"
    }, 
    "sim.getCustomizationScriptAssociatedWithObject": {
        "body": "sim.getCustomizationScriptAssociatedWithObject(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getCustomizationScriptAssociatedWithObject", 
        "description": "number scriptHandle = sim.getCustomizationScriptAssociatedWithObject(number objectHandle)Retrieves a customization script's handle based on its associated object. See also sim.getObjectAssociatedWithScript and sim.getScriptAssociatedWithObject. objectHandle: handle of the object that might have a customization script associatedobjectHandle: handle of the object that might have a customization script associated handle of the customization script associated with the object, or -1 if the operation was not successful or the object doesn't have an associated script"
    }, 
    "sim.unpackUInt32Table": {
        "body": "sim.unpackUInt32Table(${0:data},${1:startUint32Index=0},${2:uint32Count=0},${3:additionalByteOffset=0})", 
        "scope": "source.lua", 
        "prefix": "sim.unpackUInt32Table", 
        "description": "table uint32Numbers = sim.unpackUInt32Table(string data,number startUint32Index=0,number uint32Count=0,number additionalByteOffset=0)Unpacks a string (or part of it) into a table of uint32 numbers. See also sim.packUInt32Table and the other packing/unpacking functions. - -"
    }, 
    "sim.objfloatparam_objbbox_min_z": {
        "body": "sim.objfloatparam_objbbox_min_z", 
        "scope": "source.lua", 
        "prefix": "sim.objfloatparam_objbbox_min_z", 
        "description": "Constants"
    }, 
    "sim.cameraintparam_rendering_attributes": {
        "body": "sim.cameraintparam_rendering_attributes", 
        "scope": "source.lua", 
        "prefix": "sim.cameraintparam_rendering_attributes", 
        "description": "Constants"
    }, 
    "sim.vortex_body_seclinearaxisslip": {
        "body": "sim.vortex_body_seclinearaxisslip", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_seclinearaxisslip", 
        "description": "Constants"
    }, 
    "sim.computeJacobian": {
        "body": "sim.computeJacobian(${0:ikGroupHandle},${1:options})", 
        "scope": "source.lua", 
        "prefix": "sim.computeJacobian", 
        "description": "number result = sim.computeJacobian(number ikGroupHandle,number options)Computes the Jacobian of a registered IK group. The result can then be read via sim.getIkGroupMatrix. See also sim.handleIkGroup and sim.checkIkGroup. ikGroupHandle: handle of the IK group. See also simGetIkGroupHandle.options: bit-coded:bit0 set (1): the joint IK weights are taken into account.reserved: reserved for future extensions. Set to NULL.ikGroupHandle: handle of the IK group. See also simGetIkGroupHandle.options: bit-coded:bit0 set (1): the joint IK weights are taken into account.reserved: reserved for future extensions. Set to NULL.ikGroupHandle: handle of the IK group. See also simGetIkGroupHandle.options: bit-coded:bit0 set (1): the joint IK weights are taken into account.reserved: reserved for future extensions. Set to NULL.ikGroupHandle: handle of the IK group. See also simGetIkGroupHandle.options: bit-coded:bit0 set (1): the joint IK weights are taken into account.reserved: reserved for future extensions. Set to NULL. -1 if operation failed"
    }, 
    "sim.objectspecialproperty_renderable": {
        "body": "sim.objectspecialproperty_renderable", 
        "scope": "source.lua", 
        "prefix": "sim.objectspecialproperty_renderable", 
        "description": "Constants"
    }, 
    "simUI.getWidgetVisibility": {
        "body": "simUI.getWidgetVisibility(${0:handle},${1:id})", 
        "scope": "source.lua", 
        "prefix": "simUI.getWidgetVisibility", 
        "description": "bool visibility = simUI.getWidgetVisibility(number handle,number id)"
    }, 
    "sim.vortex_body_materialuniqueid": {
        "body": "sim.vortex_body_materialuniqueid", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_materialuniqueid", 
        "description": "Constants"
    }, 
    "sim.bullet_global_constraintsolvingiterations": {
        "body": "sim.bullet_global_constraintsolvingiterations", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_global_constraintsolvingiterations", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_p1frictionloss": {
        "body": "sim.vortex_joint_p1frictionloss", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p1frictionloss", 
        "description": "Constants"
    }, 
    "sim.vortex_body_seclinearaxisslide": {
        "body": "sim.vortex_body_seclinearaxisslide", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_seclinearaxisslide", 
        "description": "Constants"
    }, 
    "sim.setJointTargetVelocity": {
        "body": "sim.setJointTargetVelocity(${0:objectHandle},${1:targetVelocity})", 
        "scope": "source.lua", 
        "prefix": "sim.setJointTargetVelocity", 
        "description": "number result = sim.setJointTargetVelocity(number objectHandle,number targetVelocity)Sets the intrinsic target velocity of a non-spherical joint. This command makes only sense when the joint mode is torque/force mode: the dynamics functionality and the joint motor have to be enabled (position control should however be disabled). See also sim.getJointTargetVelocity. objectHandle: handle of the joint objecttargetVelocity: target velocity of the joint (linear or angular velocity depending on the joint-type). objectHandle: handle of the joint objecttargetVelocity: target velocity of the joint (linear or angular velocity depending on the joint-type). objectHandle: handle of the joint objecttargetVelocity: target velocity of the joint (linear or angular velocity depending on the joint-type).  -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.scaleObject": {
        "body": "sim.scaleObject(${0:objectHandle},${1:xScale},${2:yScale},${3:zScale},${4:options=0})", 
        "scope": "source.lua", 
        "prefix": "sim.scaleObject", 
        "description": "number result = sim.scaleObject(number objectHandle,number xScale,number yScale,number zScale,number options=0)Scales specified objects in a non-isometric fashion, if possible (i.e. some objects can be fully isometrically scaled, others have 2 or all 3 axes linked). See also sim.scaleObjects for isometric scaling. objectHandle: the handle of the object to scale.xScale/yScale/zScale: the scaling factors along the object's x, y and z-axis.options: reserved for future extension. Keep at 0.objectHandle: the handle of the object to scale.xScale/yScale/zScale: the scaling factors along the object's x, y and z-axis.options: reserved for future extension. Keep at 0.objectHandle: the handle of the object to scale.xScale/yScale/zScale: the scaling factors along the object's x, y and z-axis.options: reserved for future extension. Keep at 0. -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simB0.publish": {
        "body": "simB0.publish(${0:handle},${1:payload})", 
        "scope": "source.lua", 
        "prefix": "simB0.publish", 
        "description": "simB0.publish(string handle,string payload)"
    }, 
    "sim.filtercomponent_resize": {
        "body": "sim.filtercomponent_resize", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_resize", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_p1frictionmaxforce": {
        "body": "sim.vortex_joint_p1frictionmaxforce", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p1frictionmaxforce", 
        "description": "Constants"
    }, 
    "simUI.setPlotLabels": {
        "body": "simUI.setPlotLabels(${0:handle},${1:id},${2:x},${3:y})", 
        "scope": "source.lua", 
        "prefix": "simUI.setPlotLabels", 
        "description": "simUI.setPlotLabels(number handle,number id,string x,string y)"
    }, 
    "simUI.setRowCount": {
        "body": "simUI.setRowCount(${0:handle},${1:id},${2:count},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setRowCount", 
        "description": "simUI.setRowCount(number handle,number id,number count,bool suppressEvents=true)"
    }, 
    "sim.camerafloatparam_perspective_angle": {
        "body": "sim.camerafloatparam_perspective_angle", 
        "scope": "source.lua", 
        "prefix": "sim.camerafloatparam_perspective_angle", 
        "description": "Constants"
    }, 
    "sim.objintparam_child_role": {
        "body": "sim.objintparam_child_role", 
        "scope": "source.lua", 
        "prefix": "sim.objintparam_child_role", 
        "description": "Constants"
    }, 
    "error": {
        "body": "error(${0:...})", 
        "scope": "source.lua", 
        "prefix": "error", 
        "description": "5.1,5.2,5.3\n\nerror (message [, level])"
    }, 
    "fun": {
        "body": "function ${1:function_name}( ${2:...} )\n\t${0:-- body}\nend", 
        "scope": "source.lua", 
        "prefix": "fun", 
        "description": "function"
    }, 
    "simUI.saveState": {
        "body": "simUI.saveState(${0:handle},${1:id})", 
        "scope": "source.lua", 
        "prefix": "simUI.saveState", 
        "description": "string state = simUI.saveState(number handle,number id)"
    }, 
    "sim.intparam_server_port_range": {
        "body": "sim.intparam_server_port_range", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_server_port_range", 
        "description": "Constants"
    }, 
    "sysCall_addOnScriptRun": {
        "body": "sysCall_addOnScriptRun(${0:running.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_addOnScriptRun", 
        "description": "sysCall_addOnScriptRun(Called when the add-on script is running.)"
    }, 
    "sysCall_customCallback2": {
        "body": "sysCall_customCallback2(${0:script.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_customCallback2", 
        "description": "sysCall_customCallback2(Can be called by a customized main script.)"
    }, 
    "sim.colorcomponent_specular": {
        "body": "sim.colorcomponent_specular", 
        "scope": "source.lua", 
        "prefix": "sim.colorcomponent_specular", 
        "description": "Constants"
    }, 
    "sim.objectproperty_selectable": {
        "body": "sim.objectproperty_selectable", 
        "scope": "source.lua", 
        "prefix": "sim.objectproperty_selectable", 
        "description": "Constants"
    }, 
    "simRRS1.selectRcsServer": {
        "body": "simRRS1.selectRcsServer()", 
        "scope": "source.lua", 
        "prefix": "simRRS1.selectRcsServer", 
        "description": "boolean result= simRRS1.selectRcsServer()"
    }, 
    "sim.filtercomponent_intensityscale": {
        "body": "sim.filtercomponent_intensityscale", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_intensityscale", 
        "description": "Constants"
    }, 
    "sim.object_camera_type": {
        "body": "sim.object_camera_type", 
        "scope": "source.lua", 
        "prefix": "sim.object_camera_type", 
        "description": "Constants"
    }, 
    "sim.navigation_clickselection": {
        "body": "sim.navigation_clickselection", 
        "scope": "source.lua", 
        "prefix": "sim.navigation_clickselection", 
        "description": "Constants"
    }, 
    "io.flush": {
        "body": "io.flush(${0:...})", 
        "scope": "source.lua", 
        "prefix": "io.flush", 
        "description": "5.1,5.2,5.3\n\nio.flush ()"
    }, 
    "file:close": {
        "body": "file:close(${0:...})", 
        "scope": "source.lua", 
        "prefix": "file:close", 
        "description": "5.1,5.2,5.3\n\nfile:close ()"
    }, 
    "sim.vortex_body_compliance": {
        "body": "sim.vortex_body_compliance", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_compliance", 
        "description": "Constants"
    }, 
    "sim.stringparam_app_arg5": {
        "body": "sim.stringparam_app_arg5", 
        "scope": "source.lua", 
        "prefix": "sim.stringparam_app_arg5", 
        "description": "Constants"
    }, 
    "sim.buttonproperty_nobackgroundcolor": {
        "body": "sim.buttonproperty_nobackgroundcolor", 
        "scope": "source.lua", 
        "prefix": "sim.buttonproperty_nobackgroundcolor", 
        "description": "Constants"
    }, 
    "sim.unpackDoubleTable": {
        "body": "sim.unpackDoubleTable(${0:data},${1:startDoubleIndex=0},${2:doubleCount=0},${3:additionalByteOffset=0})", 
        "scope": "source.lua", 
        "prefix": "sim.unpackDoubleTable", 
        "description": "table doubleNumbers = sim.unpackDoubleTable(string data,number startDoubleIndex=0,number doubleCount=0,number additionalByteOffset=0)Unpacks a string (or part of it) into a table of double floating-point numbers. See also sim.packDoubleTable and the other packing/unpacking functions. - -"
    }, 
    "simMTB.disconnectInput": {
        "body": "simMTB.disconnectInput(${0:inputMtbServerHandle})", 
        "scope": "source.lua", 
        "prefix": "simMTB.disconnectInput", 
        "description": "boolean result= simMTB.disconnectInput(number inputMtbServerHandle)"
    }, 
    "sim.buffer_uint32": {
        "body": "sim.buffer_uint32", 
        "scope": "source.lua", 
        "prefix": "sim.buffer_uint32", 
        "description": "Constants"
    }, 
    "sim.serialSend": {
        "body": "sim.serialSend(${0:portHandle},${1:data})", 
        "scope": "source.lua", 
        "prefix": "sim.serialSend", 
        "description": "number charsSent = sim.serialSend(number portHandle,string data)Writes data to a previously opened serial port (RS-232). See also sim.serialRead. portHandle: the handle returned by the simSerialOpen functiondata: a pointer to the data that should be sentdataLength: length of the data to be sentportHandle: the handle returned by the simSerialOpen functiondata: a pointer to the data that should be sentdataLength: length of the data to be sentportHandle: the handle returned by the simSerialOpen functiondata: a pointer to the data that should be sentdataLength: length of the data to be sentportHandle: the handle returned by the simSerialOpen functiondata: a pointer to the data that should be sentdataLength: length of the data to be sent -1 if operation was not successful, otherwise the effective data length that was written"
    }, 
    "simK3.getLineSensor": {
        "body": "simK3.getLineSensor(${0:k3Handle},${1:index})", 
        "scope": "source.lua", 
        "prefix": "simK3.getLineSensor", 
        "description": "number intensity = simK3.getLineSensor(number k3Handle,number index)"
    }, 
    "if": {
        "body": "if ${1:condition} then\n\t${0:-- body}\nend", 
        "scope": "source.lua", 
        "prefix": "if", 
        "description": "if"
    }, 
    "sim.objectproperty_cannotdelete": {
        "body": "sim.objectproperty_cannotdelete", 
        "scope": "source.lua", 
        "prefix": "sim.objectproperty_cannotdelete", 
        "description": "Constants"
    }, 
    "sim.displayattribute_pickpass": {
        "body": "sim.displayattribute_pickpass", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_pickpass", 
        "description": "Constants"
    }, 
    "sim.physics_ode": {
        "body": "sim.physics_ode", 
        "scope": "source.lua", 
        "prefix": "sim.physics_ode", 
        "description": "Constants"
    }, 
    "simx.setFloatSignal": {
        "body": "simx.setFloatSignal(${0:clientId},${1:signalName},${2:signalValue})", 
        "scope": "source.lua", 
        "prefix": "simx.setFloatSignal", 
        "description": "number returnCode= simx.setFloatSignal(number clientId,string signalName,number signalValue)Sets the value of a float signal. If that signal is not yet present, it is added. See also simx.getFloatSignal, simx.clearFloatSignal, simx.setIntegerSignal and simx.setStringSignal. clientID: the client ID. refer to simx.start.signalName: name of the signalsignalValue: value of the signaloperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "simUI.curve_style.scatter": {
        "body": "simUI.curve_style.scatter", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_style.scatter", 
        "description": "Constants"
    }, 
    "simOMPL.Algorithm.RRTConnect": {
        "body": "simOMPL.Algorithm.RRTConnect", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.RRTConnect", 
        "description": "Constants"
    }, 
    "sim.shape_multishape_subtype": {
        "body": "sim.shape_multishape_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.shape_multishape_subtype", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_originaldepth": {
        "body": "sim.filtercomponent_originaldepth", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_originaldepth", 
        "description": "Constants"
    }, 
    "sim.removeVoxelsFromOctree": {
        "body": "sim.removeVoxelsFromOctree(${0:octreeHandle},${1:options},${2:points})", 
        "scope": "source.lua", 
        "prefix": "sim.removeVoxelsFromOctree", 
        "description": "number totalVoxelCnt = sim.removeVoxelsFromOctree(number octreeHandle,number options,table points)Removes voxels from an octree. See also sim.insertVoxelsIntoOctree and the other octree related functions. octreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the voxel positions specified as X/Y/Z coordinates. Set to NULL to remove all voxelsptCnt: the number of point coordinates contained in ptsreserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the voxel positions specified as X/Y/Z coordinates. Set to NULL to remove all voxelsptCnt: the number of point coordinates contained in ptsreserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the voxel positions specified as X/Y/Z coordinates. Set to NULL to remove all voxelsptCnt: the number of point coordinates contained in ptsreserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the voxel positions specified as X/Y/Z coordinates. Set to NULL to remove all voxelsptCnt: the number of point coordinates contained in ptsreserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the voxel positions specified as X/Y/Z coordinates. Set to NULL to remove all voxelsptCnt: the number of point coordinates contained in ptsreserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the octree reference frame, otherwise they are relative to the world reference framepts: a pointer to the voxel positions specified as X/Y/Z coordinates. Set to NULL to remove all voxelsptCnt: the number of point coordinates contained in ptsreserved: reserved for future extensions. Set to NULL -1 if operation was not successful, otherwise the total number of voxels in the octree"
    }, 
    "sim.buildMatrix": {
        "body": "sim.buildMatrix(${0:position},${1:eulerAngles})", 
        "scope": "source.lua", 
        "prefix": "sim.buildMatrix", 
        "description": "table_12 matrix = sim.buildMatrix(table_3 position,table_3 eulerAngles)Builds a transformation matrix based on a position vector and Euler angles. See also the other matrix/transformation functions. position: pointer to 3 simFloat values representing the position componenteulerAngles: pointer to 3 simFloat values representing the angular componentmatrix: pointer to 12 simFloat values representing the transformation matrixThe x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])The position component of the matrix is (matrix[3],matrix[7],matrix[11])position: pointer to 3 simFloat values representing the position componenteulerAngles: pointer to 3 simFloat values representing the angular componentmatrix: pointer to 12 simFloat values representing the transformation matrixThe x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])The position component of the matrix is (matrix[3],matrix[7],matrix[11])position: pointer to 3 simFloat values representing the position componenteulerAngles: pointer to 3 simFloat values representing the angular componentmatrix: pointer to 12 simFloat values representing the transformation matrixThe x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])The position component of the matrix is (matrix[3],matrix[7],matrix[11])position: pointer to 3 simFloat values representing the position componenteulerAngles: pointer to 3 simFloat values representing the angular componentmatrix: pointer to 12 simFloat values representing the transformation matrixThe x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])The position component of the matrix is (matrix[3],matrix[7],matrix[11])position: pointer to 3 simFloat values representing the position componenteulerAngles: pointer to 3 simFloat values representing the angular componentmatrix: pointer to 12 simFloat values representing the transformation matrixThe x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])The position component of the matrix is (matrix[3],matrix[7],matrix[11])position: pointer to 3 simFloat values representing the position componenteulerAngles: pointer to 3 simFloat values representing the angular componentmatrix: pointer to 12 simFloat values representing the transformation matrixThe x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])The position component of the matrix is (matrix[3],matrix[7],matrix[11])position: pointer to 3 simFloat values representing the position componenteulerAngles: pointer to 3 simFloat values representing the angular componentmatrix: pointer to 12 simFloat values representing the transformation matrixThe x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])The position component of the matrix is (matrix[3],matrix[7],matrix[11]) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simx.readProximitySensor": {
        "body": "simx.readProximitySensor(${0:clientId},${1:proximitySensorHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.readProximitySensor", 
        "description": "number returnCode,boolean detectionState,table_3 detectedPoint,number objectHandle,table_3 normalVector= simx.readProximitySensor(number clientId,number proximitySensorHandle)Reads the state of a proximity sensor. This function doesn't perform detection, it merely reads the result from a previous call to sim.handleProximitySensor (sim.handleProximitySensor is called in the default main script). See also simx.getObjectGroupData. clientID: the client ID. refer to simx.start.sensorHandle: handle of the proximity sensoroperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls) returnCode: a remote API function return codedetectionState: the detection statedetectedPoint: the detected point coordinates (relative to the sensor reference frame)detectedObjectHandle: the handle of the detected objectdetectedSurfaceNormalVector: the normal vector (normalized) of the detected surface. Relative to the sensor reference frame"
    }, 
    "string.format": {
        "body": "string.format( \"${1:formatstring}\",${2:...} )", 
        "scope": "source.lua", 
        "prefix": "string.format", 
        "description": "5.1,5.2,5.3\n\nstring.format"
    }, 
    "sim.transformBuffer": {
        "body": "sim.transformBuffer(${0:inBuffer},${1:inFormat},${2:multiplier},${3:offset},${4:outFormat})", 
        "scope": "source.lua", 
        "prefix": "sim.transformBuffer", 
        "description": "string outBuffer = sim.transformBuffer(string inBuffer,number inFormat,number multiplier,number offset,number outFormat)Modified a buffer than contains packed data. See also the data packing/unpacking functions. - -"
    }, 
    "simROS.imageTransportShutdownPublisher": {
        "body": "simROS.imageTransportShutdownPublisher(${0:publisherHandle})", 
        "scope": "source.lua", 
        "prefix": "simROS.imageTransportShutdownPublisher", 
        "description": "simROS.imageTransportShutdownPublisher(number publisherHandle)"
    }, 
    "sim.getObjectName": {
        "body": "sim.getObjectName(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectName", 
        "description": "string objectName = sim.getObjectName(number objectHandle)Retrieves the name of an object based on its handle. See also sim.setObjectName. objectHandle: handle of the object. By adding sim.handleflag_altname to the object handle, the object alternative name can be retrieved.objectHandle: handle of the object. By adding sim.handleflag_altname to the object handle, the object alternative name can be retrieved. Name (or alternative name) of the object if operation was successful, NULL otherwise. The user is in charge of destroying the returned buffer with simReleaseBuffer"
    }, 
    "simVision.destroyVelodyneHDL64E": {
        "body": "simVision.destroyVelodyneHDL64E()", 
        "scope": "source.lua", 
        "prefix": "simVision.destroyVelodyneHDL64E", 
        "description": "number result= simVision.destroyVelodyneHDL64E()"
    }, 
    "simx.getObjectSelection": {
        "body": "simx.getObjectSelection(${0:clientId})", 
        "scope": "source.lua", 
        "prefix": "simx.getObjectSelection", 
        "description": "number returnCode,table objectHandles= simx.getObjectSelection(number clientId)Retrieves all selected object's handles. See also simx.setObjectSelection. clientID: the client ID. refer to simx.start.operationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls), or simx.opmode_blocking depending on the intent. returnCode: a remote API function return codeobjectHandles: the handles of selected objects."
    }, 
    "sim.vortex_global_constraintlineardamping": {
        "body": "sim.vortex_global_constraintlineardamping", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_global_constraintlineardamping", 
        "description": "Constants"
    }, 
    "sim.simulation_advancing_lastbeforepause": {
        "body": "sim.simulation_advancing_lastbeforepause", 
        "scope": "source.lua", 
        "prefix": "sim.simulation_advancing_lastbeforepause", 
        "description": "Constants"
    }, 
    "sim.setEngineFloatParameter": {
        "body": "sim.setEngineFloatParameter(${0:paramId},${1:objectHandle},${2:floatParam})", 
        "scope": "source.lua", 
        "prefix": "sim.setEngineFloatParameter", 
        "description": "number result = sim.setEngineFloatParameter(number paramId,number objectHandle,number floatParam)Sets a float-type physics engine property. You might have to call sim.resetDynamicObject for changes to take effect. See also the other engine properties setter and getter API functions. paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to set a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to set a global engine parameter. If NULL, then the objectHandle argument will be evaluated.val: the new property values.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to set a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to set a global engine parameter. If NULL, then the objectHandle argument will be evaluated.val: the new property values.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to set a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to set a global engine parameter. If NULL, then the objectHandle argument will be evaluated.val: the new property values.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to set a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to set a global engine parameter. If NULL, then the objectHandle argument will be evaluated.val: the new property values. 1 in case of success. This function call doesn't generate any error message."
    }, 
    "sim.buttonproperty_transparent": {
        "body": "sim.buttonproperty_transparent", 
        "scope": "source.lua", 
        "prefix": "sim.buttonproperty_transparent", 
        "description": "Constants"
    }, 
    "simROS.shutdownServiceServer": {
        "body": "simROS.shutdownServiceServer(${0:serviceServerHandle})", 
        "scope": "source.lua", 
        "prefix": "simROS.shutdownServiceServer", 
        "description": "simROS.shutdownServiceServer(number serviceServerHandle)"
    }, 
    "sim.navigation_shiftselection": {
        "body": "sim.navigation_shiftselection", 
        "scope": "source.lua", 
        "prefix": "sim.navigation_shiftselection", 
        "description": "Constants"
    }, 
    "sim.modelproperty_not_renderable": {
        "body": "sim.modelproperty_not_renderable", 
        "scope": "source.lua", 
        "prefix": "sim.modelproperty_not_renderable", 
        "description": "Constants"
    }, 
    "debug.gethook": {
        "body": "debug.gethook( ${1:[thread]} )", 
        "scope": "source.lua", 
        "prefix": "debug.gethook", 
        "description": "5.1,5.2,5.3\n\ndebug.gethook ([thread])"
    }, 
    "simx.opmode_discontinue": {
        "body": "simx.opmode_discontinue", 
        "scope": "source.lua", 
        "prefix": "simx.opmode_discontinue", 
        "description": "Constants"
    }, 
    "math.maxinteger": {
        "body": "math.maxinteger(${0:...})", 
        "scope": "source.lua", 
        "prefix": "math.maxinteger", 
        "description": "5.3\n\nmath.maxinteger"
    }, 
    "sim.handle_all": {
        "body": "sim.handle_all", 
        "scope": "source.lua", 
        "prefix": "sim.handle_all", 
        "description": "Constants"
    }, 
    "math.tanh": {
        "body": "math.tanh(${0:...})", 
        "scope": "source.lua", 
        "prefix": "math.tanh", 
        "description": "5.1,5.2\n\nmath.tanh (x)"
    }, 
    "sim.vortex_joint_a0frictionloss": {
        "body": "sim.vortex_joint_a0frictionloss", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a0frictionloss", 
        "description": "Constants"
    }, 
    "sim.colorcomponent_auxiliary": {
        "body": "sim.colorcomponent_auxiliary", 
        "scope": "source.lua", 
        "prefix": "sim.colorcomponent_auxiliary", 
        "description": "Constants"
    }, 
    "sim.exportIk": {
        "body": "sim.exportIk(${0:pathAndFilename})", 
        "scope": "source.lua", 
        "prefix": "sim.exportIk", 
        "description": "number result = sim.exportIk(string pathAndFilename)Exports the IK content of a scene. The generated file can be used with the external IK, to do IK computations in an external application. pathAndFilename: the location and the name of the file to create.reserved1: reserved argument, keep at 0.reserved2: reserved argument, keep at NULL.pathAndFilename: the location and the name of the file to create.reserved1: reserved argument, keep at 0.reserved2: reserved argument, keep at NULL.pathAndFilename: the location and the name of the file to create.reserved1: reserved argument, keep at 0.reserved2: reserved argument, keep at NULL. -1 or 0 if operation was not successful."
    }, 
    "simOMPL.Algorithm.pSBL": {
        "body": "simOMPL.Algorithm.pSBL", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.pSBL", 
        "description": "Constants"
    }, 
    "simROS.deleteParam": {
        "body": "simROS.deleteParam(${0:name})", 
        "scope": "source.lua", 
        "prefix": "simROS.deleteParam", 
        "description": "simROS.deleteParam(string name)"
    }, 
    "sim.boolparam_use_glfinish_cmd": {
        "body": "sim.boolparam_use_glfinish_cmd", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_use_glfinish_cmd", 
        "description": "Constants"
    }, 
    "sim.vortex_global_multithreading": {
        "body": "sim.vortex_global_multithreading", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_global_multithreading", 
        "description": "Constants"
    }, 
    "sim.simulation_paused": {
        "body": "sim.simulation_paused", 
        "scope": "source.lua", 
        "prefix": "sim.simulation_paused", 
        "description": "Constants"
    }, 
    "simUI.curve_style.line": {
        "body": "simUI.curve_style.line", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_style.line", 
        "description": "Constants"
    }, 
    "simx.return_ok": {
        "body": "simx.return_ok", 
        "scope": "source.lua", 
        "prefix": "simx.return_ok", 
        "description": "Constants"
    }, 
    "simOMPL.Algorithm.BITstar": {
        "body": "simOMPL.Algorithm.BITstar", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.BITstar", 
        "description": "Constants"
    }, 
    "sim.vortex_global_internalscalingfactor": {
        "body": "sim.vortex_global_internalscalingfactor", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_global_internalscalingfactor", 
        "description": "Constants"
    }, 
    "simx.return_split_progress_flag": {
        "body": "simx.return_split_progress_flag", 
        "scope": "source.lua", 
        "prefix": "simx.return_split_progress_flag", 
        "description": "Constants"
    }, 
    "simUI.getNodeOutletCount": {
        "body": "simUI.getNodeOutletCount(${0:handle},${1:id},${2:nodeId})", 
        "scope": "source.lua", 
        "prefix": "simUI.getNodeOutletCount", 
        "description": "number count = simUI.getNodeOutletCount(number handle,number id,number nodeId)"
    }, 
    "sim.setObjectParent": {
        "body": "sim.setObjectParent(${0:objectHandle},${1:parentObjectHandle},${2:keepInPlace})", 
        "scope": "source.lua", 
        "prefix": "sim.setObjectParent", 
        "description": "number result = sim.setObjectParent(number objectHandle,number parentObjectHandle,boolean keepInPlace)Sets an object's parent object. See also sim.getObjectParent. objectHandle: handle of the object that will become child of the parent object. Can be combined with sim_handleflag_assembly (simply add sim_handleflag_assembly to objectHandle), if the two objects can be assembled via a predefined assembly transformation (refer to the assembling option in the object common properties). In that case, parentObjectHandle can't be -1, and keepInPlace should be set to false.parentObjectHandle: handle of the object that will become parent, or -1 if the object should become parentless.keepInPlace: indicates whether the object's absolute position and orientation should stay sameobjectHandle: handle of the object that will become child of the parent object. Can be combined with sim_handleflag_assembly (simply add sim_handleflag_assembly to objectHandle), if the two objects can be assembled via a predefined assembly transformation (refer to the assembling option in the object common properties). In that case, parentObjectHandle can't be -1, and keepInPlace should be set to false.parentObjectHandle: handle of the object that will become parent, or -1 if the object should become parentless.keepInPlace: indicates whether the object's absolute position and orientation should stay sameobjectHandle: handle of the object that will become child of the parent object. Can be combined with sim_handleflag_assembly (simply add sim_handleflag_assembly to objectHandle), if the two objects can be assembled via a predefined assembly transformation (refer to the assembling option in the object common properties). In that case, parentObjectHandle can't be -1, and keepInPlace should be set to false.parentObjectHandle: handle of the object that will become parent, or -1 if the object should become parentless.keepInPlace: indicates whether the object's absolute position and orientation should stay sameobjectHandle: handle of the object that will become child of the parent object. Can be combined with sim_handleflag_assembly (simply add sim_handleflag_assembly to objectHandle), if the two objects can be assembled via a predefined assembly transformation (refer to the assembling option in the object common properties). In that case, parentObjectHandle can't be -1, and keepInPlace should be set to false.parentObjectHandle: handle of the object that will become parent, or -1 if the object should become parentless.keepInPlace: indicates whether the object's absolute position and orientation should stay same -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "rawequal": {
        "body": "rawequal(${0:...})", 
        "scope": "source.lua", 
        "prefix": "rawequal", 
        "description": "5.1,5.2,5.3\n\nrawequal (v1, v2)"
    }, 
    "sim.filtercomponent_circularcut": {
        "body": "sim.filtercomponent_circularcut", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_circularcut", 
        "description": "Constants"
    }, 
    "sim.vortex_body_bitcoded": {
        "body": "sim.vortex_body_bitcoded", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_bitcoded", 
        "description": "Constants"
    }, 
    "sim.displayattribute_trianglewireframe": {
        "body": "sim.displayattribute_trianglewireframe", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_trianglewireframe", 
        "description": "Constants"
    }, 
    "simRRS1.SET_OVERRIDE_POSITION": {
        "body": "simRRS1.SET_OVERRIDE_POSITION(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_OVERRIDE_POSITION", 
        "description": "int status= simRRS1.SET_OVERRIDE_POSITION(bitstring2 rcsHandle)"
    }, 
    "simVision.handleAnaglyphStereo": {
        "body": "simVision.handleAnaglyphStereo(${0:passiveVisionSensorHandle},${1:activeVisionSensorHandles})", 
        "scope": "source.lua", 
        "prefix": "simVision.handleAnaglyphStereo", 
        "description": "number result= simVision.handleAnaglyphStereo(number passiveVisionSensorHandle,table_2 activeVisionSensorHandles)"
    }, 
    "sim.handleCollision": {
        "body": "sim.handleCollision(${0:collisionObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.handleCollision", 
        "description": "number collisionCount,table_2 collidingObjectHandles = sim.handleCollision(number collisionObjectHandle)Handles (check for collision, etc.) a registered collision object. Collision objects can be registered while editing a scene. See also sim.readCollision, sim.resetCollision, sim.checkCollision and sim.checkCollisionEx. collisionObjectHandle: handle of the collision object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all registered collision objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)collisionObjectHandle: handle of the collision object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all registered collision objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling) number of collisions or -1 if operation was not successful"
    }, 
    "sim.objfloatparam_modelbbox_max_x": {
        "body": "sim.objfloatparam_modelbbox_max_x", 
        "scope": "source.lua", 
        "prefix": "sim.objfloatparam_modelbbox_max_x", 
        "description": "Constants"
    }, 
    "sim.modelproperty_not_collidable": {
        "body": "sim.modelproperty_not_collidable", 
        "scope": "source.lua", 
        "prefix": "sim.modelproperty_not_collidable", 
        "description": "Constants"
    }, 
    "sim.ode_global_cfm": {
        "body": "sim.ode_global_cfm", 
        "scope": "source.lua", 
        "prefix": "sim.ode_global_cfm", 
        "description": "Constants"
    }, 
    "sim.createForceSensor": {
        "body": "sim.createForceSensor(${0:options},${1:intParams},${2:floatParams},${3:color=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.createForceSensor", 
        "description": "number sensorHandle = sim.createForceSensor(number options,table_5 intParams,table_5 floatParams,table_24 color=nil)Creates a force sensor.  options: bit-coded options:bit 0 set (1): force threshold enabledbit 1 set (2): torque threshold enabledintParams (input): 5 integer parameters:intParams[0]: filter type (0=average, 1=median)intParams[1]: value count the filter operates onintParams[2]: number of consecutive threshold violation for the sensor to breakintParams[3]: reserved. Set to 0intParams[4]: reserved. Set to 0floatParams (input): 5 floating point parameters:floatParams[0]: sensor sizefloatParams[1]: force threshold valuefloatParams[2]: torque threshold valuefloatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0color: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): force threshold enabledbit 1 set (2): torque threshold enabledintParams (input): 5 integer parameters:intParams[0]: filter type (0=average, 1=median)intParams[1]: value count the filter operates onintParams[2]: number of consecutive threshold violation for the sensor to breakintParams[3]: reserved. Set to 0intParams[4]: reserved. Set to 0floatParams (input): 5 floating point parameters:floatParams[0]: sensor sizefloatParams[1]: force threshold valuefloatParams[2]: torque threshold valuefloatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0color: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): force threshold enabledbit 1 set (2): torque threshold enabledintParams (input): 5 integer parameters:intParams[0]: filter type (0=average, 1=median)intParams[1]: value count the filter operates onintParams[2]: number of consecutive threshold violation for the sensor to breakintParams[3]: reserved. Set to 0intParams[4]: reserved. Set to 0floatParams (input): 5 floating point parameters:floatParams[0]: sensor sizefloatParams[1]: force threshold valuefloatParams[2]: torque threshold valuefloatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0color: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): force threshold enabledbit 1 set (2): torque threshold enabledintParams (input): 5 integer parameters:intParams[0]: filter type (0=average, 1=median)intParams[1]: value count the filter operates onintParams[2]: number of consecutive threshold violation for the sensor to breakintParams[3]: reserved. Set to 0intParams[4]: reserved. Set to 0floatParams (input): 5 floating point parameters:floatParams[0]: sensor sizefloatParams[1]: force threshold valuefloatParams[2]: torque threshold valuefloatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0color: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): force threshold enabledbit 1 set (2): torque threshold enabledintParams (input): 5 integer parameters:intParams[0]: filter type (0=average, 1=median)intParams[1]: value count the filter operates onintParams[2]: number of consecutive threshold violation for the sensor to breakintParams[3]: reserved. Set to 0intParams[4]: reserved. Set to 0floatParams (input): 5 floating point parameters:floatParams[0]: sensor sizefloatParams[1]: force threshold valuefloatParams[2]: torque threshold valuefloatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0color: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): force threshold enabledbit 1 set (2): torque threshold enabledintParams (input): 5 integer parameters:intParams[0]: filter type (0=average, 1=median)intParams[1]: value count the filter operates onintParams[2]: number of consecutive threshold violation for the sensor to breakintParams[3]: reserved. Set to 0intParams[4]: reserved. Set to 0floatParams (input): 5 floating point parameters:floatParams[0]: sensor sizefloatParams[1]: force threshold valuefloatParams[2]: torque threshold valuefloatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0color: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): force threshold enabledbit 1 set (2): torque threshold enabledintParams (input): 5 integer parameters:intParams[0]: filter type (0=average, 1=median)intParams[1]: value count the filter operates onintParams[2]: number of consecutive threshold violation for the sensor to breakintParams[3]: reserved. Set to 0intParams[4]: reserved. Set to 0floatParams (input): 5 floating point parameters:floatParams[0]: sensor sizefloatParams[1]: force threshold valuefloatParams[2]: torque threshold valuefloatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0color: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): force threshold enabledbit 1 set (2): torque threshold enabledintParams (input): 5 integer parameters:intParams[0]: filter type (0=average, 1=median)intParams[1]: value count the filter operates onintParams[2]: number of consecutive threshold violation for the sensor to breakintParams[3]: reserved. Set to 0intParams[4]: reserved. Set to 0floatParams (input): 5 floating point parameters:floatParams[0]: sensor sizefloatParams[1]: force threshold valuefloatParams[2]: torque threshold valuefloatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0color: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): force threshold enabledbit 1 set (2): torque threshold enabledintParams (input): 5 integer parameters:intParams[0]: filter type (0=average, 1=median)intParams[1]: value count the filter operates onintParams[2]: number of consecutive threshold violation for the sensor to breakintParams[3]: reserved. Set to 0intParams[4]: reserved. Set to 0floatParams (input): 5 floating point parameters:floatParams[0]: sensor sizefloatParams[1]: force threshold valuefloatParams[2]: torque threshold valuefloatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0color: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): force threshold enabledbit 1 set (2): torque threshold enabledintParams (input): 5 integer parameters:intParams[0]: filter type (0=average, 1=median)intParams[1]: value count the filter operates onintParams[2]: number of consecutive threshold violation for the sensor to breakintParams[3]: reserved. Set to 0intParams[4]: reserved. Set to 0floatParams (input): 5 floating point parameters:floatParams[0]: sensor sizefloatParams[1]: force threshold valuefloatParams[2]: torque threshold valuefloatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0color: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): force threshold enabledbit 1 set (2): torque threshold enabledintParams (input): 5 integer parameters:intParams[0]: filter type (0=average, 1=median)intParams[1]: value count the filter operates onintParams[2]: number of consecutive threshold violation for the sensor to breakintParams[3]: reserved. Set to 0intParams[4]: reserved. Set to 0floatParams (input): 5 floating point parameters:floatParams[0]: sensor sizefloatParams[1]: force threshold valuefloatParams[2]: torque threshold valuefloatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0color: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): force threshold enabledbit 1 set (2): torque threshold enabledintParams (input): 5 integer parameters:intParams[0]: filter type (0=average, 1=median)intParams[1]: value count the filter operates onintParams[2]: number of consecutive threshold violation for the sensor to breakintParams[3]: reserved. Set to 0intParams[4]: reserved. Set to 0floatParams (input): 5 floating point parameters:floatParams[0]: sensor sizefloatParams[1]: force threshold valuefloatParams[2]: torque threshold valuefloatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0color: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): force threshold enabledbit 1 set (2): torque threshold enabledintParams (input): 5 integer parameters:intParams[0]: filter type (0=average, 1=median)intParams[1]: value count the filter operates onintParams[2]: number of consecutive threshold violation for the sensor to breakintParams[3]: reserved. Set to 0intParams[4]: reserved. Set to 0floatParams (input): 5 floating point parameters:floatParams[0]: sensor sizefloatParams[1]: force threshold valuefloatParams[2]: torque threshold valuefloatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0color: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): force threshold enabledbit 1 set (2): torque threshold enabledintParams (input): 5 integer parameters:intParams[0]: filter type (0=average, 1=median)intParams[1]: value count the filter operates onintParams[2]: number of consecutive threshold violation for the sensor to breakintParams[3]: reserved. Set to 0intParams[4]: reserved. Set to 0floatParams (input): 5 floating point parameters:floatParams[0]: sensor sizefloatParams[1]: force threshold valuefloatParams[2]: torque threshold valuefloatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0color: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): force threshold enabledbit 1 set (2): torque threshold enabledintParams (input): 5 integer parameters:intParams[0]: filter type (0=average, 1=median)intParams[1]: value count the filter operates onintParams[2]: number of consecutive threshold violation for the sensor to breakintParams[3]: reserved. Set to 0intParams[4]: reserved. Set to 0floatParams (input): 5 floating point parameters:floatParams[0]: sensor sizefloatParams[1]: force threshold valuefloatParams[2]: torque threshold valuefloatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0color: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): force threshold enabledbit 1 set (2): torque threshold enabledintParams (input): 5 integer parameters:intParams[0]: filter type (0=average, 1=median)intParams[1]: value count the filter operates onintParams[2]: number of consecutive threshold violation for the sensor to breakintParams[3]: reserved. Set to 0intParams[4]: reserved. Set to 0floatParams (input): 5 floating point parameters:floatParams[0]: sensor sizefloatParams[1]: force threshold valuefloatParams[2]: torque threshold valuefloatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0color: pointer to 2x4x3 values representing the various colors of the sensor ((part1, part2) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Can be NULL for default values -1 if operation was not successful, otherwise the handle of the force sensor"
    }, 
    "sim.getScriptExecutionCount": {
        "body": "sim.getScriptExecutionCount()", 
        "scope": "source.lua", 
        "prefix": "sim.getScriptExecutionCount", 
        "description": "number executionCount = sim.getScriptExecutionCount()Retrieves the number of times the current script was called and returned. See also sim.getSimulationState. - -"
    }, 
    "sim.vortex_joint_p1frictioncoeff": {
        "body": "sim.vortex_joint_p1frictioncoeff", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p1frictioncoeff", 
        "description": "Constants"
    }, 
    "simUI.curve_scatter_shape.cross_circle": {
        "body": "simUI.curve_scatter_shape.cross_circle", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_scatter_shape.cross_circle", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_p0frictioncoeff": {
        "body": "sim.vortex_joint_p0frictioncoeff", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p0frictioncoeff", 
        "description": "Constants"
    }, 
    "sim.announceSceneContentChange": {
        "body": "sim.announceSceneContentChange()", 
        "scope": "source.lua", 
        "prefix": "sim.announceSceneContentChange", 
        "description": "number result = sim.announceSceneContentChange()Announces a change in the scene. This is required for the undo/redo function to operate properly when performing changes via the API. Only call this function directly after a change was made through a dialog element (e.g. a checkbox was checked/unchecked) and that change was reported to the scene (e.g. with sim.writeCustomDataBlock). What this call will do is following: the whole scene will be serialized (saved) to memory as a scene image and compared to a previously memorized scene image. If both images are same, then the last image is discarded, otherwise only the changes between the two images are memorized. A call to this function has no effect (and doesn't generate any error) when called during simulation or when in edit mode. None -1 if operation was not successful, 0 if nothing was memorized, or 1 if changes were memorized."
    }, 
    "simMTB.step": {
        "body": "simMTB.step(${0:mtbServerHandle})", 
        "scope": "source.lua", 
        "prefix": "simMTB.step", 
        "description": "number result,string message= simMTB.step(number mtbServerHandle)"
    }, 
    "sim.displayattribute_useauxcomponent": {
        "body": "sim.displayattribute_useauxcomponent", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_useauxcomponent", 
        "description": "Constants"
    }, 
    "sim.ode_joint_stopcfm": {
        "body": "sim.ode_joint_stopcfm", 
        "scope": "source.lua", 
        "prefix": "sim.ode_joint_stopcfm", 
        "description": "Constants"
    }, 
    "sim.scripttype_customizationscript": {
        "body": "sim.scripttype_customizationscript", 
        "scope": "source.lua", 
        "prefix": "sim.scripttype_customizationscript", 
        "description": "Constants"
    }, 
    "sim.readCustomDataBlockTags": {
        "body": "sim.readCustomDataBlockTags(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.readCustomDataBlockTags", 
        "description": "table tags = sim.readCustomDataBlockTags(number objectHandle)Reads the tags of all custom data that is stored inside of an object, a script or a scene (i.e. the data is part of the object, the script or the scene).  Reads also all custom data that is stored inside of the application's current session. See also sim.readCustomDataBlock. objectHandle: handle of the object or script where the data is stored, or sim_handle_scene if the data is stored in the scene, or sim_handle_app if the data is stored in the application's current session.tagCount: a pointer to an integer receiving the number of tag strings contained in the returned buffer.objectHandle: handle of the object or script where the data is stored, or sim_handle_scene if the data is stored in the scene, or sim_handle_app if the data is stored in the application's current session.tagCount: a pointer to an integer receiving the number of tag strings contained in the returned buffer. the tags (each followed by the zero-char) or nil in case of an error (or if no tags are present). The user is in charge of releasing the returned buffer with simReleaseBuffer."
    }, 
    "simSurfRec.Algorithm.scalespace": {
        "body": "simSurfRec.Algorithm.scalespace", 
        "scope": "source.lua", 
        "prefix": "simSurfRec.Algorithm.scalespace", 
        "description": "Constants"
    }, 
    "simROS.setParamString": {
        "body": "simROS.setParamString(${0:name},${1:value})", 
        "scope": "source.lua", 
        "prefix": "simROS.setParamString", 
        "description": "simROS.setParamString(string name,string value)"
    }, 
    "simOMPL.Algorithm.PRMstar": {
        "body": "simOMPL.Algorithm.PRMstar", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.PRMstar", 
        "description": "Constants"
    }, 
    "simK3.getGripperProxSensor": {
        "body": "simK3.getGripperProxSensor(${0:k3Handle},${1:index})", 
        "scope": "source.lua", 
        "prefix": "simK3.getGripperProxSensor", 
        "description": "number distance = simK3.getGripperProxSensor(number k3Handle,number index)"
    }, 
    "sim.displayattribute_noghosts": {
        "body": "sim.displayattribute_noghosts", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_noghosts", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_upperlimitstiffness": {
        "body": "sim.vortex_joint_upperlimitstiffness", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_upperlimitstiffness", 
        "description": "Constants"
    }, 
    "sim.mill_pyramid_subtype": {
        "body": "sim.mill_pyramid_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.mill_pyramid_subtype", 
        "description": "Constants"
    }, 
    "sim.adjustView": {
        "body": "sim.adjustView(${0:viewHandleOrIndex},${1:associatedViewableObjectHandle},${2:options},${3:viewLabel=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.adjustView", 
        "description": "number result = sim.adjustView(number viewHandleOrIndex,number associatedViewableObjectHandle,number options,string viewLabel=nil)Adjusts parameters of a view. See also the sim.floatingViewAdd and sim.cameraFitToView functions. viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view.associatedViewableObjectHandle: handle of the object that you wish to associate with the view. Must be a viewable object. Can also be -1, in which case the view is emptiedoptions: bit-coded:bit0-bit3=the 3D display mode (0=solid rendering, 1=wireframe rendering)bit4 (16) set=orthogonal projection (otherwise perspective projection)bit5 (32) set=x/y graph display (otherwise time-graph display)bit6 (64) set=floating view is removed at simulation endbit7 (128) set=floating view is ignored during a scene save operationbit8 (256) set=the view is not modified. The return value of the function indicates if the view still exists (2), or does not exist anymore (1). No error is generated.bit9 (512) set=the view is not modified. The return value of the function represents the object associated with the view.bit10 (1024) set=x/y graph has x view size proportional to y view size.viewLabel: a label that will be displayed at the top of a floating view. If NULL is specified, then the name of the associated viewable object is taken as label.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view.associatedViewableObjectHandle: handle of the object that you wish to associate with the view. Must be a viewable object. Can also be -1, in which case the view is emptiedoptions: bit-coded:bit0-bit3=the 3D display mode (0=solid rendering, 1=wireframe rendering)bit4 (16) set=orthogonal projection (otherwise perspective projection)bit5 (32) set=x/y graph display (otherwise time-graph display)bit6 (64) set=floating view is removed at simulation endbit7 (128) set=floating view is ignored during a scene save operationbit8 (256) set=the view is not modified. The return value of the function indicates if the view still exists (2), or does not exist anymore (1). No error is generated.bit9 (512) set=the view is not modified. The return value of the function represents the object associated with the view.bit10 (1024) set=x/y graph has x view size proportional to y view size.viewLabel: a label that will be displayed at the top of a floating view. If NULL is specified, then the name of the associated viewable object is taken as label.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view.associatedViewableObjectHandle: handle of the object that you wish to associate with the view. Must be a viewable object. Can also be -1, in which case the view is emptiedoptions: bit-coded:bit0-bit3=the 3D display mode (0=solid rendering, 1=wireframe rendering)bit4 (16) set=orthogonal projection (otherwise perspective projection)bit5 (32) set=x/y graph display (otherwise time-graph display)bit6 (64) set=floating view is removed at simulation endbit7 (128) set=floating view is ignored during a scene save operationbit8 (256) set=the view is not modified. The return value of the function indicates if the view still exists (2), or does not exist anymore (1). No error is generated.bit9 (512) set=the view is not modified. The return value of the function represents the object associated with the view.bit10 (1024) set=x/y graph has x view size proportional to y view size.viewLabel: a label that will be displayed at the top of a floating view. If NULL is specified, then the name of the associated viewable object is taken as label.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view.associatedViewableObjectHandle: handle of the object that you wish to associate with the view. Must be a viewable object. Can also be -1, in which case the view is emptiedoptions: bit-coded:bit0-bit3=the 3D display mode (0=solid rendering, 1=wireframe rendering)bit4 (16) set=orthogonal projection (otherwise perspective projection)bit5 (32) set=x/y graph display (otherwise time-graph display)bit6 (64) set=floating view is removed at simulation endbit7 (128) set=floating view is ignored during a scene save operationbit8 (256) set=the view is not modified. The return value of the function indicates if the view still exists (2), or does not exist anymore (1). No error is generated.bit9 (512) set=the view is not modified. The return value of the function represents the object associated with the view.bit10 (1024) set=x/y graph has x view size proportional to y view size.viewLabel: a label that will be displayed at the top of a floating view. If NULL is specified, then the name of the associated viewable object is taken as label.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view.associatedViewableObjectHandle: handle of the object that you wish to associate with the view. Must be a viewable object. Can also be -1, in which case the view is emptiedoptions: bit-coded:bit0-bit3=the 3D display mode (0=solid rendering, 1=wireframe rendering)bit4 (16) set=orthogonal projection (otherwise perspective projection)bit5 (32) set=x/y graph display (otherwise time-graph display)bit6 (64) set=floating view is removed at simulation endbit7 (128) set=floating view is ignored during a scene save operationbit8 (256) set=the view is not modified. The return value of the function indicates if the view still exists (2), or does not exist anymore (1). No error is generated.bit9 (512) set=the view is not modified. The return value of the function represents the object associated with the view.bit10 (1024) set=x/y graph has x view size proportional to y view size.viewLabel: a label that will be displayed at the top of a floating view. If NULL is specified, then the name of the associated viewable object is taken as label.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view.associatedViewableObjectHandle: handle of the object that you wish to associate with the view. Must be a viewable object. Can also be -1, in which case the view is emptiedoptions: bit-coded:bit0-bit3=the 3D display mode (0=solid rendering, 1=wireframe rendering)bit4 (16) set=orthogonal projection (otherwise perspective projection)bit5 (32) set=x/y graph display (otherwise time-graph display)bit6 (64) set=floating view is removed at simulation endbit7 (128) set=floating view is ignored during a scene save operationbit8 (256) set=the view is not modified. The return value of the function indicates if the view still exists (2), or does not exist anymore (1). No error is generated.bit9 (512) set=the view is not modified. The return value of the function represents the object associated with the view.bit10 (1024) set=x/y graph has x view size proportional to y view size.viewLabel: a label that will be displayed at the top of a floating view. If NULL is specified, then the name of the associated viewable object is taken as label.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view.associatedViewableObjectHandle: handle of the object that you wish to associate with the view. Must be a viewable object. Can also be -1, in which case the view is emptiedoptions: bit-coded:bit0-bit3=the 3D display mode (0=solid rendering, 1=wireframe rendering)bit4 (16) set=orthogonal projection (otherwise perspective projection)bit5 (32) set=x/y graph display (otherwise time-graph display)bit6 (64) set=floating view is removed at simulation endbit7 (128) set=floating view is ignored during a scene save operationbit8 (256) set=the view is not modified. The return value of the function indicates if the view still exists (2), or does not exist anymore (1). No error is generated.bit9 (512) set=the view is not modified. The return value of the function represents the object associated with the view.bit10 (1024) set=x/y graph has x view size proportional to y view size.viewLabel: a label that will be displayed at the top of a floating view. If NULL is specified, then the name of the associated viewable object is taken as label.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view.associatedViewableObjectHandle: handle of the object that you wish to associate with the view. Must be a viewable object. Can also be -1, in which case the view is emptiedoptions: bit-coded:bit0-bit3=the 3D display mode (0=solid rendering, 1=wireframe rendering)bit4 (16) set=orthogonal projection (otherwise perspective projection)bit5 (32) set=x/y graph display (otherwise time-graph display)bit6 (64) set=floating view is removed at simulation endbit7 (128) set=floating view is ignored during a scene save operationbit8 (256) set=the view is not modified. The return value of the function indicates if the view still exists (2), or does not exist anymore (1). No error is generated.bit9 (512) set=the view is not modified. The return value of the function represents the object associated with the view.bit10 (1024) set=x/y graph has x view size proportional to y view size.viewLabel: a label that will be displayed at the top of a floating view. If NULL is specified, then the name of the associated viewable object is taken as label.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view.associatedViewableObjectHandle: handle of the object that you wish to associate with the view. Must be a viewable object. Can also be -1, in which case the view is emptiedoptions: bit-coded:bit0-bit3=the 3D display mode (0=solid rendering, 1=wireframe rendering)bit4 (16) set=orthogonal projection (otherwise perspective projection)bit5 (32) set=x/y graph display (otherwise time-graph display)bit6 (64) set=floating view is removed at simulation endbit7 (128) set=floating view is ignored during a scene save operationbit8 (256) set=the view is not modified. The return value of the function indicates if the view still exists (2), or does not exist anymore (1). No error is generated.bit9 (512) set=the view is not modified. The return value of the function represents the object associated with the view.bit10 (1024) set=x/y graph has x view size proportional to y view size.viewLabel: a label that will be displayed at the top of a floating view. If NULL is specified, then the name of the associated viewable object is taken as label.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view.associatedViewableObjectHandle: handle of the object that you wish to associate with the view. Must be a viewable object. Can also be -1, in which case the view is emptiedoptions: bit-coded:bit0-bit3=the 3D display mode (0=solid rendering, 1=wireframe rendering)bit4 (16) set=orthogonal projection (otherwise perspective projection)bit5 (32) set=x/y graph display (otherwise time-graph display)bit6 (64) set=floating view is removed at simulation endbit7 (128) set=floating view is ignored during a scene save operationbit8 (256) set=the view is not modified. The return value of the function indicates if the view still exists (2), or does not exist anymore (1). No error is generated.bit9 (512) set=the view is not modified. The return value of the function represents the object associated with the view.bit10 (1024) set=x/y graph has x view size proportional to y view size.viewLabel: a label that will be displayed at the top of a floating view. If NULL is specified, then the name of the associated viewable object is taken as label.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view.associatedViewableObjectHandle: handle of the object that you wish to associate with the view. Must be a viewable object. Can also be -1, in which case the view is emptiedoptions: bit-coded:bit0-bit3=the 3D display mode (0=solid rendering, 1=wireframe rendering)bit4 (16) set=orthogonal projection (otherwise perspective projection)bit5 (32) set=x/y graph display (otherwise time-graph display)bit6 (64) set=floating view is removed at simulation endbit7 (128) set=floating view is ignored during a scene save operationbit8 (256) set=the view is not modified. The return value of the function indicates if the view still exists (2), or does not exist anymore (1). No error is generated.bit9 (512) set=the view is not modified. The return value of the function represents the object associated with the view.bit10 (1024) set=x/y graph has x view size proportional to y view size.viewLabel: a label that will be displayed at the top of a floating view. If NULL is specified, then the name of the associated viewable object is taken as label.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view.associatedViewableObjectHandle: handle of the object that you wish to associate with the view. Must be a viewable object. Can also be -1, in which case the view is emptiedoptions: bit-coded:bit0-bit3=the 3D display mode (0=solid rendering, 1=wireframe rendering)bit4 (16) set=orthogonal projection (otherwise perspective projection)bit5 (32) set=x/y graph display (otherwise time-graph display)bit6 (64) set=floating view is removed at simulation endbit7 (128) set=floating view is ignored during a scene save operationbit8 (256) set=the view is not modified. The return value of the function indicates if the view still exists (2), or does not exist anymore (1). No error is generated.bit9 (512) set=the view is not modified. The return value of the function represents the object associated with the view.bit10 (1024) set=x/y graph has x view size proportional to y view size.viewLabel: a label that will be displayed at the top of a floating view. If NULL is specified, then the name of the associated viewable object is taken as label.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view.associatedViewableObjectHandle: handle of the object that you wish to associate with the view. Must be a viewable object. Can also be -1, in which case the view is emptiedoptions: bit-coded:bit0-bit3=the 3D display mode (0=solid rendering, 1=wireframe rendering)bit4 (16) set=orthogonal projection (otherwise perspective projection)bit5 (32) set=x/y graph display (otherwise time-graph display)bit6 (64) set=floating view is removed at simulation endbit7 (128) set=floating view is ignored during a scene save operationbit8 (256) set=the view is not modified. The return value of the function indicates if the view still exists (2), or does not exist anymore (1). No error is generated.bit9 (512) set=the view is not modified. The return value of the function represents the object associated with the view.bit10 (1024) set=x/y graph has x view size proportional to y view size.viewLabel: a label that will be displayed at the top of a floating view. If NULL is specified, then the name of the associated viewable object is taken as label. A value >0 in case of success"
    }, 
    "simRRS1.stopRcsServer": {
        "body": "simRRS1.stopRcsServer()", 
        "scope": "source.lua", 
        "prefix": "simRRS1.stopRcsServer", 
        "description": "boolean result= simRRS1.stopRcsServer()"
    }, 
    "simx.getDialogInput": {
        "body": "simx.getDialogInput(${0:clientId},${1:dialogHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.getDialogInput", 
        "description": "number returnCode,string inputText= simx.getDialogInput(number clientId,number dialogHandle)Queries the text the user entered into a  generic dialog box of style sim.dlgstyle_input. To be used after simx.displayDialog was called and after simx.getDialogResult returned sim.dlgret_ok. clientID: the client ID. refer to simx.start.dialogHandle: handle of generic dialog (return value of simx.displayDialog)operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking  returnCode: a remote API function return codeinputText: the string the user entered."
    }, 
    "sim.shape_simpleshape_subtype": {
        "body": "sim.shape_simpleshape_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.shape_simpleshape_subtype", 
        "description": "Constants"
    }, 
    "sim.importMesh": {
        "body": "sim.importMesh(${0:fileformat},${1:pathAndFilename},${2:options},${3:identicalVerticeTolerance},${4:scalingFactor})", 
        "scope": "source.lua", 
        "prefix": "sim.importMesh", 
        "description": "table_of_table vertices,table_of_table indices,nil,table names = sim.importMesh(number fileformat,string pathAndFilename,number options,number identicalVerticeTolerance,number scalingFactor)Imports a mesh from a file. See also sim.exportMesh, sim.importShape and sim.createMeshShape fileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format and 4 for BINARY STL formatpathAndFilename: the location of the file to import.options: bit-coded: bit0 set (1): keep identical vertices, bit1 set (2): keep identical triangles, bit2 set (4): don't correct triangle windingsidenticalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesvertices: an array to vertice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowverticesSizes: an array indicating the individual vertice array sizes. The user is in charge of releasing the memory. See the example belowindices: an array to indice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. Can be NULL. See the example belowindicesSizes: an array indicating the individual indice array sizes. The user is in charge of releasing the memory. Can be NULL if indices is also NULL. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names extracted from the file. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowUSAGE EXAMPLE:simFloat** vertices;simInt* verticesSizes;simInt** indices;simInt* indicesSizes;simChar** names;simInt elementCount=simImportMesh(1,d:\\example.dxf,0,0.0001f,1.0f,&vertices,                            &verticesSizes,&indices,&indicesSizes,NULL,&names);if (elementCount>0){    const float grey[3]={0.5f,0.5f,0.5f};    for (int i=0;i<elementCount;i++)    {        simInt shapeHandle=simCreateMeshShape(2,20.0f*3.1415f/180.0f,vertices[i],                               verticesSizes[i],indices[i],indicesSizes[i],NULL);        simSetObjectName(shapeHandle,names[i]);        simSetShapeColor(shapeHandle,,sim_colorcomponent_ambient,grey);        simReleaseBuffer(names[i]);        simReleaseBuffer((simChar*)indices[i]);        simReleaseBuffer((simChar*)vertices[i]);    }    simReleaseBuffer((simChar*)names);    simReleaseBuffer((simChar*)indicesSizes);    simReleaseBuffer((simChar*)indices);    simReleaseBuffer((simChar*)verticesSizes);    simReleaseBuffer((simChar*)vertices);}fileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format and 4 for BINARY STL formatpathAndFilename: the location of the file to import.options: bit-coded: bit0 set (1): keep identical vertices, bit1 set (2): keep identical triangles, bit2 set (4): don't correct triangle windingsidenticalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesvertices: an array to vertice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowverticesSizes: an array indicating the individual vertice array sizes. The user is in charge of releasing the memory. See the example belowindices: an array to indice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. Can be NULL. See the example belowindicesSizes: an array indicating the individual indice array sizes. The user is in charge of releasing the memory. Can be NULL if indices is also NULL. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names extracted from the file. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowUSAGE EXAMPLE:simFloat** vertices;simInt* verticesSizes;simInt** indices;simInt* indicesSizes;simChar** names;simInt elementCount=simImportMesh(1,d:\\example.dxf,0,0.0001f,1.0f,&vertices,                            &verticesSizes,&indices,&indicesSizes,NULL,&names);if (elementCount>0){    const float grey[3]={0.5f,0.5f,0.5f};    for (int i=0;i<elementCount;i++)    {        simInt shapeHandle=simCreateMeshShape(2,20.0f*3.1415f/180.0f,vertices[i],                               verticesSizes[i],indices[i],indicesSizes[i],NULL);        simSetObjectName(shapeHandle,names[i]);        simSetShapeColor(shapeHandle,,sim_colorcomponent_ambient,grey);        simReleaseBuffer(names[i]);        simReleaseBuffer((simChar*)indices[i]);        simReleaseBuffer((simChar*)vertices[i]);    }    simReleaseBuffer((simChar*)names);    simReleaseBuffer((simChar*)indicesSizes);    simReleaseBuffer((simChar*)indices);    simReleaseBuffer((simChar*)verticesSizes);    simReleaseBuffer((simChar*)vertices);}fileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format and 4 for BINARY STL formatpathAndFilename: the location of the file to import.options: bit-coded: bit0 set (1): keep identical vertices, bit1 set (2): keep identical triangles, bit2 set (4): don't correct triangle windingsidenticalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesvertices: an array to vertice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowverticesSizes: an array indicating the individual vertice array sizes. The user is in charge of releasing the memory. See the example belowindices: an array to indice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. Can be NULL. See the example belowindicesSizes: an array indicating the individual indice array sizes. The user is in charge of releasing the memory. Can be NULL if indices is also NULL. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names extracted from the file. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowUSAGE EXAMPLE:simFloat** vertices;simInt* verticesSizes;simInt** indices;simInt* indicesSizes;simChar** names;simInt elementCount=simImportMesh(1,d:\\example.dxf,0,0.0001f,1.0f,&vertices,                            &verticesSizes,&indices,&indicesSizes,NULL,&names);if (elementCount>0){    const float grey[3]={0.5f,0.5f,0.5f};    for (int i=0;i<elementCount;i++)    {        simInt shapeHandle=simCreateMeshShape(2,20.0f*3.1415f/180.0f,vertices[i],                               verticesSizes[i],indices[i],indicesSizes[i],NULL);        simSetObjectName(shapeHandle,names[i]);        simSetShapeColor(shapeHandle,,sim_colorcomponent_ambient,grey);        simReleaseBuffer(names[i]);        simReleaseBuffer((simChar*)indices[i]);        simReleaseBuffer((simChar*)vertices[i]);    }    simReleaseBuffer((simChar*)names);    simReleaseBuffer((simChar*)indicesSizes);    simReleaseBuffer((simChar*)indices);    simReleaseBuffer((simChar*)verticesSizes);    simReleaseBuffer((simChar*)vertices);}fileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format and 4 for BINARY STL formatpathAndFilename: the location of the file to import.options: bit-coded: bit0 set (1): keep identical vertices, bit1 set (2): keep identical triangles, bit2 set (4): don't correct triangle windingsidenticalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesvertices: an array to vertice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowverticesSizes: an array indicating the individual vertice array sizes. The user is in charge of releasing the memory. See the example belowindices: an array to indice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. Can be NULL. See the example belowindicesSizes: an array indicating the individual indice array sizes. The user is in charge of releasing the memory. Can be NULL if indices is also NULL. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names extracted from the file. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowUSAGE EXAMPLE:simFloat** vertices;simInt* verticesSizes;simInt** indices;simInt* indicesSizes;simChar** names;simInt elementCount=simImportMesh(1,d:\\example.dxf,0,0.0001f,1.0f,&vertices,                            &verticesSizes,&indices,&indicesSizes,NULL,&names);if (elementCount>0){    const float grey[3]={0.5f,0.5f,0.5f};    for (int i=0;i<elementCount;i++)    {        simInt shapeHandle=simCreateMeshShape(2,20.0f*3.1415f/180.0f,vertices[i],                               verticesSizes[i],indices[i],indicesSizes[i],NULL);        simSetObjectName(shapeHandle,names[i]);        simSetShapeColor(shapeHandle,,sim_colorcomponent_ambient,grey);        simReleaseBuffer(names[i]);        simReleaseBuffer((simChar*)indices[i]);        simReleaseBuffer((simChar*)vertices[i]);    }    simReleaseBuffer((simChar*)names);    simReleaseBuffer((simChar*)indicesSizes);    simReleaseBuffer((simChar*)indices);    simReleaseBuffer((simChar*)verticesSizes);    simReleaseBuffer((simChar*)vertices);}fileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format and 4 for BINARY STL formatpathAndFilename: the location of the file to import.options: bit-coded: bit0 set (1): keep identical vertices, bit1 set (2): keep identical triangles, bit2 set (4): don't correct triangle windingsidenticalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesvertices: an array to vertice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowverticesSizes: an array indicating the individual vertice array sizes. The user is in charge of releasing the memory. See the example belowindices: an array to indice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. Can be NULL. See the example belowindicesSizes: an array indicating the individual indice array sizes. The user is in charge of releasing the memory. Can be NULL if indices is also NULL. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names extracted from the file. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowUSAGE EXAMPLE:simFloat** vertices;simInt* verticesSizes;simInt** indices;simInt* indicesSizes;simChar** names;simInt elementCount=simImportMesh(1,d:\\example.dxf,0,0.0001f,1.0f,&vertices,                            &verticesSizes,&indices,&indicesSizes,NULL,&names);if (elementCount>0){    const float grey[3]={0.5f,0.5f,0.5f};    for (int i=0;i<elementCount;i++)    {        simInt shapeHandle=simCreateMeshShape(2,20.0f*3.1415f/180.0f,vertices[i],                               verticesSizes[i],indices[i],indicesSizes[i],NULL);        simSetObjectName(shapeHandle,names[i]);        simSetShapeColor(shapeHandle,,sim_colorcomponent_ambient,grey);        simReleaseBuffer(names[i]);        simReleaseBuffer((simChar*)indices[i]);        simReleaseBuffer((simChar*)vertices[i]);    }    simReleaseBuffer((simChar*)names);    simReleaseBuffer((simChar*)indicesSizes);    simReleaseBuffer((simChar*)indices);    simReleaseBuffer((simChar*)verticesSizes);    simReleaseBuffer((simChar*)vertices);}fileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format and 4 for BINARY STL formatpathAndFilename: the location of the file to import.options: bit-coded: bit0 set (1): keep identical vertices, bit1 set (2): keep identical triangles, bit2 set (4): don't correct triangle windingsidenticalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesvertices: an array to vertice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowverticesSizes: an array indicating the individual vertice array sizes. The user is in charge of releasing the memory. See the example belowindices: an array to indice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. Can be NULL. See the example belowindicesSizes: an array indicating the individual indice array sizes. The user is in charge of releasing the memory. Can be NULL if indices is also NULL. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names extracted from the file. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowUSAGE EXAMPLE:simFloat** vertices;simInt* verticesSizes;simInt** indices;simInt* indicesSizes;simChar** names;simInt elementCount=simImportMesh(1,d:\\example.dxf,0,0.0001f,1.0f,&vertices,                            &verticesSizes,&indices,&indicesSizes,NULL,&names);if (elementCount>0){    const float grey[3]={0.5f,0.5f,0.5f};    for (int i=0;i<elementCount;i++)    {        simInt shapeHandle=simCreateMeshShape(2,20.0f*3.1415f/180.0f,vertices[i],                               verticesSizes[i],indices[i],indicesSizes[i],NULL);        simSetObjectName(shapeHandle,names[i]);        simSetShapeColor(shapeHandle,,sim_colorcomponent_ambient,grey);        simReleaseBuffer(names[i]);        simReleaseBuffer((simChar*)indices[i]);        simReleaseBuffer((simChar*)vertices[i]);    }    simReleaseBuffer((simChar*)names);    simReleaseBuffer((simChar*)indicesSizes);    simReleaseBuffer((simChar*)indices);    simReleaseBuffer((simChar*)verticesSizes);    simReleaseBuffer((simChar*)vertices);}fileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format and 4 for BINARY STL formatpathAndFilename: the location of the file to import.options: bit-coded: bit0 set (1): keep identical vertices, bit1 set (2): keep identical triangles, bit2 set (4): don't correct triangle windingsidenticalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesvertices: an array to vertice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowverticesSizes: an array indicating the individual vertice array sizes. The user is in charge of releasing the memory. See the example belowindices: an array to indice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. Can be NULL. See the example belowindicesSizes: an array indicating the individual indice array sizes. The user is in charge of releasing the memory. Can be NULL if indices is also NULL. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names extracted from the file. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowUSAGE EXAMPLE:simFloat** vertices;simInt* verticesSizes;simInt** indices;simInt* indicesSizes;simChar** names;simInt elementCount=simImportMesh(1,d:\\example.dxf,0,0.0001f,1.0f,&vertices,                            &verticesSizes,&indices,&indicesSizes,NULL,&names);if (elementCount>0){    const float grey[3]={0.5f,0.5f,0.5f};    for (int i=0;i<elementCount;i++)    {        simInt shapeHandle=simCreateMeshShape(2,20.0f*3.1415f/180.0f,vertices[i],                               verticesSizes[i],indices[i],indicesSizes[i],NULL);        simSetObjectName(shapeHandle,names[i]);        simSetShapeColor(shapeHandle,,sim_colorcomponent_ambient,grey);        simReleaseBuffer(names[i]);        simReleaseBuffer((simChar*)indices[i]);        simReleaseBuffer((simChar*)vertices[i]);    }    simReleaseBuffer((simChar*)names);    simReleaseBuffer((simChar*)indicesSizes);    simReleaseBuffer((simChar*)indices);    simReleaseBuffer((simChar*)verticesSizes);    simReleaseBuffer((simChar*)vertices);}fileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format and 4 for BINARY STL formatpathAndFilename: the location of the file to import.options: bit-coded: bit0 set (1): keep identical vertices, bit1 set (2): keep identical triangles, bit2 set (4): don't correct triangle windingsidenticalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesvertices: an array to vertice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowverticesSizes: an array indicating the individual vertice array sizes. The user is in charge of releasing the memory. See the example belowindices: an array to indice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. Can be NULL. See the example belowindicesSizes: an array indicating the individual indice array sizes. The user is in charge of releasing the memory. Can be NULL if indices is also NULL. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names extracted from the file. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowUSAGE EXAMPLE:simFloat** vertices;simInt* verticesSizes;simInt** indices;simInt* indicesSizes;simChar** names;simInt elementCount=simImportMesh(1,d:\\example.dxf,0,0.0001f,1.0f,&vertices,                            &verticesSizes,&indices,&indicesSizes,NULL,&names);if (elementCount>0){    const float grey[3]={0.5f,0.5f,0.5f};    for (int i=0;i<elementCount;i++)    {        simInt shapeHandle=simCreateMeshShape(2,20.0f*3.1415f/180.0f,vertices[i],                               verticesSizes[i],indices[i],indicesSizes[i],NULL);        simSetObjectName(shapeHandle,names[i]);        simSetShapeColor(shapeHandle,,sim_colorcomponent_ambient,grey);        simReleaseBuffer(names[i]);        simReleaseBuffer((simChar*)indices[i]);        simReleaseBuffer((simChar*)vertices[i]);    }    simReleaseBuffer((simChar*)names);    simReleaseBuffer((simChar*)indicesSizes);    simReleaseBuffer((simChar*)indices);    simReleaseBuffer((simChar*)verticesSizes);    simReleaseBuffer((simChar*)vertices);}fileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format and 4 for BINARY STL formatpathAndFilename: the location of the file to import.options: bit-coded: bit0 set (1): keep identical vertices, bit1 set (2): keep identical triangles, bit2 set (4): don't correct triangle windingsidenticalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesvertices: an array to vertice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowverticesSizes: an array indicating the individual vertice array sizes. The user is in charge of releasing the memory. See the example belowindices: an array to indice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. Can be NULL. See the example belowindicesSizes: an array indicating the individual indice array sizes. The user is in charge of releasing the memory. Can be NULL if indices is also NULL. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names extracted from the file. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowUSAGE EXAMPLE:simFloat** vertices;simInt* verticesSizes;simInt** indices;simInt* indicesSizes;simChar** names;simInt elementCount=simImportMesh(1,d:\\example.dxf,0,0.0001f,1.0f,&vertices,                            &verticesSizes,&indices,&indicesSizes,NULL,&names);if (elementCount>0){    const float grey[3]={0.5f,0.5f,0.5f};    for (int i=0;i<elementCount;i++)    {        simInt shapeHandle=simCreateMeshShape(2,20.0f*3.1415f/180.0f,vertices[i],                               verticesSizes[i],indices[i],indicesSizes[i],NULL);        simSetObjectName(shapeHandle,names[i]);        simSetShapeColor(shapeHandle,,sim_colorcomponent_ambient,grey);        simReleaseBuffer(names[i]);        simReleaseBuffer((simChar*)indices[i]);        simReleaseBuffer((simChar*)vertices[i]);    }    simReleaseBuffer((simChar*)names);    simReleaseBuffer((simChar*)indicesSizes);    simReleaseBuffer((simChar*)indices);    simReleaseBuffer((simChar*)verticesSizes);    simReleaseBuffer((simChar*)vertices);}fileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format and 4 for BINARY STL formatpathAndFilename: the location of the file to import.options: bit-coded: bit0 set (1): keep identical vertices, bit1 set (2): keep identical triangles, bit2 set (4): don't correct triangle windingsidenticalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesvertices: an array to vertice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowverticesSizes: an array indicating the individual vertice array sizes. The user is in charge of releasing the memory. See the example belowindices: an array to indice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. Can be NULL. See the example belowindicesSizes: an array indicating the individual indice array sizes. The user is in charge of releasing the memory. Can be NULL if indices is also NULL. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names extracted from the file. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowUSAGE EXAMPLE:simFloat** vertices;simInt* verticesSizes;simInt** indices;simInt* indicesSizes;simChar** names;simInt elementCount=simImportMesh(1,d:\\example.dxf,0,0.0001f,1.0f,&vertices,                            &verticesSizes,&indices,&indicesSizes,NULL,&names);if (elementCount>0){    const float grey[3]={0.5f,0.5f,0.5f};    for (int i=0;i<elementCount;i++)    {        simInt shapeHandle=simCreateMeshShape(2,20.0f*3.1415f/180.0f,vertices[i],                               verticesSizes[i],indices[i],indicesSizes[i],NULL);        simSetObjectName(shapeHandle,names[i]);        simSetShapeColor(shapeHandle,,sim_colorcomponent_ambient,grey);        simReleaseBuffer(names[i]);        simReleaseBuffer((simChar*)indices[i]);        simReleaseBuffer((simChar*)vertices[i]);    }    simReleaseBuffer((simChar*)names);    simReleaseBuffer((simChar*)indicesSizes);    simReleaseBuffer((simChar*)indices);    simReleaseBuffer((simChar*)verticesSizes);    simReleaseBuffer((simChar*)vertices);}fileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format and 4 for BINARY STL formatpathAndFilename: the location of the file to import.options: bit-coded: bit0 set (1): keep identical vertices, bit1 set (2): keep identical triangles, bit2 set (4): don't correct triangle windingsidenticalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesvertices: an array to vertice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowverticesSizes: an array indicating the individual vertice array sizes. The user is in charge of releasing the memory. See the example belowindices: an array to indice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. Can be NULL. See the example belowindicesSizes: an array indicating the individual indice array sizes. The user is in charge of releasing the memory. Can be NULL if indices is also NULL. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names extracted from the file. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowUSAGE EXAMPLE:simFloat** vertices;simInt* verticesSizes;simInt** indices;simInt* indicesSizes;simChar** names;simInt elementCount=simImportMesh(1,d:\\example.dxf,0,0.0001f,1.0f,&vertices,                            &verticesSizes,&indices,&indicesSizes,NULL,&names);if (elementCount>0){    const float grey[3]={0.5f,0.5f,0.5f};    for (int i=0;i<elementCount;i++)    {        simInt shapeHandle=simCreateMeshShape(2,20.0f*3.1415f/180.0f,vertices[i],                               verticesSizes[i],indices[i],indicesSizes[i],NULL);        simSetObjectName(shapeHandle,names[i]);        simSetShapeColor(shapeHandle,,sim_colorcomponent_ambient,grey);        simReleaseBuffer(names[i]);        simReleaseBuffer((simChar*)indices[i]);        simReleaseBuffer((simChar*)vertices[i]);    }    simReleaseBuffer((simChar*)names);    simReleaseBuffer((simChar*)indicesSizes);    simReleaseBuffer((simChar*)indices);    simReleaseBuffer((simChar*)verticesSizes);    simReleaseBuffer((simChar*)vertices);}fileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format and 4 for BINARY STL formatpathAndFilename: the location of the file to import.options: bit-coded: bit0 set (1): keep identical vertices, bit1 set (2): keep identical triangles, bit2 set (4): don't correct triangle windingsidenticalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesvertices: an array to vertice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowverticesSizes: an array indicating the individual vertice array sizes. The user is in charge of releasing the memory. See the example belowindices: an array to indice arrays. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. Can be NULL. See the example belowindicesSizes: an array indicating the individual indice array sizes. The user is in charge of releasing the memory. Can be NULL if indices is also NULL. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names extracted from the file. The import operation may generate several meshes depending on the fileformat. The user is in charge of releasing the memory. See the example belowUSAGE EXAMPLE:simFloat** vertices;simInt* verticesSizes;simInt** indices;simInt* indicesSizes;simChar** names;simInt elementCount=simImportMesh(1,d:\\example.dxf,0,0.0001f,1.0f,&vertices,                            &verticesSizes,&indices,&indicesSizes,NULL,&names);if (elementCount>0){    const float grey[3]={0.5f,0.5f,0.5f};    for (int i=0;i<elementCount;i++)    {        simInt shapeHandle=simCreateMeshShape(2,20.0f*3.1415f/180.0f,vertices[i],                               verticesSizes[i],indices[i],indicesSizes[i],NULL);        simSetObjectName(shapeHandle,names[i]);        simSetShapeColor(shapeHandle,,sim_colorcomponent_ambient,grey);        simReleaseBuffer(names[i]);        simReleaseBuffer((simChar*)indices[i]);        simReleaseBuffer((simChar*)vertices[i]);    }    simReleaseBuffer((simChar*)names);    simReleaseBuffer((simChar*)indicesSizes);    simReleaseBuffer((simChar*)indices);    simReleaseBuffer((simChar*)verticesSizes);    simReleaseBuffer((simChar*)vertices);} Number of imported meshes, or 0 or -1 if the operation was not successful"
    }, 
    "simx.synchronous": {
        "body": "simx.synchronous(${0:clientId})", 
        "scope": "source.lua", 
        "prefix": "simx.synchronous", 
        "description": "number returnCode= simx.synchronous(number clientId)Enables or disables the synchronous operation mode for the remote API server service that the client is connected to. The function is blocking. While in synchronous operation mode, the client application is in charge of triggering the next simulation step. Only pre-enabled remote API server services will successfully execute this function. See also simx.synchronousTrigger and this section. This is a remote API helper function. clientID: the client ID. refer to simx.start.enable: the enable state of the synchronous operation returnCode: a remote API function return code"
    }, 
    "sim.visionfloatparam_far_clipping": {
        "body": "sim.visionfloatparam_far_clipping", 
        "scope": "source.lua", 
        "prefix": "sim.visionfloatparam_far_clipping", 
        "description": "Constants"
    }, 
    "sim.combineRgbImages": {
        "body": "sim.combineRgbImages(${0:img1},${1:img1Res},${2:img2},${3:img2Res},${4:operation})", 
        "scope": "source.lua", 
        "prefix": "sim.combineRgbImages", 
        "description": "string outImg = sim.combineRgbImages(string img1,table_2 img1Res,string img2,table_2 img2Res,number operation)Combines two RGB images. See also sim.transformImage."
    }, 
    "sim.physics_newton": {
        "body": "sim.physics_newton", 
        "scope": "source.lua", 
        "prefix": "sim.physics_newton", 
        "description": "Constants"
    }, 
    "simx.removeModel": {
        "body": "simx.removeModel(${0:clientId},${1:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.removeModel", 
        "description": "number returnCode= simx.removeModel(number clientId,number objectHandle)Removes a model from the scene. See also simx.removeObject. clientID: the client ID. refer to simx.start.objectHandle: handle of the model to remove (object should be flagged as model base).operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot (or simx.opmode_blocking) returnCode: a remote API function return code"
    }, 
    "sim.vortex_joint_motorconstraintfrictionmaxforce": {
        "body": "sim.vortex_joint_motorconstraintfrictionmaxforce", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_motorconstraintfrictionmaxforce", 
        "description": "Constants"
    }, 
    "sim.handleDynamics": {
        "body": "sim.handleDynamics(${0:deltaTime})", 
        "scope": "source.lua", 
        "prefix": "sim.handleDynamics", 
        "description": "number result = sim.handleDynamics(number deltaTime)Handles the dynamics functionality in a scene. This function is not available to add-ons. deltaTime: the time that passed since the command was called last. Typically simGetSimulationTimeStep()deltaTime: the time that passed since the command was called last. Typically simGetSimulationTimeStep() -1 if operation was not successful. 0 if the sepcified physics engine could not be found, otherwise, the number of calculation steps performed by the physics engine."
    }, 
    "simRRS1.INITIALIZE": {
        "body": "simRRS1.INITIALIZE(${0:robotNumber},${1:robotPathName},${2:modulePathName},${3:manipulatorType},${4:CarrrsVersion})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.INITIALIZE", 
        "description": "int status,bitstring2 rcsHandle,int rcsRrsVersion,int rcsVersion,int numberOfMessages= simRRS1.INITIALIZE(int robotNumber,string robotPathName,string modulePathName,string manipulatorType,int CarrrsVersion)"
    }, 
    "sim.imgcomb_horizontal": {
        "body": "sim.imgcomb_horizontal", 
        "scope": "source.lua", 
        "prefix": "sim.imgcomb_horizontal", 
        "description": "Constants"
    }, 
    "sim.handle_self": {
        "body": "sim.handle_self", 
        "scope": "source.lua", 
        "prefix": "sim.handle_self", 
        "description": "Constants"
    }, 
    "simROS.publisherTreatUInt8ArrayAsString": {
        "body": "simROS.publisherTreatUInt8ArrayAsString(${0:publisherHandle})", 
        "scope": "source.lua", 
        "prefix": "simROS.publisherTreatUInt8ArrayAsString", 
        "description": "simROS.publisherTreatUInt8ArrayAsString(number publisherHandle)"
    }, 
    "simx.cmdheaderoffset_full_mem_size": {
        "body": "simx.cmdheaderoffset_full_mem_size", 
        "scope": "source.lua", 
        "prefix": "simx.cmdheaderoffset_full_mem_size", 
        "description": "Constants"
    }, 
    "sim.arrayparam_gravity": {
        "body": "sim.arrayparam_gravity", 
        "scope": "source.lua", 
        "prefix": "sim.arrayparam_gravity", 
        "description": "Constants"
    }, 
    "sim.cameraintparam_pov_focal_blur": {
        "body": "sim.cameraintparam_pov_focal_blur", 
        "scope": "source.lua", 
        "prefix": "sim.cameraintparam_pov_focal_blur", 
        "description": "Constants"
    }, 
    "sim.vortex_body_autosleepangularspeedthreshold": {
        "body": "sim.vortex_body_autosleepangularspeedthreshold", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_autosleepangularspeedthreshold", 
        "description": "Constants"
    }, 
    "sim.switchThread": {
        "body": "sim.switchThread()", 
        "scope": "source.lua", 
        "prefix": "sim.switchThread", 
        "description": "number result = sim.switchThread()Allows specifying the exact moment at which the current thread should switch to another thread. If the current script doesn't run in a thread (i.e. if it runs in the application main thread), this function has no effect. By default, V-REP doesn't use regular threads, but something similar to hybrid threads (which behave like coroutines, but can also behave like regular threads). This allows much more flexibility and execution control of the threads: each thread (except for the main or application thread) has a switch timing associated, which specifies how long the thread will run before switching to other threads. By default this value is 2 millisecond, but can be modified with sim.setThreadSwitchTiming. That timing can be shortened with sim.switchThread. Use with care when calling this function from a plugin. See also the sim.setThreadAutomaticSwitch, sim.setThreadResumeLocation and sim.setThreadIsFree functions. None 1 if the thread was switched (the current thread gave control to other threads until the next calculation pass), 0 if it was not switched (e.g. because the function was called from the main or application thread, or from a thread started by the user), or -1 in case of an error."
    }, 
    "sim.scriptattribute_executionorder": {
        "body": "sim.scriptattribute_executionorder", 
        "scope": "source.lua", 
        "prefix": "sim.scriptattribute_executionorder", 
        "description": "Constants"
    }, 
    "string.dump": {
        "body": "string.dump(${0:...})", 
        "scope": "source.lua", 
        "prefix": "string.dump", 
        "description": "5.1,5.2,5.3\n\nstring.dump (function)"
    }, 
    "sim.setNameSuffix": {
        "body": "sim.setNameSuffix(${0:nameSuffixNumber})", 
        "scope": "source.lua", 
        "prefix": "sim.setNameSuffix", 
        "description": "number result = sim.setNameSuffix(number nameSuffixNumber)Sets the name suffix adjustment number (for detailed information on this, read also the section on accessing general-type objects). In V-REP, all objects are identified by a name and a handle. When an object (scene object or general-type object) is copied at the same time as a child script, the newly created object's name will become oldName#0, should the same object be pasted another time, the next name will be oldName#1, etc.  From within a child script, retrieving object handles is performed by automatically appending a name suffix to the object name (each script gets initialized with the name suffix number of the object it is attached to). This allows to copy-paste objects and scripts without having to manually adjust the scripts (the scripts will automatically know which object they have to access based on the set name suffix). From within a script, most of the time you won't need to set the name suffix, but in some special cases you might want to temporarily disable it (e.g. myChildScript#42 (which has its name suffix automatically set to 42) copied itself together with its attached robot (myRobot#42) and now from within myChildScript#42 you want to shift myRobot#43 to avoid collision. In that case set the name suffix to 43, shift myRobot (retrieve its handle with sim.getObjectHandle(myRobot) then set the suffix back to 42). From within a script, the sim.setNameSuffix command is influencing only current script. When accessing the API from outside of a script however, the name adjustment mechanism needs to be adjusted manually (make sure you reset the name suffix to its initial state after you are done retrieving handles). Imagine you have one robot in your scene that is named robot. You can access the robot from a C/C++ application with sim.getObjectHandle(robot). If the robot is duplicated, the second robot's name will be robot#0, the third will be robot#1, etc. From within you C/C++ application you can now access all robots with the same code, you just need to adjust the name suffix number. E.g. sim.setNameSuffix(42), then sim.getObjectHandle(robot) will retrieve the handle of robot#42. Once you are done accessing objects, reset the name suffix number to -1 (sim.setNameSuffix(-1)). Setting the name suffix to -1 disables the name adjustment mechanism (default when accessing the API from outside of a script) See also the sim.getNameSuffix function. nameSuffixNumber: a number starting from -1 (-1 is for no suffix, 0 is for the 0 suffix, etc.)nameSuffixNumber: a number starting from -1 (-1 is for no suffix, 0 is for the 0 suffix, etc.) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.ik_z_constraint": {
        "body": "sim.ik_z_constraint", 
        "scope": "source.lua", 
        "prefix": "sim.ik_z_constraint", 
        "description": "Constants"
    }, 
    "sim.simulation_advancing_firstafterstop": {
        "body": "sim.simulation_advancing_firstafterstop", 
        "scope": "source.lua", 
        "prefix": "sim.simulation_advancing_firstafterstop", 
        "description": "Constants"
    }, 
    "simUI.setTitle": {
        "body": "simUI.setTitle(${0:handle},${1:title},${2:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setTitle", 
        "description": "simUI.setTitle(number handle,string title,bool suppressEvents=true)"
    }, 
    "sim.texturemap_sphere": {
        "body": "sim.texturemap_sphere", 
        "scope": "source.lua", 
        "prefix": "sim.texturemap_sphere", 
        "description": "Constants"
    }, 
    "sim.appobj_pathplanning_type": {
        "body": "sim.appobj_pathplanning_type", 
        "scope": "source.lua", 
        "prefix": "sim.appobj_pathplanning_type", 
        "description": "Constants"
    }, 
    "sim.receiveData": {
        "body": "sim.receiveData(${0:dataHeader=-1},${1:dataName=nil},${2:antennaHandle=sim_handle_self},${3:index=-1})", 
        "scope": "source.lua", 
        "prefix": "sim.receiveData", 
        "description": "string data,number senderID,number dataHeader,string dataName = sim.receiveData(number dataHeader=-1,string dataName=nil,number antennaHandle=sim_handle_self,number index=-1)Receives wireless data (in a simulation). See also sim.sendData and sim.tubeOpen. Cannot be called from add-ons.Wireless receptions can be visualized globally via the environment dialog, or individually as in following example:sim.setBoolParameter(sim.boolparam_force_show_wireless_reception,true)data=sim.receiveData(...)sim.setBoolParameter(sim.boolparam_force_show_wireless_reception,false) dataHeader: number indicating who designed the communication message. Can also be -1, in which case messages with any dataHeader will be retrieved (not recommended, unless index is different from -1). dataName: name indicating the type of message. Can be nil, in which case messages with any dataName will be retrieved (not recommended, unless index is different from -1)antennaHandle: handle of the scene object that should operate as the antenna for this reception. If sim_handle_default is specified, a reception antenna at (0,0,0) is simulated.index: zero-based index of the message to read. If -1 is indicated, the first message that matches the dataHeader and dataName is read and removed. Otherwise messages are just read.dataLength: length of the received data (if returned pointer is not NULL)senderID: identifier of the sender. Can be the handle of a script if the message was sent from a script, or can be 0 if the message was sent from the non-Lua API. Can be NULL.dataHeaderR: dataHeader of the data that was read. Can be NULL.dataNameR: dataName of the data that was read. Can be NULL. The user is in charge of releasing the buffer with simReleaseBuffer(*dataNameR).dataHeader: number indicating who designed the communication message. Can also be -1, in which case messages with any dataHeader will be retrieved (not recommended, unless index is different from -1). dataName: name indicating the type of message. Can be nil, in which case messages with any dataName will be retrieved (not recommended, unless index is different from -1)antennaHandle: handle of the scene object that should operate as the antenna for this reception. If sim_handle_default is specified, a reception antenna at (0,0,0) is simulated.index: zero-based index of the message to read. If -1 is indicated, the first message that matches the dataHeader and dataName is read and removed. Otherwise messages are just read.dataLength: length of the received data (if returned pointer is not NULL)senderID: identifier of the sender. Can be the handle of a script if the message was sent from a script, or can be 0 if the message was sent from the non-Lua API. Can be NULL.dataHeaderR: dataHeader of the data that was read. Can be NULL.dataNameR: dataName of the data that was read. Can be NULL. The user is in charge of releasing the buffer with simReleaseBuffer(*dataNameR).dataHeader: number indicating who designed the communication message. Can also be -1, in which case messages with any dataHeader will be retrieved (not recommended, unless index is different from -1). dataName: name indicating the type of message. Can be nil, in which case messages with any dataName will be retrieved (not recommended, unless index is different from -1)antennaHandle: handle of the scene object that should operate as the antenna for this reception. If sim_handle_default is specified, a reception antenna at (0,0,0) is simulated.index: zero-based index of the message to read. If -1 is indicated, the first message that matches the dataHeader and dataName is read and removed. Otherwise messages are just read.dataLength: length of the received data (if returned pointer is not NULL)senderID: identifier of the sender. Can be the handle of a script if the message was sent from a script, or can be 0 if the message was sent from the non-Lua API. Can be NULL.dataHeaderR: dataHeader of the data that was read. Can be NULL.dataNameR: dataName of the data that was read. Can be NULL. The user is in charge of releasing the buffer with simReleaseBuffer(*dataNameR).dataHeader: number indicating who designed the communication message. Can also be -1, in which case messages with any dataHeader will be retrieved (not recommended, unless index is different from -1). dataName: name indicating the type of message. Can be nil, in which case messages with any dataName will be retrieved (not recommended, unless index is different from -1)antennaHandle: handle of the scene object that should operate as the antenna for this reception. If sim_handle_default is specified, a reception antenna at (0,0,0) is simulated.index: zero-based index of the message to read. If -1 is indicated, the first message that matches the dataHeader and dataName is read and removed. Otherwise messages are just read.dataLength: length of the received data (if returned pointer is not NULL)senderID: identifier of the sender. Can be the handle of a script if the message was sent from a script, or can be 0 if the message was sent from the non-Lua API. Can be NULL.dataHeaderR: dataHeader of the data that was read. Can be NULL.dataNameR: dataName of the data that was read. Can be NULL. The user is in charge of releasing the buffer with simReleaseBuffer(*dataNameR).dataHeader: number indicating who designed the communication message. Can also be -1, in which case messages with any dataHeader will be retrieved (not recommended, unless index is different from -1). dataName: name indicating the type of message. Can be nil, in which case messages with any dataName will be retrieved (not recommended, unless index is different from -1)antennaHandle: handle of the scene object that should operate as the antenna for this reception. If sim_handle_default is specified, a reception antenna at (0,0,0) is simulated.index: zero-based index of the message to read. If -1 is indicated, the first message that matches the dataHeader and dataName is read and removed. Otherwise messages are just read.dataLength: length of the received data (if returned pointer is not NULL)senderID: identifier of the sender. Can be the handle of a script if the message was sent from a script, or can be 0 if the message was sent from the non-Lua API. Can be NULL.dataHeaderR: dataHeader of the data that was read. Can be NULL.dataNameR: dataName of the data that was read. Can be NULL. The user is in charge of releasing the buffer with simReleaseBuffer(*dataNameR).dataHeader: number indicating who designed the communication message. Can also be -1, in which case messages with any dataHeader will be retrieved (not recommended, unless index is different from -1). dataName: name indicating the type of message. Can be nil, in which case messages with any dataName will be retrieved (not recommended, unless index is different from -1)antennaHandle: handle of the scene object that should operate as the antenna for this reception. If sim_handle_default is specified, a reception antenna at (0,0,0) is simulated.index: zero-based index of the message to read. If -1 is indicated, the first message that matches the dataHeader and dataName is read and removed. Otherwise messages are just read.dataLength: length of the received data (if returned pointer is not NULL)senderID: identifier of the sender. Can be the handle of a script if the message was sent from a script, or can be 0 if the message was sent from the non-Lua API. Can be NULL.dataHeaderR: dataHeader of the data that was read. Can be NULL.dataNameR: dataName of the data that was read. Can be NULL. The user is in charge of releasing the buffer with simReleaseBuffer(*dataNameR).dataHeader: number indicating who designed the communication message. Can also be -1, in which case messages with any dataHeader will be retrieved (not recommended, unless index is different from -1). dataName: name indicating the type of message. Can be nil, in which case messages with any dataName will be retrieved (not recommended, unless index is different from -1)antennaHandle: handle of the scene object that should operate as the antenna for this reception. If sim_handle_default is specified, a reception antenna at (0,0,0) is simulated.index: zero-based index of the message to read. If -1 is indicated, the first message that matches the dataHeader and dataName is read and removed. Otherwise messages are just read.dataLength: length of the received data (if returned pointer is not NULL)senderID: identifier of the sender. Can be the handle of a script if the message was sent from a script, or can be 0 if the message was sent from the non-Lua API. Can be NULL.dataHeaderR: dataHeader of the data that was read. Can be NULL.dataNameR: dataName of the data that was read. Can be NULL. The user is in charge of releasing the buffer with simReleaseBuffer(*dataNameR).dataHeader: number indicating who designed the communication message. Can also be -1, in which case messages with any dataHeader will be retrieved (not recommended, unless index is different from -1). dataName: name indicating the type of message. Can be nil, in which case messages with any dataName will be retrieved (not recommended, unless index is different from -1)antennaHandle: handle of the scene object that should operate as the antenna for this reception. If sim_handle_default is specified, a reception antenna at (0,0,0) is simulated.index: zero-based index of the message to read. If -1 is indicated, the first message that matches the dataHeader and dataName is read and removed. Otherwise messages are just read.dataLength: length of the received data (if returned pointer is not NULL)senderID: identifier of the sender. Can be the handle of a script if the message was sent from a script, or can be 0 if the message was sent from the non-Lua API. Can be NULL.dataHeaderR: dataHeader of the data that was read. Can be NULL.dataNameR: dataName of the data that was read. Can be NULL. The user is in charge of releasing the buffer with simReleaseBuffer(*dataNameR). pointer to the received data, or NULL if no data is available or in case of an error. The user is in charge of releasing the returned buffer with simReleaseBuffer."
    }, 
    "simOMPL.setGoalCallback": {
        "body": "simOMPL.setGoalCallback(${0:taskHandle},${1:callback})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.setGoalCallback", 
        "description": "number result = simOMPL.setGoalCallback(number taskHandle,string callback)"
    }, 
    "sim.drawing_auxchannelcolor2": {
        "body": "sim.drawing_auxchannelcolor2", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_auxchannelcolor2", 
        "description": "Constants"
    }, 
    "sim.script_main_script_nonexistent": {
        "body": "sim.script_main_script_nonexistent", 
        "scope": "source.lua", 
        "prefix": "sim.script_main_script_nonexistent", 
        "description": "Constants"
    }, 
    "sim.createIkElement": {
        "body": "sim.createIkElement(${0:ikGroupHandle},${1:options},${2:intParams},${3:floatParams=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.createIkElement", 
        "description": "number result = sim.createIkElement(number ikGroupHandle,number options,table intParams,table floatParams=nil)Creates an IK element. See also sim.createIkGroup. ikGroupHandle: the handle to an IK group which will contain this IK element.options: bit-coded options:bit 0 set (1): the element is inactiveintParams: an array of 4 integer parameters:intParams[0]: the handle of the tip dummy.intParams[1]: the handle of the base object, or -1 for none (i.e. world).intParams[2]: the handle of an object that will represent an alternative base for constraint evaluation, or -1 if the the constraints should be evaluated relative the the base object.intParams[3]: the IK constraints.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the linear precision.floatParams[1]: the angular precision.floatParams[2]: the position weight.floatParams[3]: the orientation weight.reserved: reserved. Set to NULL.ikGroupHandle: the handle to an IK group which will contain this IK element.options: bit-coded options:bit 0 set (1): the element is inactiveintParams: an array of 4 integer parameters:intParams[0]: the handle of the tip dummy.intParams[1]: the handle of the base object, or -1 for none (i.e. world).intParams[2]: the handle of an object that will represent an alternative base for constraint evaluation, or -1 if the the constraints should be evaluated relative the the base object.intParams[3]: the IK constraints.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the linear precision.floatParams[1]: the angular precision.floatParams[2]: the position weight.floatParams[3]: the orientation weight.reserved: reserved. Set to NULL.ikGroupHandle: the handle to an IK group which will contain this IK element.options: bit-coded options:bit 0 set (1): the element is inactiveintParams: an array of 4 integer parameters:intParams[0]: the handle of the tip dummy.intParams[1]: the handle of the base object, or -1 for none (i.e. world).intParams[2]: the handle of an object that will represent an alternative base for constraint evaluation, or -1 if the the constraints should be evaluated relative the the base object.intParams[3]: the IK constraints.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the linear precision.floatParams[1]: the angular precision.floatParams[2]: the position weight.floatParams[3]: the orientation weight.reserved: reserved. Set to NULL.ikGroupHandle: the handle to an IK group which will contain this IK element.options: bit-coded options:bit 0 set (1): the element is inactiveintParams: an array of 4 integer parameters:intParams[0]: the handle of the tip dummy.intParams[1]: the handle of the base object, or -1 for none (i.e. world).intParams[2]: the handle of an object that will represent an alternative base for constraint evaluation, or -1 if the the constraints should be evaluated relative the the base object.intParams[3]: the IK constraints.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the linear precision.floatParams[1]: the angular precision.floatParams[2]: the position weight.floatParams[3]: the orientation weight.reserved: reserved. Set to NULL.ikGroupHandle: the handle to an IK group which will contain this IK element.options: bit-coded options:bit 0 set (1): the element is inactiveintParams: an array of 4 integer parameters:intParams[0]: the handle of the tip dummy.intParams[1]: the handle of the base object, or -1 for none (i.e. world).intParams[2]: the handle of an object that will represent an alternative base for constraint evaluation, or -1 if the the constraints should be evaluated relative the the base object.intParams[3]: the IK constraints.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the linear precision.floatParams[1]: the angular precision.floatParams[2]: the position weight.floatParams[3]: the orientation weight.reserved: reserved. Set to NULL.ikGroupHandle: the handle to an IK group which will contain this IK element.options: bit-coded options:bit 0 set (1): the element is inactiveintParams: an array of 4 integer parameters:intParams[0]: the handle of the tip dummy.intParams[1]: the handle of the base object, or -1 for none (i.e. world).intParams[2]: the handle of an object that will represent an alternative base for constraint evaluation, or -1 if the the constraints should be evaluated relative the the base object.intParams[3]: the IK constraints.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the linear precision.floatParams[1]: the angular precision.floatParams[2]: the position weight.floatParams[3]: the orientation weight.reserved: reserved. Set to NULL.ikGroupHandle: the handle to an IK group which will contain this IK element.options: bit-coded options:bit 0 set (1): the element is inactiveintParams: an array of 4 integer parameters:intParams[0]: the handle of the tip dummy.intParams[1]: the handle of the base object, or -1 for none (i.e. world).intParams[2]: the handle of an object that will represent an alternative base for constraint evaluation, or -1 if the the constraints should be evaluated relative the the base object.intParams[3]: the IK constraints.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the linear precision.floatParams[1]: the angular precision.floatParams[2]: the position weight.floatParams[3]: the orientation weight.reserved: reserved. Set to NULL.ikGroupHandle: the handle to an IK group which will contain this IK element.options: bit-coded options:bit 0 set (1): the element is inactiveintParams: an array of 4 integer parameters:intParams[0]: the handle of the tip dummy.intParams[1]: the handle of the base object, or -1 for none (i.e. world).intParams[2]: the handle of an object that will represent an alternative base for constraint evaluation, or -1 if the the constraints should be evaluated relative the the base object.intParams[3]: the IK constraints.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the linear precision.floatParams[1]: the angular precision.floatParams[2]: the position weight.floatParams[3]: the orientation weight.reserved: reserved. Set to NULL.ikGroupHandle: the handle to an IK group which will contain this IK element.options: bit-coded options:bit 0 set (1): the element is inactiveintParams: an array of 4 integer parameters:intParams[0]: the handle of the tip dummy.intParams[1]: the handle of the base object, or -1 for none (i.e. world).intParams[2]: the handle of an object that will represent an alternative base for constraint evaluation, or -1 if the the constraints should be evaluated relative the the base object.intParams[3]: the IK constraints.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the linear precision.floatParams[1]: the angular precision.floatParams[2]: the position weight.floatParams[3]: the orientation weight.reserved: reserved. Set to NULL.ikGroupHandle: the handle to an IK group which will contain this IK element.options: bit-coded options:bit 0 set (1): the element is inactiveintParams: an array of 4 integer parameters:intParams[0]: the handle of the tip dummy.intParams[1]: the handle of the base object, or -1 for none (i.e. world).intParams[2]: the handle of an object that will represent an alternative base for constraint evaluation, or -1 if the the constraints should be evaluated relative the the base object.intParams[3]: the IK constraints.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the linear precision.floatParams[1]: the angular precision.floatParams[2]: the position weight.floatParams[3]: the orientation weight.reserved: reserved. Set to NULL.ikGroupHandle: the handle to an IK group which will contain this IK element.options: bit-coded options:bit 0 set (1): the element is inactiveintParams: an array of 4 integer parameters:intParams[0]: the handle of the tip dummy.intParams[1]: the handle of the base object, or -1 for none (i.e. world).intParams[2]: the handle of an object that will represent an alternative base for constraint evaluation, or -1 if the the constraints should be evaluated relative the the base object.intParams[3]: the IK constraints.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the linear precision.floatParams[1]: the angular precision.floatParams[2]: the position weight.floatParams[3]: the orientation weight.reserved: reserved. Set to NULL.ikGroupHandle: the handle to an IK group which will contain this IK element.options: bit-coded options:bit 0 set (1): the element is inactiveintParams: an array of 4 integer parameters:intParams[0]: the handle of the tip dummy.intParams[1]: the handle of the base object, or -1 for none (i.e. world).intParams[2]: the handle of an object that will represent an alternative base for constraint evaluation, or -1 if the the constraints should be evaluated relative the the base object.intParams[3]: the IK constraints.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the linear precision.floatParams[1]: the angular precision.floatParams[2]: the position weight.floatParams[3]: the orientation weight.reserved: reserved. Set to NULL.ikGroupHandle: the handle to an IK group which will contain this IK element.options: bit-coded options:bit 0 set (1): the element is inactiveintParams: an array of 4 integer parameters:intParams[0]: the handle of the tip dummy.intParams[1]: the handle of the base object, or -1 for none (i.e. world).intParams[2]: the handle of an object that will represent an alternative base for constraint evaluation, or -1 if the the constraints should be evaluated relative the the base object.intParams[3]: the IK constraints.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the linear precision.floatParams[1]: the angular precision.floatParams[2]: the position weight.floatParams[3]: the orientation weight.reserved: reserved. Set to NULL.ikGroupHandle: the handle to an IK group which will contain this IK element.options: bit-coded options:bit 0 set (1): the element is inactiveintParams: an array of 4 integer parameters:intParams[0]: the handle of the tip dummy.intParams[1]: the handle of the base object, or -1 for none (i.e. world).intParams[2]: the handle of an object that will represent an alternative base for constraint evaluation, or -1 if the the constraints should be evaluated relative the the base object.intParams[3]: the IK constraints.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the linear precision.floatParams[1]: the angular precision.floatParams[2]: the position weight.floatParams[3]: the orientation weight.reserved: reserved. Set to NULL. -1 if operation was not successful."
    }, 
    "sim.filtercomponent_multiplywithbuffer1": {
        "body": "sim.filtercomponent_multiplywithbuffer1", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_multiplywithbuffer1", 
        "description": "Constants"
    }, 
    "sim.drawing_vertexcolors": {
        "body": "sim.drawing_vertexcolors", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_vertexcolors", 
        "description": "Constants"
    }, 
    "math.sqrt": {
        "body": "math.sqrt( ${1:x} )", 
        "scope": "source.lua", 
        "prefix": "math.sqrt", 
        "description": "5.1,5.2,5.3\n\nmath.sqrt"
    }, 
    "sim.script_lua_error": {
        "body": "sim.script_lua_error", 
        "scope": "source.lua", 
        "prefix": "sim.script_lua_error", 
        "description": "Constants"
    }, 
    "for": {
        "body": "for ${1:i}=${2:1},${3:10} do\n\t${0:print(i)}\nend", 
        "scope": "source.lua", 
        "prefix": "for", 
        "description": "for i=1,10"
    }, 
    "simx.getObjectOrientation": {
        "body": "simx.getObjectOrientation(${0:clientId},${1:objectHandle},${2:relativeToObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.getObjectOrientation", 
        "description": "number returnCode,table_3 eulerAngles= simx.getObjectOrientation(number clientId,number objectHandle,number relativeToObjectHandle)Retrieves the orientation (Euler angles) of an object. See also simx.setObjectOrientation, simx.getObjectQuaternion, simx.getObjectPosition and simx.getObjectGroupData. clientID: the client ID. refer to simx.start.objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the orientation.   Specify -1 to retrieve the absolute orientation, sim.handle_parent to   retrieve the orientation relative to the object's parent, or an object   handle relative to whose reference frame you want the orientationoperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls) returnCode: a remote API function return codeeulerAngles: the Euler angles (alpha, beta and gamma)"
    }, 
    "sim.newton_global_stepsize": {
        "body": "sim.newton_global_stepsize", 
        "scope": "source.lua", 
        "prefix": "sim.newton_global_stepsize", 
        "description": "Constants"
    }, 
    "simUI.growPlotYRange": {
        "body": "simUI.growPlotYRange(${0:handle},${1:id},${2:ymin},${3:ymax})", 
        "scope": "source.lua", 
        "prefix": "simUI.growPlotYRange", 
        "description": "simUI.growPlotYRange(number handle,number id,number ymin,number ymax)"
    }, 
    "sim.callbackid_userdefined": {
        "body": "sim.callbackid_userdefined", 
        "scope": "source.lua", 
        "prefix": "sim.callbackid_userdefined", 
        "description": "Constants"
    }, 
    "sim.createVisionSensor": {
        "body": "sim.createVisionSensor(${0:options},${1:intParams},${2:floatParams},${3:color=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.createVisionSensor", 
        "description": "number sensorHandle = sim.createVisionSensor(number options,table_4 intParams,table_11 floatParams,table_48 color=nil)Creates a vision sensor.  options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default valuesoptions: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the sensor will be in perspective operation modebit 2 set (4): the sensor volume will not be shown when not detecting anythingbit 3 set (8): the sensor volume will not be shown when detecting somethingbit 4 set (16): the sensor will be passive (use an external image)bit 5 set (32): the sensor will use local lightsbit 6 set (64): the sensor will not render any fogbit 7 set (128): the sensor will use a specific color for default background (i.e. null pixels)intParams (input): 4 integer parameters:intParams[0]: sensor resolution xintParams[1]: sensor resolution yintParams[2]: reserved. Set to 0intParams[3]: reserved. Set to 0floatParams (input): 11 floating point parameters:floatParams[0]: near clipping planefloatParams[1]: far clipping planefloatParams[2]: view angle / ortho view sizefloatParams[3]: sensor size xfloatParams[4]: sensor size yfloatParams[5]: sensor size zfloatParams[6]: null pixel red-valuefloatParams[7]: null pixel green-valuefloatParams[8]: null pixel blue-valuefloatParams[9]: reserved. Set to 0.0floatParams[10]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((sensor passive, sensor active) x (ambient_diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb)). Set the last 24 values to zero. Can be NULL for default values -1 if operation was not successful, otherwise the handle of the force sensor"
    }, 
    "sim.filtercomponent_verticalflip": {
        "body": "sim.filtercomponent_verticalflip", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_verticalflip", 
        "description": "Constants"
    }, 
    "sim.arrayparam_random_euler": {
        "body": "sim.arrayparam_random_euler", 
        "scope": "source.lua", 
        "prefix": "sim.arrayparam_random_euler", 
        "description": "Constants"
    }, 
    "math.abs": {
        "body": "math.abs( ${1:x} )", 
        "scope": "source.lua", 
        "prefix": "math.abs", 
        "description": "5.1,5.2,5.3\n\nmath.abs"
    }, 
    "sim.boolparam_objectshift_toolbarbutton_enabled": {
        "body": "sim.boolparam_objectshift_toolbarbutton_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_objectshift_toolbarbutton_enabled", 
        "description": "Constants"
    }, 
    "sim.handleDistance": {
        "body": "sim.handleDistance(${0:distanceObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.handleDistance", 
        "description": "number result,number smallestDistance = sim.handleDistance(number distanceObjectHandle)Handles (measures distances, etc.) a registered distance object. Distance objects can be registered while editing a scene. See also sim.readDistance, sim.resetDistance and sim.checkDistance. distanceObjectHandle: handle of the distance object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all registered distance objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)smallestDistance: smallest measured distance. Can be NULLdistanceObjectHandle: handle of the distance object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all registered distance objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)smallestDistance: smallest measured distance. Can be NULLdistanceObjectHandle: handle of the distance object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all registered distance objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)smallestDistance: smallest measured distance. Can be NULL 1 if at least one distance was measured, 0 if no distance was measured, -1 in case of an error"
    }, 
    "simSDF.dump": {
        "body": "simSDF.dump(${0:fileName})", 
        "scope": "source.lua", 
        "prefix": "simSDF.dump", 
        "description": "simSDF.dump(string fileName)"
    }, 
    "simROS.advertiseService": {
        "body": "simROS.advertiseService(${0:serviceName},${1:serviceType},${2:serviceCallback})", 
        "scope": "source.lua", 
        "prefix": "simROS.advertiseService", 
        "description": "number serviceServerHandle = simROS.advertiseService(string serviceName,string serviceType,string serviceCallback)"
    }, 
    "sim.groupShapes": {
        "body": "sim.groupShapes(${0:shapeHandles})", 
        "scope": "source.lua", 
        "prefix": "sim.groupShapes", 
        "description": "number shapeHandle = sim.groupShapes(table shapeHandles)Groups (or merges) several shapes into a compound shape (or simple shape). See also sim.ungroupShape. shapeHandles: the handles of the shapes you wish to groupshapeCount: the size of the shapeHandles array. A negative number indicates that we want to merge the shapes instead of grouping them.shapeHandles: the handles of the shapes you wish to groupshapeCount: the size of the shapeHandles array. A negative number indicates that we want to merge the shapes instead of grouping them.shapeHandles: the handles of the shapes you wish to groupshapeCount: the size of the shapeHandles array. A negative number indicates that we want to merge the shapes instead of grouping them. -1 if operation was not successful. Otherwise the handle of the resulting compound shape."
    }, 
    "simUI.insertComboboxItem": {
        "body": "simUI.insertComboboxItem(${0:handle},${1:id},${2:index},${3:text},${4:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.insertComboboxItem", 
        "description": "simUI.insertComboboxItem(number handle,number id,number index,string text,bool suppressEvents=true)"
    }, 
    "simx.setJointTargetVelocity": {
        "body": "simx.setJointTargetVelocity(${0:clientId},${1:jointHandle},${2:targetVelocity})", 
        "scope": "source.lua", 
        "prefix": "simx.setJointTargetVelocity", 
        "description": "number returnCode= simx.setJointTargetVelocity(number clientId,number jointHandle,number targetVelocity)Sets the intrinsic target velocity of a non-spherical joint. This command makes only sense when the joint mode is in torque/force mode: the dynamics functionality and the joint motor have to be enabled (position control should however be disabled) clientID: the client ID. refer to simx.start.jointHandle: handle of the jointtargetVelocity: target velocity of the joint (linear or angular velocity depending on the joint-type)operationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_oneshot or simx.opmode_streaming returnCode: a remote API function return code"
    }, 
    "sim.setArrayParameter": {
        "body": "sim.setArrayParameter(${0:parameter},${1:arrayOfValues})", 
        "scope": "source.lua", 
        "prefix": "sim.setArrayParameter", 
        "description": "number result = sim.setArrayParameter(number parameter,table arrayOfValues)Sets 3 values of an array parameter. See also sim.getArrayParameter, sim.setBoolParameter, sim.setInt32Parameter and sim.setFloatParameter. parameter: array parameter identifierparameterValues: array of 3 simFloat values related to the parameter (simVoid is kept for backward compatibility).parameter: array parameter identifierparameterValues: array of 3 simFloat values related to the parameter (simVoid is kept for backward compatibility).parameter: array parameter identifierparameterValues: array of 3 simFloat values related to the parameter (simVoid is kept for backward compatibility). -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.lightintparam_pov_casts_shadows": {
        "body": "sim.lightintparam_pov_casts_shadows", 
        "scope": "source.lua", 
        "prefix": "sim.lightintparam_pov_casts_shadows", 
        "description": "Constants"
    }, 
    "simx.eraseFile": {
        "body": "simx.eraseFile(${0:clientId},${1:fileName_serverSide})", 
        "scope": "source.lua", 
        "prefix": "simx.eraseFile", 
        "description": "number returnCode= simx.eraseFile(number clientId,string fileName_serverSide)Erases a file on the server side. This function is used by several other functions internally (e.g. simx.loadModel). See also simx.transferFile. This is a remote API helper function. clientID: the client ID. refer to simx.start.fileName_serverSide: the file to erase on the server side. For now, do not specify a path (the file will be erased in the remote API plugin directory)operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "sim.navigation_camerarotate": {
        "body": "sim.navigation_camerarotate", 
        "scope": "source.lua", 
        "prefix": "sim.navigation_camerarotate", 
        "description": "Constants"
    }, 
    "simUI.getNodeText": {
        "body": "simUI.getNodeText(${0:handle},${1:id},${2:nodeId})", 
        "scope": "source.lua", 
        "prefix": "simUI.getNodeText", 
        "description": "string text = simUI.getNodeText(number handle,number id,number nodeId)"
    }, 
    "sim.jointmode_ikdependent": {
        "body": "sim.jointmode_ikdependent", 
        "scope": "source.lua", 
        "prefix": "sim.jointmode_ikdependent", 
        "description": "Constants"
    }, 
    "sim.modelproperty_not_respondable": {
        "body": "sim.modelproperty_not_respondable", 
        "scope": "source.lua", 
        "prefix": "sim.modelproperty_not_respondable", 
        "description": "Constants"
    }, 
    "sim.getRealTimeSimulation": {
        "body": "sim.getRealTimeSimulation()", 
        "scope": "source.lua", 
        "prefix": "sim.getRealTimeSimulation", 
        "description": "number result = sim.getRealTimeSimulation()Indicates whether the simulation is real-time. See also simIsRealTimeSimulationStepNeeded and simAdjustRealTimeTimer. None 1 if simulation is real-time, 0 if it is not, and -1 if the operation was not successful"
    }, 
    "sim.getFloatSignal": {
        "body": "sim.getFloatSignal(${0:signalName})", 
        "scope": "source.lua", 
        "prefix": "sim.getFloatSignal", 
        "description": "number signalValue = sim.getFloatSignal(string signalName)Gets the value of a float signal. Signals are cleared at simulation start.  See also sim.setFloatSignal, the other signal functions,  and sim.persistentDataRead. signalName: name of the signalsignalValue: value of the signalsignalName: name of the signalsignalValue: value of the signalsignalName: name of the signalsignalValue: value of the signal -1 if operation was not successful, 0 if signal does not exist, 1 if signalValue was retrieved"
    }, 
    "math.modf": {
        "body": "math.modf( ${1:x} )", 
        "scope": "source.lua", 
        "prefix": "math.modf", 
        "description": "5.1,5.2,5.3\n\nmath.modf"
    }, 
    "sim.message_model_loaded": {
        "body": "sim.message_model_loaded", 
        "scope": "source.lua", 
        "prefix": "sim.message_model_loaded", 
        "description": "Constants"
    }, 
    "simCHAI3D.addShape": {
        "body": "simCHAI3D.addShape(${0:vertices},${1:indices},${2:position},${3:orientation},${4:stiffnessFactor})", 
        "scope": "source.lua", 
        "prefix": "simCHAI3D.addShape", 
        "description": "number objectID = simCHAI3D.addShape(table vertices,table indices,table_3 position,table_3 orientation,number stiffnessFactor)"
    }, 
    "sim.unpackFloatTable": {
        "body": "sim.unpackFloatTable(${0:data},${1:startFloatIndex=0},${2:floatCount=0},${3:additionalByteOffset=0})", 
        "scope": "source.lua", 
        "prefix": "sim.unpackFloatTable", 
        "description": "table floatNumbers = sim.unpackFloatTable(string data,number startFloatIndex=0,number floatCount=0,number additionalByteOffset=0)Unpacks a string (or part of it) into a table of floating-point numbers. See also sim.packFloatTable and the other packing/unpacking functions. - -"
    }, 
    "simCHAI3D.readButtons": {
        "body": "simCHAI3D.readButtons(${0:deviceIndex})", 
        "scope": "source.lua", 
        "prefix": "simCHAI3D.readButtons", 
        "description": "number buttons = simCHAI3D.readButtons(number deviceIndex)"
    }, 
    "bit32.rshift": {
        "body": "bit32.rshift(${0:...})", 
        "scope": "source.lua", 
        "prefix": "bit32.rshift", 
        "description": "5.2\n\nbit32.rshift (x, disp)"
    }, 
    "sim.banner_clickselectsparent": {
        "body": "sim.banner_clickselectsparent", 
        "scope": "source.lua", 
        "prefix": "sim.banner_clickselectsparent", 
        "description": "Constants"
    }, 
    "sim.displayattribute_originalcolors": {
        "body": "sim.displayattribute_originalcolors", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_originalcolors", 
        "description": "Constants"
    }, 
    "sim.getIntegerSignal": {
        "body": "sim.getIntegerSignal(${0:signalName})", 
        "scope": "source.lua", 
        "prefix": "sim.getIntegerSignal", 
        "description": "number signalValue = sim.getIntegerSignal(string signalName)Gets the value of an integer signal. Signals are cleared at simulation start.  See also sim.setIntegerSignal, the other signal functions,  and sim.persistentDataRead. signalName: name of the signalsignalValue: value of the signalsignalName: name of the signalsignalValue: value of the signalsignalName: name of the signalsignalValue: value of the signal -1 if operation was not successful, 0 if signal does not exist, 1 if signalValue was retrieved"
    }, 
    "sim.vortex_body_seclinearaxisstaticfrictionscale": {
        "body": "sim.vortex_body_seclinearaxisstaticfrictionscale", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_seclinearaxisstaticfrictionscale", 
        "description": "Constants"
    }, 
    "sim.objintparam_collection_self_collision_indicator": {
        "body": "sim.objintparam_collection_self_collision_indicator", 
        "scope": "source.lua", 
        "prefix": "sim.objintparam_collection_self_collision_indicator", 
        "description": "Constants"
    }, 
    "sim.modifyGhost": {
        "body": "sim.modifyGhost(${0:ghostGroup},${1:ghostId},${2:operation},${3:floatValue},${4:options=nil},${5:optionsMask=nil},${6:colorOrTransformation=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.modifyGhost", 
        "description": "number result = sim.modifyGhost(number ghostGroup,number ghostId,number operation,number floatValue,number options=nil,number optionsMask=nil,table colorOrTransformation=nil)Modifies or removes a ghost object previously added with sim.addGhost. ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13.ghostGroup: an identifier that allows, together with ghostId, identifying which ghosts to modify.ghostId: an identifier that allows, together with ghostGroup, identifying which ghosts to modify. If -1, then all ghosts that match ghostGroup will be modified.operation: a value indicating the operation to perform:0: no operation is performed, and the return value indicates the number of ghosts that match the identifiers.1: removes the specified ghosts. The return value indicates the number of removed ghosts.2: sets the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.3: sets the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.4: shifts the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.5: shifts the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.6: shifts the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.7: scales the start time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.8: scales the end time (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.9: scales the start and end times (via floatValue) of the specified ghosts. The return value indicates the number of modified ghosts.10: modifies the attributes (via options and optionsMask) of the specified ghosts. The return value indicates the number of modified ghosts.11: pre-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.12: post-multiplies (via colorOrTransformation) the transformations of the specified ghosts. The return value indicates the number of modified ghosts.13: modifies (via colorOrTransformation) the color of the specified ghosts. The return value indicates the number of modified ghosts.14: sets the transparency factor (via floatValue) of the specified ghosts. Only ghosts with custom colors will be influenced. The return value indicates the number of modified ghosts.floatValue: a floating point value that is used to modify the specified ghosts. See operation here above.options: the attributes used to modify the specified ghosts (see operation here above). Attributes are bit-coded:bit0 reservedbit1 set (2)=the provided start- and end-times will be played-back in real-timebit2 set (4)=preserve the original colorsbit3 reservedbit4 set (16)=create an invisible ghostbit5 set (32)=backface culling for the ghost (only when using custom colors)optionsMask: a mask allowing to select options to set.colorOrTransformation: a pointer to 7 or 12 float values: when operation is 11 or 12, 7 values indicating a transformation should be provided (x,y,z,qx,qy,qz,qw). when operation is 13, 12 values indicating a color should be provided (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL when operation is different from 11, 12 or 13. -1 if operation was not successful, otherwise a value depending on the operation performed."
    }, 
    "sim.loadScene": {
        "body": "sim.loadScene(${0:filename})", 
        "scope": "source.lua", 
        "prefix": "sim.loadScene", 
        "description": "number result = sim.loadScene(string filename)Loads a previously saved scene. If current scene is not empty, a new scene will be created before switching to it and loading the scene. See also sim.saveScene, sim.loadModel, simCloseScene and sim.setBoolParameter with sim.boolparam_scene_and_model_load_messages.  filename: scene filename. The filename extension is required (ttt)filename: scene filename. The filename extension is required (ttt) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simOMPL.Algorithm.KPIECE1": {
        "body": "simOMPL.Algorithm.KPIECE1", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.KPIECE1", 
        "description": "Constants"
    }, 
    "sim.distcalcmethod_dl_if_nonzero": {
        "body": "sim.distcalcmethod_dl_if_nonzero", 
        "scope": "source.lua", 
        "prefix": "sim.distcalcmethod_dl_if_nonzero", 
        "description": "Constants"
    }, 
    "simx.opmode_oneshot": {
        "body": "simx.opmode_oneshot", 
        "scope": "source.lua", 
        "prefix": "simx.opmode_oneshot", 
        "description": "Constants"
    }, 
    "sysCall_threadmain": {
        "body": "sysCall_threadmain(${0:script.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_threadmain", 
        "description": "sysCall_threadmain(Main function of a threaded child script.)"
    }, 
    "sim.buttonproperty_enabled": {
        "body": "sim.buttonproperty_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.buttonproperty_enabled", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_error_b": {
        "body": "sim.jointfloatparam_error_b", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_error_b", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_error_a": {
        "body": "sim.jointfloatparam_error_a", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_error_a", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_error_g": {
        "body": "sim.jointfloatparam_error_g", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_error_g", 
        "description": "Constants"
    }, 
    "sim.dummy_linktype_ik_tip_target": {
        "body": "sim.dummy_linktype_ik_tip_target", 
        "scope": "source.lua", 
        "prefix": "sim.dummy_linktype_ik_tip_target", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_error_z": {
        "body": "sim.jointfloatparam_error_z", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_error_z", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_error_y": {
        "body": "sim.jointfloatparam_error_y", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_error_y", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_error_x": {
        "body": "sim.jointfloatparam_error_x", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_error_x", 
        "description": "Constants"
    }, 
    "sim.waitForSignal": {
        "body": "sim.waitForSignal(${0:signalName})", 
        "scope": "source.lua", 
        "prefix": "sim.waitForSignal", 
        "description": "number/string signalValue = sim.waitForSignal(string signalName)Waits for a signal. Signals are cleared at simulation start. This function will first check whether an integer signal with that name is present, then if a float signal with that name is present and finally if a string signal with that name is present. The function only returns when the signal is present (defined). This function can only be called from child scripts running in a thread (since this is a blocking operation) and is not available from the C-API. See also the other signal functions and sim.wait. - -"
    }, 
    "sim.shapeintparam_culling": {
        "body": "sim.shapeintparam_culling", 
        "scope": "source.lua", 
        "prefix": "sim.shapeintparam_culling", 
        "description": "Constants"
    }, 
    "sim.appobj_texture_type": {
        "body": "sim.appobj_texture_type", 
        "scope": "source.lua", 
        "prefix": "sim.appobj_texture_type", 
        "description": "Constants"
    }, 
    "sim.getLinkDummy": {
        "body": "sim.getLinkDummy(${0:dummyHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getLinkDummy", 
        "description": "number linkDummyHandle = sim.getLinkDummy(number dummyHandle)Retrieves the object handle of the dummy linked to this one. See also sim.setLinkDummy. dummyHandle: handle of the dummy whose linked dummy has to be retrieved.dummyHandle: handle of the dummy whose linked dummy has to be retrieved. Handle of the dummy linked to the specified dummy object, or -1 if the dummy is not linked or in case of an error"
    }, 
    "sim.filtercomponent_3x3filter": {
        "body": "sim.filtercomponent_3x3filter", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_3x3filter", 
        "description": "Constants"
    }, 
    "sim.scriptthreadresume_actuation_last": {
        "body": "sim.scriptthreadresume_actuation_last", 
        "scope": "source.lua", 
        "prefix": "sim.scriptthreadresume_actuation_last", 
        "description": "Constants"
    }, 
    "simUI.setComboboxItems": {
        "body": "simUI.setComboboxItems(${0:handle},${1:id},${2:items},${3:index},${4:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setComboboxItems", 
        "description": "simUI.setComboboxItems(number handle,number id,table items,number index,bool suppressEvents=true)"
    }, 
    "sim.light_spot_subtype": {
        "body": "sim.light_spot_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.light_spot_subtype", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_edge": {
        "body": "sim.filtercomponent_edge", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_edge", 
        "description": "Constants"
    }, 
    "pcall": {
        "body": "pcall(${0:...})", 
        "scope": "source.lua", 
        "prefix": "pcall", 
        "description": "5.1,5.2,5.3\n\npcall (f, arg1, ...)"
    }, 
    "sim.getDialogInput": {
        "body": "sim.getDialogInput(${0:genericDlgHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getDialogInput", 
        "description": "string input = sim.getDialogInput(number genericDlgHandle)Queries the text of the edit box of a generic dialog box of style sim_dlgstyle_input. To be used after sim.displayDialog was called and after sim.getDialogResult returned sim.dlgret_ok genericDialogHandle: handle of the generic dialoggenericDialogHandle: handle of the generic dialog Pointer to a text buffer or NULL in case of an error. The user is in charge of releasing the returned string with simReleaseBuffer."
    }, 
    "sim.pure_primitive_cone": {
        "body": "sim.pure_primitive_cone", 
        "scope": "source.lua", 
        "prefix": "sim.pure_primitive_cone", 
        "description": "Constants"
    }, 
    "sim.cameraintparam_disabled_light_components": {
        "body": "sim.cameraintparam_disabled_light_components", 
        "scope": "source.lua", 
        "prefix": "sim.cameraintparam_disabled_light_components", 
        "description": "Constants"
    }, 
    "sim.drawing_discpoints": {
        "body": "sim.drawing_discpoints", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_discpoints", 
        "description": "Constants"
    }, 
    "sim.distcalcmethod_dac_if_nonzero": {
        "body": "sim.distcalcmethod_dac_if_nonzero", 
        "scope": "source.lua", 
        "prefix": "sim.distcalcmethod_dac_if_nonzero", 
        "description": "Constants"
    }, 
    "sim.displayattribute_dynamiccontentonly": {
        "body": "sim.displayattribute_dynamiccontentonly", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_dynamiccontentonly", 
        "description": "Constants"
    }, 
    "simUI.setPlotRanges": {
        "body": "simUI.setPlotRanges(${0:handle},${1:id},${2:xmin},${3:xmax},${4:ymin},${5:ymax})", 
        "scope": "source.lua", 
        "prefix": "simUI.setPlotRanges", 
        "description": "simUI.setPlotRanges(number handle,number id,number xmin,number xmax,number ymin,number ymax)"
    }, 
    "sim.handleflag_resetforce": {
        "body": "sim.handleflag_resetforce", 
        "scope": "source.lua", 
        "prefix": "sim.handleflag_resetforce", 
        "description": "Constants"
    }, 
    "sim.banner_overlay": {
        "body": "sim.banner_overlay", 
        "scope": "source.lua", 
        "prefix": "sim.banner_overlay", 
        "description": "Constants"
    }, 
    "sim.newton_global_multithreading": {
        "body": "sim.newton_global_multithreading", 
        "scope": "source.lua", 
        "prefix": "sim.newton_global_multithreading", 
        "description": "Constants"
    }, 
    "simOMPL.Algorithm.CForest": {
        "body": "simOMPL.Algorithm.CForest", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.CForest", 
        "description": "Constants"
    }, 
    "simx.writeStringStream": {
        "body": "simx.writeStringStream(${0:clientId},${1:signalName},${2:signalValueToAppend})", 
        "scope": "source.lua", 
        "prefix": "simx.writeStringStream", 
        "description": "number returnCode= simx.writeStringStream(number clientId,string signalName,string signalValueToAppend)Appends a string to a string signal. If that signal is not yet present, it is added. To pack/unpack integers/floats into/from a string, refer to simx.packInts, simx.packFloats, simx.unpackInts and simx.unpackFloats. See also simx.readStringStream. clientID: the client ID. refer to simx.start.signalName: name of the signalsignalValueToAppend: value to append to the signal. That value may contain any value, including embedded zeros.operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "sim.getObjectType": {
        "body": "sim.getObjectType(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectType", 
        "description": "number objectType = sim.getObjectType(number objectHandle)Retrieves the type of an object  objectHandle: handle of the objectobjectHandle: handle of the object type of the object (sim_object_shape_type, sim_object_joint_type, etc. (see the object types) or -1 in case of error"
    }, 
    "simOMPL.createTask": {
        "body": "simOMPL.createTask(${0:name})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.createTask", 
        "description": "number taskHandle = simOMPL.createTask(string name)"
    }, 
    "simK3.setVelocity": {
        "body": "simK3.setVelocity(${0:k3Handle},${1:leftVelocity},${2:rightVelocity})", 
        "scope": "source.lua", 
        "prefix": "simK3.setVelocity", 
        "description": "boolean result = simK3.setVelocity(number k3Handle,number leftVelocity,number rightVelocity)"
    }, 
    "fori": {
        "body": "for ${1:i},${2:v} in ipairs(${3:table_name}) do\n\t${0:print(i,v)}\nend", 
        "scope": "source.lua", 
        "prefix": "fori", 
        "description": "for i,v in ipairs()"
    }, 
    "simRRS1.TERMINATE": {
        "body": "simRRS1.TERMINATE()", 
        "scope": "source.lua", 
        "prefix": "simRRS1.TERMINATE", 
        "description": "int status= simRRS1.TERMINATE()"
    }, 
    "sim.handle_all_except_explicit": {
        "body": "sim.handle_all_except_explicit", 
        "scope": "source.lua", 
        "prefix": "sim.handle_all_except_explicit", 
        "description": "Constants"
    }, 
    "simUI.setRowHeight": {
        "body": "simUI.setRowHeight(${0:handle},${1:id},${2:row},${3:min_size},${4:max_size})", 
        "scope": "source.lua", 
        "prefix": "simUI.setRowHeight", 
        "description": "simUI.setRowHeight(number handle,number id,number row,number min_size,number max_size)"
    }, 
    "sim.jointmode_force": {
        "body": "sim.jointmode_force", 
        "scope": "source.lua", 
        "prefix": "sim.jointmode_force", 
        "description": "Constants"
    }, 
    "simUI.mouse.left_button_up": {
        "body": "simUI.mouse.left_button_up", 
        "scope": "source.lua", 
        "prefix": "simUI.mouse.left_button_up", 
        "description": "Constants"
    }, 
    "sim.handleflag_togglevisibility": {
        "body": "sim.handleflag_togglevisibility", 
        "scope": "source.lua", 
        "prefix": "sim.handleflag_togglevisibility", 
        "description": "Constants"
    }, 
    "sim.setObjectOrientation": {
        "body": "sim.setObjectOrientation(${0:objectHandle},${1:relativeToObjectHandle},${2:eulerAngles})", 
        "scope": "source.lua", 
        "prefix": "sim.setObjectOrientation", 
        "description": "number result = sim.setObjectOrientation(number objectHandle,number relativeToObjectHandle,table_3 eulerAngles)Sets the orientation (Euler angles) of an object. Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling sim.resetDynamicObject just before). See also sim.setObjectQuaternion, sim.getObjectOrientation, sim.setObjectPosition, sim.setObjectMatrix and the other matrix/transformation functions. objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the orientation is specified. Specify -1 to set the absolute orientation, sim_handle_parent to set the orientation relative to the object's parent, or an object handle relative to whose reference frame the orientation is specified.eulerAngles: Euler angles (alpha, beta and gamma)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the orientation is specified. Specify -1 to set the absolute orientation, sim_handle_parent to set the orientation relative to the object's parent, or an object handle relative to whose reference frame the orientation is specified.eulerAngles: Euler angles (alpha, beta and gamma)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the orientation is specified. Specify -1 to set the absolute orientation, sim_handle_parent to set the orientation relative to the object's parent, or an object handle relative to whose reference frame the orientation is specified.eulerAngles: Euler angles (alpha, beta and gamma)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the orientation is specified. Specify -1 to set the absolute orientation, sim_handle_parent to set the orientation relative to the object's parent, or an object handle relative to whose reference frame the orientation is specified.eulerAngles: Euler angles (alpha, beta and gamma) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.objfloatparam_objbbox_max_z": {
        "body": "sim.objfloatparam_objbbox_max_z", 
        "scope": "source.lua", 
        "prefix": "sim.objfloatparam_objbbox_max_z", 
        "description": "Constants"
    }, 
    "sim.objfloatparam_objbbox_max_y": {
        "body": "sim.objfloatparam_objbbox_max_y", 
        "scope": "source.lua", 
        "prefix": "sim.objfloatparam_objbbox_max_y", 
        "description": "Constants"
    }, 
    "sim.objfloatparam_objbbox_max_x": {
        "body": "sim.objfloatparam_objbbox_max_x", 
        "scope": "source.lua", 
        "prefix": "sim.objfloatparam_objbbox_max_x", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_imagetocoord": {
        "body": "sim.filtercomponent_imagetocoord", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_imagetocoord", 
        "description": "Constants"
    }, 
    "os.setlocale": {
        "body": "os.setlocale(${0:...})", 
        "scope": "source.lua", 
        "prefix": "os.setlocale", 
        "description": "5.1,5.2,5.3\n\nos.setlocale (locale [, category])"
    }, 
    "sim.vortex_body_secangaxissameasprimangaxis": {
        "body": "sim.vortex_body_secangaxissameasprimangaxis", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_secangaxissameasprimangaxis", 
        "description": "Constants"
    }, 
    "simRemoteApi.status": {
        "body": "simRemoteApi.status()", 
        "scope": "source.lua", 
        "prefix": "simRemoteApi.status", 
        "description": "number status,table_5 info,number version,number clientVersion,string connectedIp= simRemoteApi.status()"
    }, 
    "forp": {
        "body": "for ${1:k},${2:v} in pairs(${3:table_name}) do\n\t${0:print(k,v)}\nend", 
        "scope": "source.lua", 
        "prefix": "forp", 
        "description": "for k,v in pairs()"
    }, 
    "sysCall_beforeCopy": {
        "body": "sysCall_beforeCopy(${0:operation).},${1:keys.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_beforeCopy", 
        "description": "sysCall_beforeCopy(called just before objects are copied (in an object copy/cut operation, or a model save operation).,Arg1 is a map with 'objectHandles' keys.)"
    }, 
    "sim.banner_left": {
        "body": "sim.banner_left", 
        "scope": "source.lua", 
        "prefix": "sim.banner_left", 
        "description": "Constants"
    }, 
    "loadstring": {
        "body": "loadstring(${0:...})", 
        "scope": "source.lua", 
        "prefix": "loadstring", 
        "description": "5.1\n\nloadstring (string [, chunkname])"
    }, 
    "simVision.handleVelodyneHDL64E": {
        "body": "simVision.handleVelodyneHDL64E(${0:velodyneHandle})", 
        "scope": "source.lua", 
        "prefix": "simVision.handleVelodyneHDL64E", 
        "description": "table points= simVision.handleVelodyneHDL64E(number velodyneHandle)"
    }, 
    "simx.readDistance": {
        "body": "simx.readDistance(${0:clientId},${1:distanceObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.readDistance", 
        "description": "number returnCode,number minimumDistance= simx.readDistance(number clientId,number distanceObjectHandle)Reads the distance that a  registered distance object measured. This function doesn't perform minimum distance calculation, it merely reads the result from a previous call to sim.handleDistance (sim.handleDistance is called in the default main script). See also simx.getObjectGroupData. clientID: the client ID. refer to simx.start.distanceObjectHandle: handle of the distance objectoperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls) returnCode: a remote API function return codeminimumDistance: the minimum distance.  If the distance object wasn't handled yet, the distance value will be larger than 1e36."
    }, 
    "sim.readTexture": {
        "body": "sim.readTexture(${0:textureId},${1:options},${2:posX=0},${3:posY=0},${4:sizeX=0},${5:sizeY=0})", 
        "scope": "source.lua", 
        "prefix": "sim.readTexture", 
        "description": "string textureData = sim.readTexture(number textureId,number options,number posX=0,number posY=0,number sizeX=0,number sizeY=0)Retrieves the RGB data (or a portion of it) related to a specific texture. See also sim.getTextureId, sim.writeTexture and sim.createTexture. textureId: the ID of the texture. See also simGetTextureId.options: reserved for future functionality. Set to zero.posX / posY: the x/y position of the texture portion to retrieve. Set to 0/0 to retrieve the full texturesizeX / sizeY: the x/y size of the texture portion to retrieve. Set to 0/0 to retrieve the full texturetextureId: the ID of the texture. See also simGetTextureId.options: reserved for future functionality. Set to zero.posX / posY: the x/y position of the texture portion to retrieve. Set to 0/0 to retrieve the full texturesizeX / sizeY: the x/y size of the texture portion to retrieve. Set to 0/0 to retrieve the full texturetextureId: the ID of the texture. See also simGetTextureId.options: reserved for future functionality. Set to zero.posX / posY: the x/y position of the texture portion to retrieve. Set to 0/0 to retrieve the full texturesizeX / sizeY: the x/y size of the texture portion to retrieve. Set to 0/0 to retrieve the full texturetextureId: the ID of the texture. See also simGetTextureId.options: reserved for future functionality. Set to zero.posX / posY: the x/y position of the texture portion to retrieve. Set to 0/0 to retrieve the full texturesizeX / sizeY: the x/y size of the texture portion to retrieve. Set to 0/0 to retrieve the full texture The texture data, or NULL in case of an error. The texture data contains RGB values between 0-255 (3 bytes per pixel). The user is in charge of releasing the returned buffer with simReleaseBuffer."
    }, 
    "os.clock": {
        "body": "os.clock(${0:...})", 
        "scope": "source.lua", 
        "prefix": "os.clock", 
        "description": "5.1,5.2,5.3\n\nos.clock ()"
    }, 
    "sim.addParticleObjectItem": {
        "body": "sim.addParticleObjectItem(${0:particleObjectHandle},${1:itemData})", 
        "scope": "source.lua", 
        "prefix": "sim.addParticleObjectItem", 
        "description": "number result = sim.addParticleObjectItem(number particleObjectHandle,table itemData)Adds an item (or clears all items) to a previously inserted particle object. See also sim.addParticleObject and sim.removeParticleObject objectHandle: handle of a previously added particle objectitemData: data relative to an item. All items (particles) require at least 6 values:\u00a0p1x, p1y, p1z, p2x, p2y, p2z with p1 is the particle start position, p2-p1 is the particle initial velocity vector. Auxiliary values might be required depending on the particle object attributes. See the particle object type combined with attributes for more information. If NULL the particle object is emptied of all its itemsobjectHandle: handle of a previously added particle objectitemData: data relative to an item. All items (particles) require at least 6 values:\u00a0p1x, p1y, p1z, p2x, p2y, p2z with p1 is the particle start position, p2-p1 is the particle initial velocity vector. Auxiliary values might be required depending on the particle object attributes. See the particle object type combined with attributes for more information. If NULL the particle object is emptied of all its itemsobjectHandle: handle of a previously added particle objectitemData: data relative to an item. All items (particles) require at least 6 values:\u00a0p1x, p1y, p1z, p2x, p2y, p2z with p1 is the particle start position, p2-p1 is the particle initial velocity vector. Auxiliary values might be required depending on the particle object attributes. See the particle object type combined with attributes for more information. If NULL the particle object is emptied of all its items -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "debug.getinfo": {
        "body": "debug.getinfo( ${1:[thread],}${2:f}${3:[, what]} )", 
        "scope": "source.lua", 
        "prefix": "debug.getinfo", 
        "description": "5.1,5.2,5.3\n\ndebug.getinfo ([thread,] f [, what])"
    }, 
    "file:write": {
        "body": "file:write(${0:...})", 
        "scope": "source.lua", 
        "prefix": "file:write", 
        "description": "5.1,5.2,5.3\n\nfile:write (...)"
    }, 
    "sim.proxintparam_entity_to_detect": {
        "body": "sim.proxintparam_entity_to_detect", 
        "scope": "source.lua", 
        "prefix": "sim.proxintparam_entity_to_detect", 
        "description": "Constants"
    }, 
    "simVision.destroyVelodyneVPL16": {
        "body": "simVision.destroyVelodyneVPL16()", 
        "scope": "source.lua", 
        "prefix": "simVision.destroyVelodyneVPL16", 
        "description": "number result= simVision.destroyVelodyneVPL16()"
    }, 
    "simOMPL.setStartState": {
        "body": "simOMPL.setStartState(${0:taskHandle},${1:state})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.setStartState", 
        "description": "number result = simOMPL.setStartState(number taskHandle,table state)"
    }, 
    "sim.getScriptHandle": {
        "body": "sim.getScriptHandle(${0:scriptName=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.getScriptHandle", 
        "description": "number scriptHandle = sim.getScriptHandle(string scriptName=nil)Retrieves the handle of a script. The operation of this function depends on the current name suffix settings (see sim.getNameSuffix, sim.setNameSuffix, and the section on accessing general-type objects). A script doesn't directly have a name assigned, however the script inherits the name of its associated object, if it has one. See also sim.isHandleValid. scriptName: name of the script. The name of a child script. If the name is left blank, the handle of the main script is retrieved. In order to retrieve the handle of a customization script, use following scriptName prefix: customization@ (for instance, customization@objectName)scriptName: name of the script. The name of a child script. If the name is left blank, the handle of the main script is retrieved. In order to retrieve the handle of a customization script, use following scriptName prefix: customization@ (for instance, customization@objectName) handle of the script if operation was successful, -1 otherwise"
    }, 
    "sim.getObjectQuaternion": {
        "body": "sim.getObjectQuaternion(${0:objectHandle},${1:relativeToObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectQuaternion", 
        "description": "table_4 quaternion = sim.getObjectQuaternion(number objectHandle,number relativeToObjectHandle)Retrieves the quaternion (x,y,z,w) of an object. See also sim.getObjectOrientation, sim.getObjectMatrix and the other matrix/transformation functions. objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the orientation. Specify -1 to retrieve the absolute orientation, sim_handle_parent to retrieve the orientation relative to the object's parent, or an object handle relative to whose reference frame you want the orientation.quaternion: the quaternion (x,y,z,w)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the orientation. Specify -1 to retrieve the absolute orientation, sim_handle_parent to retrieve the orientation relative to the object's parent, or an object handle relative to whose reference frame you want the orientation.quaternion: the quaternion (x,y,z,w)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the orientation. Specify -1 to retrieve the absolute orientation, sim_handle_parent to retrieve the orientation relative to the object's parent, or an object handle relative to whose reference frame you want the orientation.quaternion: the quaternion (x,y,z,w)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the orientation. Specify -1 to retrieve the absolute orientation, sim_handle_parent to retrieve the orientation relative to the object's parent, or an object handle relative to whose reference frame you want the orientation.quaternion: the quaternion (x,y,z,w) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simx.getArrayParameter": {
        "body": "simx.getArrayParameter(${0:clientId},${1:paramIdentifier})", 
        "scope": "source.lua", 
        "prefix": "simx.getArrayParameter", 
        "description": "number returnCode,table_3 paramValues= simx.getArrayParameter(number clientId,number paramIdentifier)Retrieves 3 values from an array. See the array parameter identifiers. See also simxSetArrayParameter, simx.getBooleanParameter, simx.getIntegerParameter, simx.getFloatingParameter and simx.getStringParameter. clientID: the client ID. refer to simx.start.paramIdentifier: an array parameter identifieroperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking (if not called on a regular basis) returnCode: a remote API function return codeparamValues: a table of 3 parameter values"
    }, 
    "sim.getObjectSizeValues": {
        "body": "sim.getObjectSizeValues(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectSizeValues", 
        "description": "table_3 sizeValues = sim.getObjectSizeValues(number objectHandle)Retrieves the x, y and z size values of a scene object. The size values are different from the real object sizes. Use this to be able to react to scaling operations. See also sim.setObjectSizeValues and sim.getObjectSizeFactor. objectHandle: handle of the scene objectsizeValues (output): a pointer to 3 size values (x, y and z)objectHandle: handle of the scene objectsizeValues (output): a pointer to 3 size values (x, y and z) -1 in case of an error"
    }, 
    "simOMPL.readState": {
        "body": "simOMPL.readState(${0:taskHandle})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.readState", 
        "description": "number result,table state = simOMPL.readState(number taskHandle)"
    }, 
    "sim.navigation_passive": {
        "body": "sim.navigation_passive", 
        "scope": "source.lua", 
        "prefix": "sim.navigation_passive", 
        "description": "Constants"
    }, 
    "sim.intparam_dynamic_engine": {
        "body": "sim.intparam_dynamic_engine", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_dynamic_engine", 
        "description": "Constants"
    }, 
    "sim.tubeStatus": {
        "body": "sim.tubeStatus(${0:tubeHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.tubeStatus", 
        "description": "number status,number readPacketsCount,number writePacketsCount = sim.tubeStatus(number tubeHandle)Checks the status of a communication tube previously opened with sim.tubeOpen. tubeHandle: the handle of the tube that was returned by the simTubeOpen function.readPacketsCount: pointer to an integer that will indicate the number of packets waiting to be read. Can be NULLwritePacketsCount: pointer to an integer that will indicate the number of packets waiting to be read on the other side of the tube. Can be NULLtubeHandle: the handle of the tube that was returned by the simTubeOpen function.readPacketsCount: pointer to an integer that will indicate the number of packets waiting to be read. Can be NULLwritePacketsCount: pointer to an integer that will indicate the number of packets waiting to be read on the other side of the tube. Can be NULLtubeHandle: the handle of the tube that was returned by the simTubeOpen function.readPacketsCount: pointer to an integer that will indicate the number of packets waiting to be read. Can be NULLwritePacketsCount: pointer to an integer that will indicate the number of packets waiting to be read on the other side of the tube. Can be NULLtubeHandle: the handle of the tube that was returned by the simTubeOpen function.readPacketsCount: pointer to an integer that will indicate the number of packets waiting to be read. Can be NULLwritePacketsCount: pointer to an integer that will indicate the number of packets waiting to be read on the other side of the tube. Can be NULL -1 if operation was not successful, 0 if the tube is not connected, 1 if the tube is connected"
    }, 
    "simx.setObjectFloatParameter": {
        "body": "simx.setObjectFloatParameter(${0:clientId},${1:objectHandle},${2:paramIdentifier},${3:paramValue})", 
        "scope": "source.lua", 
        "prefix": "simx.setObjectFloatParameter", 
        "description": "number returnCode= simx.setObjectFloatParameter(number clientId,number objectHandle,number paramIdentifier,number paramValue)Sets a floating-point parameter of a object. See also simx.getObjectFloatParameter and simx.setObjectIntParameter. clientID: the client ID. refer to simx.start.objectHandle: handle of the objectparameterID: identifier of the parameter to set. See the list of all possible object parameter identifiersparameterValue: the desired value of the parameteroperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "sim.multiplyVector": {
        "body": "sim.multiplyVector(${0:matrix},${1:vector})", 
        "scope": "source.lua", 
        "prefix": "sim.multiplyVector", 
        "description": "table_3 resultVector = sim.multiplyVector(table_12 matrix,table_3 vector)Multiplies a vector with a transformation matrix (v=m*v). See also the other matrix/transformation functions. - -"
    }, 
    "sim.intparam_flymode_camera_handle": {
        "body": "sim.intparam_flymode_camera_handle", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_flymode_camera_handle", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_p2frictionmaxforce": {
        "body": "sim.vortex_joint_p2frictionmaxforce", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p2frictionmaxforce", 
        "description": "Constants"
    }, 
    "simUI.setCheckboxValue": {
        "body": "simUI.setCheckboxValue(${0:handle},${1:id},${2:value},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setCheckboxValue", 
        "description": "simUI.setCheckboxValue(number handle,number id,number value,bool suppressEvents=true)"
    }, 
    "sim.checkProximitySensorEx": {
        "body": "sim.checkProximitySensorEx(${0:sensorHandle},${1:entityHandle},${2:mode},${3:threshold},${4:maxAngle})", 
        "scope": "source.lua", 
        "prefix": "sim.checkProximitySensorEx", 
        "description": "number result,number distance,table_3 detectedPoint,number detectedObjectHandle,table_3 normalVector = sim.checkProximitySensorEx(number sensorHandle,number entityHandle,number mode,number threshold,number maxAngle)Checks whether the proximity sensor detects the indicated entity. This is the extended functionality version of sim.checkProximitySensor. Detection is silent (no visual feedback) compared to sim.handleProximitySensor. Also, the detectable flags of the entity are overridden if the entity is an object. see also sim.readProximitySensor and sim.checkProximitySensorEx2. sensorHandle: handle of the proximity sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsdetectionMode: bit coded: bit0 (1) for front face detection, bit1 (2) for back face detection (bit0|bit1 needs to be true), bit2 (4) for fast detection (doesn't search for the closest point, just any point in the detection volume), bit3 (8) for limited angle detection (if set, maxAngle is taken into account), bit4 (16) for occlusion check.detectionThreshold: doesn't detect objects farther than detectionThreshold distance from sensor originmaxAngle: maximum detection angle (angle between detection ray and normal vector of the surface). Can be (0;pi/2). Only if bit3 of detectionMode is set will this parameter have an effect. Use this to realistically simulate ultrasonic sensors.detectedPoint: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of detected object (useful when entity to be detected is a collection or sim_handle_all). Can be NULLsurfaceNormalVector: normal vector of the surface where the point was detected. Normalized. Relative to the sensor reference frame. Can be NULLsensorHandle: handle of the proximity sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsdetectionMode: bit coded: bit0 (1) for front face detection, bit1 (2) for back face detection (bit0|bit1 needs to be true), bit2 (4) for fast detection (doesn't search for the closest point, just any point in the detection volume), bit3 (8) for limited angle detection (if set, maxAngle is taken into account), bit4 (16) for occlusion check.detectionThreshold: doesn't detect objects farther than detectionThreshold distance from sensor originmaxAngle: maximum detection angle (angle between detection ray and normal vector of the surface). Can be (0;pi/2). Only if bit3 of detectionMode is set will this parameter have an effect. Use this to realistically simulate ultrasonic sensors.detectedPoint: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of detected object (useful when entity to be detected is a collection or sim_handle_all). Can be NULLsurfaceNormalVector: normal vector of the surface where the point was detected. Normalized. Relative to the sensor reference frame. Can be NULLsensorHandle: handle of the proximity sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsdetectionMode: bit coded: bit0 (1) for front face detection, bit1 (2) for back face detection (bit0|bit1 needs to be true), bit2 (4) for fast detection (doesn't search for the closest point, just any point in the detection volume), bit3 (8) for limited angle detection (if set, maxAngle is taken into account), bit4 (16) for occlusion check.detectionThreshold: doesn't detect objects farther than detectionThreshold distance from sensor originmaxAngle: maximum detection angle (angle between detection ray and normal vector of the surface). Can be (0;pi/2). Only if bit3 of detectionMode is set will this parameter have an effect. Use this to realistically simulate ultrasonic sensors.detectedPoint: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of detected object (useful when entity to be detected is a collection or sim_handle_all). Can be NULLsurfaceNormalVector: normal vector of the surface where the point was detected. Normalized. Relative to the sensor reference frame. Can be NULLsensorHandle: handle of the proximity sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsdetectionMode: bit coded: bit0 (1) for front face detection, bit1 (2) for back face detection (bit0|bit1 needs to be true), bit2 (4) for fast detection (doesn't search for the closest point, just any point in the detection volume), bit3 (8) for limited angle detection (if set, maxAngle is taken into account), bit4 (16) for occlusion check.detectionThreshold: doesn't detect objects farther than detectionThreshold distance from sensor originmaxAngle: maximum detection angle (angle between detection ray and normal vector of the surface). Can be (0;pi/2). Only if bit3 of detectionMode is set will this parameter have an effect. Use this to realistically simulate ultrasonic sensors.detectedPoint: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of detected object (useful when entity to be detected is a collection or sim_handle_all). Can be NULLsurfaceNormalVector: normal vector of the surface where the point was detected. Normalized. Relative to the sensor reference frame. Can be NULLsensorHandle: handle of the proximity sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsdetectionMode: bit coded: bit0 (1) for front face detection, bit1 (2) for back face detection (bit0|bit1 needs to be true), bit2 (4) for fast detection (doesn't search for the closest point, just any point in the detection volume), bit3 (8) for limited angle detection (if set, maxAngle is taken into account), bit4 (16) for occlusion check.detectionThreshold: doesn't detect objects farther than detectionThreshold distance from sensor originmaxAngle: maximum detection angle (angle between detection ray and normal vector of the surface). Can be (0;pi/2). Only if bit3 of detectionMode is set will this parameter have an effect. Use this to realistically simulate ultrasonic sensors.detectedPoint: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of detected object (useful when entity to be detected is a collection or sim_handle_all). Can be NULLsurfaceNormalVector: normal vector of the surface where the point was detected. Normalized. Relative to the sensor reference frame. Can be NULLsensorHandle: handle of the proximity sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsdetectionMode: bit coded: bit0 (1) for front face detection, bit1 (2) for back face detection (bit0|bit1 needs to be true), bit2 (4) for fast detection (doesn't search for the closest point, just any point in the detection volume), bit3 (8) for limited angle detection (if set, maxAngle is taken into account), bit4 (16) for occlusion check.detectionThreshold: doesn't detect objects farther than detectionThreshold distance from sensor originmaxAngle: maximum detection angle (angle between detection ray and normal vector of the surface). Can be (0;pi/2). Only if bit3 of detectionMode is set will this parameter have an effect. Use this to realistically simulate ultrasonic sensors.detectedPoint: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of detected object (useful when entity to be detected is a collection or sim_handle_all). Can be NULLsurfaceNormalVector: normal vector of the surface where the point was detected. Normalized. Relative to the sensor reference frame. Can be NULLsensorHandle: handle of the proximity sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsdetectionMode: bit coded: bit0 (1) for front face detection, bit1 (2) for back face detection (bit0|bit1 needs to be true), bit2 (4) for fast detection (doesn't search for the closest point, just any point in the detection volume), bit3 (8) for limited angle detection (if set, maxAngle is taken into account), bit4 (16) for occlusion check.detectionThreshold: doesn't detect objects farther than detectionThreshold distance from sensor originmaxAngle: maximum detection angle (angle between detection ray and normal vector of the surface). Can be (0;pi/2). Only if bit3 of detectionMode is set will this parameter have an effect. Use this to realistically simulate ultrasonic sensors.detectedPoint: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of detected object (useful when entity to be detected is a collection or sim_handle_all). Can be NULLsurfaceNormalVector: normal vector of the surface where the point was detected. Normalized. Relative to the sensor reference frame. Can be NULLsensorHandle: handle of the proximity sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsdetectionMode: bit coded: bit0 (1) for front face detection, bit1 (2) for back face detection (bit0|bit1 needs to be true), bit2 (4) for fast detection (doesn't search for the closest point, just any point in the detection volume), bit3 (8) for limited angle detection (if set, maxAngle is taken into account), bit4 (16) for occlusion check.detectionThreshold: doesn't detect objects farther than detectionThreshold distance from sensor originmaxAngle: maximum detection angle (angle between detection ray and normal vector of the surface). Can be (0;pi/2). Only if bit3 of detectionMode is set will this parameter have an effect. Use this to realistically simulate ultrasonic sensors.detectedPoint: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of detected object (useful when entity to be detected is a collection or sim_handle_all). Can be NULLsurfaceNormalVector: normal vector of the surface where the point was detected. Normalized. Relative to the sensor reference frame. Can be NULL -1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)"
    }, 
    "sim.drawing_emissioncolor": {
        "body": "sim.drawing_emissioncolor", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_emissioncolor", 
        "description": "Constants"
    }, 
    "sim.serialRead": {
        "body": "sim.serialRead(${0:portHandle},${1:dataLengthToRead},${2:blockingOperation},${3:closingString=''},${4:timeout=0})", 
        "scope": "source.lua", 
        "prefix": "sim.serialRead", 
        "description": "string data = sim.serialRead(number portHandle,number dataLengthToRead,boolean blockingOperation,string closingString='',number timeout=0)Reads from a previously opened serial port (RS-232). The C version of the function cannot be blocking. See also sim.serialCheck and sim.serialSend. portHandle: the handle returned by the simSerialOpen functionbuffer: a buffer that will be filled with read datadataLengthToRead: the maximum data length that should be readportHandle: the handle returned by the simSerialOpen functionbuffer: a buffer that will be filled with read datadataLengthToRead: the maximum data length that should be readportHandle: the handle returned by the simSerialOpen functionbuffer: a buffer that will be filled with read datadataLengthToRead: the maximum data length that should be readportHandle: the handle returned by the simSerialOpen functionbuffer: a buffer that will be filled with read datadataLengthToRead: the maximum data length that should be read -1 if operation was not successful, otherwise the effective data length that was read"
    }, 
    "sim.boolparam_force_calcstruct_all_visible": {
        "body": "sim.boolparam_force_calcstruct_all_visible", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_force_calcstruct_all_visible", 
        "description": "Constants"
    }, 
    "simCHAI3D.reset": {
        "body": "simCHAI3D.reset()", 
        "scope": "source.lua", 
        "prefix": "simCHAI3D.reset", 
        "description": "simCHAI3D.reset()"
    }, 
    "simB0.destroy": {
        "body": "simB0.destroy(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "simB0.destroy", 
        "description": "simB0.destroy(string handle)"
    }, 
    "simx.getOutMessageInfo": {
        "body": "simx.getOutMessageInfo(${0:clientId})", 
        "scope": "source.lua", 
        "prefix": "simx.getOutMessageInfo", 
        "description": "number result,number info= simx.getOutMessageInfo(number clientId)Retrieves information about the next message to send to the server. This is a remote API helper function. See also simx.getInMessageInfo. clientID: the client ID. refer to simx.start.infoType: an outbox message info type result: -1 in case of an errorinfo: the requested information"
    }, 
    "package.cpath": {
        "body": "package.cpath(${0:...})", 
        "scope": "source.lua", 
        "prefix": "package.cpath", 
        "description": "5.1,5.2,5.3\n\npackage.cpath"
    }, 
    "simUI.getCurrentEditWidget": {
        "body": "simUI.getCurrentEditWidget(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "simUI.getCurrentEditWidget", 
        "description": "number id = simUI.getCurrentEditWidget(number handle)"
    }, 
    "sim.reorientShapeBoundingBox": {
        "body": "sim.reorientShapeBoundingBox(${0:shapeHandle},${1:relativeToHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.reorientShapeBoundingBox", 
        "description": "number result = sim.reorientShapeBoundingBox(number shapeHandle,number relativeToHandle)Reorients the bounding box of a shape. shapeHandle: the handle of the shape that will be reoriented. See also simGetObjectHandle.relativeToHandle: the handle of an object relative to which the shape should be reoriented, or -1 to align the bounding box with the world, or sim_handle_self to build the smallest bounding box around the object.reservedSetToZero: reserved for future extensions. Set to 0.shapeHandle: the handle of the shape that will be reoriented. See also simGetObjectHandle.relativeToHandle: the handle of an object relative to which the shape should be reoriented, or -1 to align the bounding box with the world, or sim_handle_self to build the smallest bounding box around the object.reservedSetToZero: reserved for future extensions. Set to 0.shapeHandle: the handle of the shape that will be reoriented. See also simGetObjectHandle.relativeToHandle: the handle of an object relative to which the shape should be reoriented, or -1 to align the bounding box with the world, or sim_handle_self to build the smallest bounding box around the object.reservedSetToZero: reserved for future extensions. Set to 0. -1 if operation was not successful. 0 if the bounding box could not be reoriented (the bounding box of pure shapes cannot be reoriented), otherwise 1."
    }, 
    "sim.vortex_body_damping": {
        "body": "sim.vortex_body_damping", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_damping", 
        "description": "Constants"
    }, 
    "sim.msgbox_type_warning": {
        "body": "sim.msgbox_type_warning", 
        "scope": "source.lua", 
        "prefix": "sim.msgbox_type_warning", 
        "description": "Constants"
    }, 
    "string.lower": {
        "body": "string.lower( ${1:s} )", 
        "scope": "source.lua", 
        "prefix": "string.lower", 
        "description": "5.1,5.2,5.3\n\nstring.lower"
    }, 
    "sim.vortex_body_normalangularaxisstaticfrictionscale": {
        "body": "sim.vortex_body_normalangularaxisstaticfrictionscale", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_normalangularaxisstaticfrictionscale", 
        "description": "Constants"
    }, 
    "sim.shapefloatparam_init_velocity_b": {
        "body": "sim.shapefloatparam_init_velocity_b", 
        "scope": "source.lua", 
        "prefix": "sim.shapefloatparam_init_velocity_b", 
        "description": "Constants"
    }, 
    "sim.stringparam_scene_path_and_name": {
        "body": "sim.stringparam_scene_path_and_name", 
        "scope": "source.lua", 
        "prefix": "sim.stringparam_scene_path_and_name", 
        "description": "Constants"
    }, 
    "sim.shapefloatparam_init_velocity_a": {
        "body": "sim.shapefloatparam_init_velocity_a", 
        "scope": "source.lua", 
        "prefix": "sim.shapefloatparam_init_velocity_a", 
        "description": "Constants"
    }, 
    "sim.boolparam_pause_toolbarbutton_enabled": {
        "body": "sim.boolparam_pause_toolbarbutton_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_pause_toolbarbutton_enabled", 
        "description": "Constants"
    }, 
    "sim.multiplyMatrices": {
        "body": "sim.multiplyMatrices(${0:matrixIn1},${1:matrixIn2})", 
        "scope": "source.lua", 
        "prefix": "sim.multiplyMatrices", 
        "description": "table_12 resultMatrix = sim.multiplyMatrices(table_12 matrixIn1,table_12 matrixIn2)Multiplies two transformation matrices. See also the other matrix/transformation functions. matrixIn1: the first input matrixmatrixIn2: the second input matrixmatrixOut: the output matrix (the result of the multiplication: matrixIn1*matrixIn2).A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn1: the first input matrixmatrixIn2: the second input matrixmatrixOut: the output matrix (the result of the multiplication: matrixIn1*matrixIn2).A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn1: the first input matrixmatrixIn2: the second input matrixmatrixOut: the output matrix (the result of the multiplication: matrixIn1*matrixIn2).A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn1: the first input matrixmatrixIn2: the second input matrixmatrixOut: the output matrix (the result of the multiplication: matrixIn1*matrixIn2).A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn1: the first input matrixmatrixIn2: the second input matrixmatrixOut: the output matrix (the result of the multiplication: matrixIn1*matrixIn2).A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn1: the first input matrixmatrixIn2: the second input matrixmatrixOut: the output matrix (the result of the multiplication: matrixIn1*matrixIn2).A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn1: the first input matrixmatrixIn2: the second input matrixmatrixOut: the output matrix (the result of the multiplication: matrixIn1*matrixIn2).A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn1: the first input matrixmatrixIn2: the second input matrixmatrixOut: the output matrix (the result of the multiplication: matrixIn1*matrixIn2).A transformation matrix contains 12 values (the last row (0,0,0,1) is omitted):The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11]) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simx.return_remote_error_flag": {
        "body": "simx.return_remote_error_flag", 
        "scope": "source.lua", 
        "prefix": "simx.return_remote_error_flag", 
        "description": "Constants"
    }, 
    "sim.modelproperty_scripts_inactive": {
        "body": "sim.modelproperty_scripts_inactive", 
        "scope": "source.lua", 
        "prefix": "sim.modelproperty_scripts_inactive", 
        "description": "Constants"
    }, 
    "simRRS1.SET_NEXT_TARGET": {
        "body": "simRRS1.SET_NEXT_TARGET(${0:rcsHandle},${1:targetId},${2:targetParam},${3:cartPos},${4:jointPos},${5:configuration})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_NEXT_TARGET", 
        "description": "int status= simRRS1.SET_NEXT_TARGET(bitstring2 rcsHandle,int targetId,int targetParam,cartPosType cartPos,jointPosType jointPos,string configuration)"
    }, 
    "sim.shapefloatparam_init_velocity_z": {
        "body": "sim.shapefloatparam_init_velocity_z", 
        "scope": "source.lua", 
        "prefix": "sim.shapefloatparam_init_velocity_z", 
        "description": "Constants"
    }, 
    "simx.auxiliaryConsoleOpen": {
        "body": "simx.auxiliaryConsoleOpen(${0:clientId},${1:title},${2:maxLines},${3:mode},${4:position},${5:size},${6:textColor},${7:backgroundColor})", 
        "scope": "source.lua", 
        "prefix": "simx.auxiliaryConsoleOpen", 
        "description": "number returnCode,number consoleHandle= simx.auxiliaryConsoleOpen(number clientId,string title,number maxLines,number mode,table_2 position,table_2 size,table_3 textColor,table_3 backgroundColor)Opens an auxiliary console window for text display. This console window is different from the application main console window. Console window handles are shared across all simulator scenes. See also simx.auxiliaryConsolePrint, simx.auxiliaryConsoleShow and simx.auxiliaryConsoleClose. clientID: the client ID. refer to simx.start.title: the title of the console windowmaxLines: the number of text lines that can be displayed and bufferedmode: bit-coded value. Bit0 set indicates that the console window will   automatically close at simulation end, bit1 set   indicates that lines will be wrapped, bit2 set indicates that the user   can close the console window, bit3 set indicates that the console will   automatically be hidden during simulation pause, bit4 set indicates that   the console will not automatically hide when the user switches to   another scene.position: the initial position of the console window (x and y value). Can be nilsize: the initial size of the console window (x and y value). Can be niltextColor: the color of the text (rgb values, 0-1). Can be nilbackgroundColor: the background color of the console window (rgb values, 0-1). Can be niloperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return codeconsoleHandle: the handle of the created console"
    }, 
    "ifel": {
        "body": "if ${1:condition} then\n\t${2:-- body}\nelse\n\t${0:-- body}\nend", 
        "scope": "source.lua", 
        "prefix": "ifel", 
        "description": "ifel"
    }, 
    "sim.shapefloatparam_init_velocity_y": {
        "body": "sim.shapefloatparam_init_velocity_y", 
        "scope": "source.lua", 
        "prefix": "sim.shapefloatparam_init_velocity_y", 
        "description": "Constants"
    }, 
    "simOMPL.Algorithm.PRM": {
        "body": "simOMPL.Algorithm.PRM", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.PRM", 
        "description": "Constants"
    }, 
    "sim.handleVisionSensor": {
        "body": "sim.handleVisionSensor(${0:sensorHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.handleVisionSensor", 
        "description": "number detectionCount,table auxiliaryValuesPacket1,table auxiliaryValuesPacket2,etc. = sim.handleVisionSensor(number sensorHandle)Handles (performs sensing, etc. of) a registered vision sensor object. See also sim.readVisionSensor, sim.checkVisionSensor, sim.checkVisionSensorEx and sim.resetVisionSensor. visionSensorHandle: handle of a vision sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all vision sensor objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)auxValues: auxiliary values returned from the applied filters (refer to the documentation for details). By default V-REP returns one packet of 15 auxiliary values:the minimum of {intensity, red, green, blue, depth value}, the maximum of {intensity, red, green, blue, depth value}, and the average of {intensity, red, green, blue, depth value}. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with simReleaseBuffer(*auxValues). If visionSensorHandle is sim_handle_all or sim_handle_all_except_explicit, nothing is returned in auxValues.auxValuesCount: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with simReleaseBuffer(*auxValuesCount).USAGE EXAMPLE:float* auxValues=NULL;int* auxValuesCount=NULL;float averageColor[3]={0.0f,0.0f,0.0f};if (simHandleVisionSensor(visionSensorHandle,&auxValues,&auxValuesCount)>=0){    if ((auxValuesCount[0]>0)||(auxValuesCount[1]>=15))    {        averageColor[0]=auxValues[11];        averageColor[1]=auxValues[12];        averageColor[2]=auxValues[13];    }    simReleaseBuffer((char*)auxValues);    simReleaseBuffer((char*)auxValuesCount);}visionSensorHandle: handle of a vision sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all vision sensor objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)auxValues: auxiliary values returned from the applied filters (refer to the documentation for details). By default V-REP returns one packet of 15 auxiliary values:the minimum of {intensity, red, green, blue, depth value}, the maximum of {intensity, red, green, blue, depth value}, and the average of {intensity, red, green, blue, depth value}. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with simReleaseBuffer(*auxValues). If visionSensorHandle is sim_handle_all or sim_handle_all_except_explicit, nothing is returned in auxValues.auxValuesCount: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with simReleaseBuffer(*auxValuesCount).USAGE EXAMPLE:float* auxValues=NULL;int* auxValuesCount=NULL;float averageColor[3]={0.0f,0.0f,0.0f};if (simHandleVisionSensor(visionSensorHandle,&auxValues,&auxValuesCount)>=0){    if ((auxValuesCount[0]>0)||(auxValuesCount[1]>=15))    {        averageColor[0]=auxValues[11];        averageColor[1]=auxValues[12];        averageColor[2]=auxValues[13];    }    simReleaseBuffer((char*)auxValues);    simReleaseBuffer((char*)auxValuesCount);}visionSensorHandle: handle of a vision sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all vision sensor objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)auxValues: auxiliary values returned from the applied filters (refer to the documentation for details). By default V-REP returns one packet of 15 auxiliary values:the minimum of {intensity, red, green, blue, depth value}, the maximum of {intensity, red, green, blue, depth value}, and the average of {intensity, red, green, blue, depth value}. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with simReleaseBuffer(*auxValues). If visionSensorHandle is sim_handle_all or sim_handle_all_except_explicit, nothing is returned in auxValues.auxValuesCount: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with simReleaseBuffer(*auxValuesCount).USAGE EXAMPLE:float* auxValues=NULL;int* auxValuesCount=NULL;float averageColor[3]={0.0f,0.0f,0.0f};if (simHandleVisionSensor(visionSensorHandle,&auxValues,&auxValuesCount)>=0){    if ((auxValuesCount[0]>0)||(auxValuesCount[1]>=15))    {        averageColor[0]=auxValues[11];        averageColor[1]=auxValues[12];        averageColor[2]=auxValues[13];    }    simReleaseBuffer((char*)auxValues);    simReleaseBuffer((char*)auxValuesCount);}visionSensorHandle: handle of a vision sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all vision sensor objects, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)auxValues: auxiliary values returned from the applied filters (refer to the documentation for details). By default V-REP returns one packet of 15 auxiliary values:the minimum of {intensity, red, green, blue, depth value}, the maximum of {intensity, red, green, blue, depth value}, and the average of {intensity, red, green, blue, depth value}. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with simReleaseBuffer(*auxValues). If visionSensorHandle is sim_handle_all or sim_handle_all_except_explicit, nothing is returned in auxValues.auxValuesCount: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with simReleaseBuffer(*auxValuesCount).USAGE EXAMPLE:float* auxValues=NULL;int* auxValuesCount=NULL;float averageColor[3]={0.0f,0.0f,0.0f};if (simHandleVisionSensor(visionSensorHandle,&auxValues,&auxValuesCount)>=0){    if ((auxValuesCount[0]>0)||(auxValuesCount[1]>=15))    {        averageColor[0]=auxValues[11];        averageColor[1]=auxValues[12];        averageColor[2]=auxValues[13];    }    simReleaseBuffer((char*)auxValues);    simReleaseBuffer((char*)auxValuesCount);} number of detections (number of vision sensors that triggered a detection), -1 in case of an error"
    }, 
    "sim.vortex_joint_a0stiffness": {
        "body": "sim.vortex_joint_a0stiffness", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a0stiffness", 
        "description": "Constants"
    }, 
    "sim.message_prox_sensor_select_down": {
        "body": "sim.message_prox_sensor_select_down", 
        "scope": "source.lua", 
        "prefix": "sim.message_prox_sensor_select_down", 
        "description": "Constants"
    }, 
    "simB0.createSubscriber": {
        "body": "simB0.createSubscriber(${0:nodeHandle},${1:topic},${2:callback=''})", 
        "scope": "source.lua", 
        "prefix": "simB0.createSubscriber", 
        "description": "string handle simB0.createSubscriber(string nodeHandle,string topic,string callback='')"
    }, 
    "sim.getVisionSensorFilter": {
        "body": "sim.getVisionSensorFilter(${0:sensorHandle},${1:filterIndex})", 
        "scope": "source.lua", 
        "prefix": "sim.getVisionSensorFilter", 
        "description": "number filterType,number options,table byteVals,table intVals,table floatVals,string customBuffer = sim.getVisionSensorFilter(number sensorHandle,number filterIndex)Retrieves the parameters and settings of a specific filter component of a vision sensor. See also sim.setVisionSensorFilter and the other vision sensor related API functions. visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded return value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values receiving the sizes of the returned buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.ints: a buffer of ints values representing the int parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.floats: a buffer of floats values representing the float parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.custom: a buffer of bytes values representing the custom parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.USAGE EXAMPLE:int options=0;int sizes[4]={0,0,0,0};unsigned char* bytes;int* ints;float* floats;unsigned char* custom;int filterType=simGetVisionSensorFilter(handle,index,&options,sizes,&bytes,&ints,&floats,&custom);if (filterType>0){    // Modify options, bytes, ints, floats and custom    // ...    // Now write back the updated values:    simSetVisionSensorFilter(handle,index,options,sizes,bytes,ints,floats,custom);    // Destroy the buffers:    simReleaseBuffer((simChar*)bytes);    simReleaseBuffer((simChar*)ints);    simReleaseBuffer((simChar*)floats);    simReleaseBuffer((simChar*)custom);}visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded return value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values receiving the sizes of the returned buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.ints: a buffer of ints values representing the int parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.floats: a buffer of floats values representing the float parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.custom: a buffer of bytes values representing the custom parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.USAGE EXAMPLE:int options=0;int sizes[4]={0,0,0,0};unsigned char* bytes;int* ints;float* floats;unsigned char* custom;int filterType=simGetVisionSensorFilter(handle,index,&options,sizes,&bytes,&ints,&floats,&custom);if (filterType>0){    // Modify options, bytes, ints, floats and custom    // ...    // Now write back the updated values:    simSetVisionSensorFilter(handle,index,options,sizes,bytes,ints,floats,custom);    // Destroy the buffers:    simReleaseBuffer((simChar*)bytes);    simReleaseBuffer((simChar*)ints);    simReleaseBuffer((simChar*)floats);    simReleaseBuffer((simChar*)custom);}visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded return value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values receiving the sizes of the returned buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.ints: a buffer of ints values representing the int parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.floats: a buffer of floats values representing the float parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.custom: a buffer of bytes values representing the custom parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.USAGE EXAMPLE:int options=0;int sizes[4]={0,0,0,0};unsigned char* bytes;int* ints;float* floats;unsigned char* custom;int filterType=simGetVisionSensorFilter(handle,index,&options,sizes,&bytes,&ints,&floats,&custom);if (filterType>0){    // Modify options, bytes, ints, floats and custom    // ...    // Now write back the updated values:    simSetVisionSensorFilter(handle,index,options,sizes,bytes,ints,floats,custom);    // Destroy the buffers:    simReleaseBuffer((simChar*)bytes);    simReleaseBuffer((simChar*)ints);    simReleaseBuffer((simChar*)floats);    simReleaseBuffer((simChar*)custom);}visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded return value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values receiving the sizes of the returned buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.ints: a buffer of ints values representing the int parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.floats: a buffer of floats values representing the float parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.custom: a buffer of bytes values representing the custom parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.USAGE EXAMPLE:int options=0;int sizes[4]={0,0,0,0};unsigned char* bytes;int* ints;float* floats;unsigned char* custom;int filterType=simGetVisionSensorFilter(handle,index,&options,sizes,&bytes,&ints,&floats,&custom);if (filterType>0){    // Modify options, bytes, ints, floats and custom    // ...    // Now write back the updated values:    simSetVisionSensorFilter(handle,index,options,sizes,bytes,ints,floats,custom);    // Destroy the buffers:    simReleaseBuffer((simChar*)bytes);    simReleaseBuffer((simChar*)ints);    simReleaseBuffer((simChar*)floats);    simReleaseBuffer((simChar*)custom);}visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded return value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values receiving the sizes of the returned buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.ints: a buffer of ints values representing the int parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.floats: a buffer of floats values representing the float parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.custom: a buffer of bytes values representing the custom parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.USAGE EXAMPLE:int options=0;int sizes[4]={0,0,0,0};unsigned char* bytes;int* ints;float* floats;unsigned char* custom;int filterType=simGetVisionSensorFilter(handle,index,&options,sizes,&bytes,&ints,&floats,&custom);if (filterType>0){    // Modify options, bytes, ints, floats and custom    // ...    // Now write back the updated values:    simSetVisionSensorFilter(handle,index,options,sizes,bytes,ints,floats,custom);    // Destroy the buffers:    simReleaseBuffer((simChar*)bytes);    simReleaseBuffer((simChar*)ints);    simReleaseBuffer((simChar*)floats);    simReleaseBuffer((simChar*)custom);}visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded return value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values receiving the sizes of the returned buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.ints: a buffer of ints values representing the int parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.floats: a buffer of floats values representing the float parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.custom: a buffer of bytes values representing the custom parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.USAGE EXAMPLE:int options=0;int sizes[4]={0,0,0,0};unsigned char* bytes;int* ints;float* floats;unsigned char* custom;int filterType=simGetVisionSensorFilter(handle,index,&options,sizes,&bytes,&ints,&floats,&custom);if (filterType>0){    // Modify options, bytes, ints, floats and custom    // ...    // Now write back the updated values:    simSetVisionSensorFilter(handle,index,options,sizes,bytes,ints,floats,custom);    // Destroy the buffers:    simReleaseBuffer((simChar*)bytes);    simReleaseBuffer((simChar*)ints);    simReleaseBuffer((simChar*)floats);    simReleaseBuffer((simChar*)custom);}visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded return value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values receiving the sizes of the returned buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.ints: a buffer of ints values representing the int parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.floats: a buffer of floats values representing the float parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.custom: a buffer of bytes values representing the custom parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.USAGE EXAMPLE:int options=0;int sizes[4]={0,0,0,0};unsigned char* bytes;int* ints;float* floats;unsigned char* custom;int filterType=simGetVisionSensorFilter(handle,index,&options,sizes,&bytes,&ints,&floats,&custom);if (filterType>0){    // Modify options, bytes, ints, floats and custom    // ...    // Now write back the updated values:    simSetVisionSensorFilter(handle,index,options,sizes,bytes,ints,floats,custom);    // Destroy the buffers:    simReleaseBuffer((simChar*)bytes);    simReleaseBuffer((simChar*)ints);    simReleaseBuffer((simChar*)floats);    simReleaseBuffer((simChar*)custom);}visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded return value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values receiving the sizes of the returned buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.ints: a buffer of ints values representing the int parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.floats: a buffer of floats values representing the float parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.custom: a buffer of bytes values representing the custom parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.USAGE EXAMPLE:int options=0;int sizes[4]={0,0,0,0};unsigned char* bytes;int* ints;float* floats;unsigned char* custom;int filterType=simGetVisionSensorFilter(handle,index,&options,sizes,&bytes,&ints,&floats,&custom);if (filterType>0){    // Modify options, bytes, ints, floats and custom    // ...    // Now write back the updated values:    simSetVisionSensorFilter(handle,index,options,sizes,bytes,ints,floats,custom);    // Destroy the buffers:    simReleaseBuffer((simChar*)bytes);    simReleaseBuffer((simChar*)ints);    simReleaseBuffer((simChar*)floats);    simReleaseBuffer((simChar*)custom);}visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded return value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values receiving the sizes of the returned buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.ints: a buffer of ints values representing the int parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.floats: a buffer of floats values representing the float parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.custom: a buffer of bytes values representing the custom parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.USAGE EXAMPLE:int options=0;int sizes[4]={0,0,0,0};unsigned char* bytes;int* ints;float* floats;unsigned char* custom;int filterType=simGetVisionSensorFilter(handle,index,&options,sizes,&bytes,&ints,&floats,&custom);if (filterType>0){    // Modify options, bytes, ints, floats and custom    // ...    // Now write back the updated values:    simSetVisionSensorFilter(handle,index,options,sizes,bytes,ints,floats,custom);    // Destroy the buffers:    simReleaseBuffer((simChar*)bytes);    simReleaseBuffer((simChar*)ints);    simReleaseBuffer((simChar*)floats);    simReleaseBuffer((simChar*)custom);}visionSensorHandle: handle of a vision sensor. See also simGetObjectHandle.filterIndex: the zero-based index of the filter position.options: bit-coded return value:bit 0 set (1): the component is enabledpSizes: a pointer to 4 integer values receiving the sizes of the returned buffers (see next 4 arguments).bytes: a buffer of bytes values representing the byte parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.ints: a buffer of ints values representing the int parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.floats: a buffer of floats values representing the float parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.custom: a buffer of bytes values representing the custom parameters of the filter component. The user is in charge of releasing that buffer with simReleaseBuffer.USAGE EXAMPLE:int options=0;int sizes[4]={0,0,0,0};unsigned char* bytes;int* ints;float* floats;unsigned char* custom;int filterType=simGetVisionSensorFilter(handle,index,&options,sizes,&bytes,&ints,&floats,&custom);if (filterType>0){    // Modify options, bytes, ints, floats and custom    // ...    // Now write back the updated values:    simSetVisionSensorFilter(handle,index,options,sizes,bytes,ints,floats,custom);    // Destroy the buffers:    simReleaseBuffer((simChar*)bytes);    simReleaseBuffer((simChar*)ints);    simReleaseBuffer((simChar*)floats);    simReleaseBuffer((simChar*)custom);} -1 in case of an error, 0 if the filterIndex is not valid, otherwise the type of filter component pointed by the filterIndex."
    }, 
    "os.getenv": {
        "body": "os.getenv(${0:...})", 
        "scope": "source.lua", 
        "prefix": "os.getenv", 
        "description": "5.1,5.2,5.3\n\nos.getenv (varname)"
    }, 
    "sim.navigation_ctrlselection": {
        "body": "sim.navigation_ctrlselection", 
        "scope": "source.lua", 
        "prefix": "sim.navigation_ctrlselection", 
        "description": "Constants"
    }, 
    "sim.newton_body_kineticfriction": {
        "body": "sim.newton_body_kineticfriction", 
        "scope": "source.lua", 
        "prefix": "sim.newton_body_kineticfriction", 
        "description": "Constants"
    }, 
    "simCHAI3D.addConstraintPlane": {
        "body": "simCHAI3D.addConstraintPlane(${0:deviceIndex},${1:position},${2:normal},${3:Kp},${4:Kv},${5:Fmax})", 
        "scope": "source.lua", 
        "prefix": "simCHAI3D.addConstraintPlane", 
        "description": "number objectID = simCHAI3D.addConstraintPlane(number deviceIndex,table_3 position,table_3 normal,number Kp,number Kv,number Fmax)"
    }, 
    "sim.addDrawingObjectItem": {
        "body": "sim.addDrawingObjectItem(${0:drawingObjectHandle},${1:itemData})", 
        "scope": "source.lua", 
        "prefix": "sim.addDrawingObjectItem", 
        "description": "number result = sim.addDrawingObjectItem(number drawingObjectHandle,table itemData)Adds an item (or clears all items) to a previously inserted drawing object. See also sim.addDrawingObject and sim.removeDrawingObject objectHandle: handle of a previously added drawing objectitemData: data relative to an item. If the item is a point item, 3 values are required (x;y;z). If the item is a line item, 6 values are required, and if the item is a triangle item, 9 values are required. Additional values (auxiliary values) might be required depending on the drawing object attributes. See the drawing object types and attributes for more information. If NULL the drawing object is emptied of all its itemsobjectHandle: handle of a previously added drawing objectitemData: data relative to an item. If the item is a point item, 3 values are required (x;y;z). If the item is a line item, 6 values are required, and if the item is a triangle item, 9 values are required. Additional values (auxiliary values) might be required depending on the drawing object attributes. See the drawing object types and attributes for more information. If NULL the drawing object is emptied of all its itemsobjectHandle: handle of a previously added drawing objectitemData: data relative to an item. If the item is a point item, 3 values are required (x;y;z). If the item is a line item, 6 values are required, and if the item is a triangle item, 9 values are required. Additional values (auxiliary values) might be required depending on the drawing object attributes. See the drawing object types and attributes for more information. If NULL the drawing object is emptied of all its items -1 if operation was not successful. If the point was added, then the return value is >0, if it was not added (e.g. drawing object is saturated or the item was merged with an existing item), then the return value will be 0."
    }, 
    "sim.physics_bullet": {
        "body": "sim.physics_bullet", 
        "scope": "source.lua", 
        "prefix": "sim.physics_bullet", 
        "description": "Constants"
    }, 
    "sim.message_keypress": {
        "body": "sim.message_keypress", 
        "scope": "source.lua", 
        "prefix": "sim.message_keypress", 
        "description": "Constants"
    }, 
    "sim.intparam_server_port_start": {
        "body": "sim.intparam_server_port_start", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_server_port_start", 
        "description": "Constants"
    }, 
    "simBubble.stop": {
        "body": "simBubble.stop(${0:bubbleRobHandle})", 
        "scope": "source.lua", 
        "prefix": "simBubble.stop", 
        "description": "boolean result = simBubble.stop(number bubbleRobHandle)"
    }, 
    "sim.setPage": {
        "body": "sim.setPage(${0:pageIndex})", 
        "scope": "source.lua", 
        "prefix": "sim.setPage", 
        "description": "number result = sim.setPage(number pageIndex)Switches between pages (main scene views). See also sim.getPage. index: index of the page. Valid values are 0-7index: index of the page. Valid values are 0-7 -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.getJointMode": {
        "body": "sim.getJointMode(${0:jointHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getJointMode", 
        "description": "number jointMode,number options = sim.getJointMode(number jointHandle)Retrieves the operation mode of a joint. See also sim.setJointMode. jointHandle: handle of the joint objectoptions (output): bit-coded: if bit0 is set (1), the joint operates in hybrid mode.jointHandle: handle of the joint objectoptions (output): bit-coded: if bit0 is set (1), the joint operates in hybrid mode.jointHandle: handle of the joint objectoptions (output): bit-coded: if bit0 is set (1), the joint operates in hybrid mode. -1 if operation was not successful, otherwise the  joint mode."
    }, 
    "sim.getOrientationOnPath": {
        "body": "sim.getOrientationOnPath(${0:pathHandle},${1:relativeDistance})", 
        "scope": "source.lua", 
        "prefix": "sim.getOrientationOnPath", 
        "description": "table_3 eulerAngles = sim.getOrientationOnPath(number pathHandle,number relativeDistance)Retrieves the absolute interpolated orientation of a point along a path object. See also sim.getPositionOnPath, sim.getPathPosition and sim.getClosestPositionOnPath. pathHandle: handle of the path objectrelativeDistance: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate path length calculation method (refer to the path position calculation method section). See also simGetPathLength. In order to retrieve the orientation that lies exactly on a specific path control point, specify following for relativeDistance: -ctrlPtIndex-1 (the value will be rounded appropriately).eulerAngles: Euler angles (alpha, beta and gamma)pathHandle: handle of the path objectrelativeDistance: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate path length calculation method (refer to the path position calculation method section). See also simGetPathLength. In order to retrieve the orientation that lies exactly on a specific path control point, specify following for relativeDistance: -ctrlPtIndex-1 (the value will be rounded appropriately).eulerAngles: Euler angles (alpha, beta and gamma)pathHandle: handle of the path objectrelativeDistance: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate path length calculation method (refer to the path position calculation method section). See also simGetPathLength. In order to retrieve the orientation that lies exactly on a specific path control point, specify following for relativeDistance: -ctrlPtIndex-1 (the value will be rounded appropriately).eulerAngles: Euler angles (alpha, beta and gamma)pathHandle: handle of the path objectrelativeDistance: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate path length calculation method (refer to the path position calculation method section). See also simGetPathLength. In order to retrieve the orientation that lies exactly on a specific path control point, specify following for relativeDistance: -ctrlPtIndex-1 (the value will be rounded appropriately).eulerAngles: Euler angles (alpha, beta and gamma) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.moveToPosition": {
        "body": "sim.moveToPosition(${0:objectHandle},${1:relativeToObjectHandle},${2:position},${3:orientation},${4:velocity},${5:accel},${6:distCalcMethod})", 
        "scope": "source.lua", 
        "prefix": "sim.moveToPosition", 
        "description": "number deltaTimeLeft = sim.moveToPosition(number objectHandle,number relativeToObjectHandle,table_3 position,table_3 orientation,number velocity,number accel,table_2 distCalcMethod)"
    }, 
    "utf8.len": {
        "body": "utf8.len(${0:...})", 
        "scope": "source.lua", 
        "prefix": "utf8.len", 
        "description": "5.3\n\nutf8.len (s [, i [, j]])"
    }, 
    "sim.boolparam_rml4_available": {
        "body": "sim.boolparam_rml4_available", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_rml4_available", 
        "description": "Constants"
    }, 
    "sim.msgbox_type_info": {
        "body": "sim.msgbox_type_info", 
        "scope": "source.lua", 
        "prefix": "sim.msgbox_type_info", 
        "description": "Constants"
    }, 
    "sim.appobj_constraintsolver_type": {
        "body": "sim.appobj_constraintsolver_type", 
        "scope": "source.lua", 
        "prefix": "sim.appobj_constraintsolver_type", 
        "description": "Constants"
    }, 
    "sim.getCollisionHandle": {
        "body": "sim.getCollisionHandle(${0:collisionObjectName})", 
        "scope": "source.lua", 
        "prefix": "sim.getCollisionHandle", 
        "description": "number collisionObjectHandle = sim.getCollisionHandle(string collisionObjectName)Retrieves the handle of a collision object. The operation of this function depends on the current name suffix settings (see sim.getNameSuffix, sim.setNameSuffix, and the section on accessing general-type objects). See also sim.isHandleValid. collisionObjectName: name of the collision objectcollisionObjectName: name of the collision object handle of collision object or -1 if operation was not successful"
    }, 
    "sim.handleSensingStart": {
        "body": "sim.handleSensingStart()", 
        "scope": "source.lua", 
        "prefix": "sim.handleSensingStart", 
        "description": "number result = sim.handleSensingStart()Handles various functionality (e.g. camera tracking during simulation, object velocity calculation, etc.). Should only be called from the main script, as the first instruction in the sensing section. See also sim.handleSimulationStart. - -"
    }, 
    "coroutine.isyieldable": {
        "body": "coroutine.isyieldable( )", 
        "scope": "source.lua", 
        "prefix": "coroutine.isyieldable", 
        "description": "5.3\n\ncoroutine.isyieldable"
    }, 
    "simRRS1.SET_JOINT_ACCELERATIONS": {
        "body": "simRRS1.SET_JOINT_ACCELERATIONS(${0:rcsHandle},${1:allJointFlags},${2:jointFlags},${3:accelPercent})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_JOINT_ACCELERATIONS", 
        "description": "int status= simRRS1.SET_JOINT_ACCELERATIONS(bitstring2 rcsHandle,int allJointFlags,bitstring jointFlags,real_32 accelPercent)"
    }, 
    "sim.isScriptExecutionThreaded": {
        "body": "sim.isScriptExecutionThreaded()", 
        "scope": "source.lua", 
        "prefix": "sim.isScriptExecutionThreaded", 
        "description": "number result = sim.isScriptExecutionThreaded()Checks whether the current script runs threaded - -"
    }, 
    "sim.getStringSignal": {
        "body": "sim.getStringSignal(${0:signalName})", 
        "scope": "source.lua", 
        "prefix": "sim.getStringSignal", 
        "description": "string signalValue = sim.getStringSignal(string signalName)Gets the value of a string signal. Signals are cleared at simulation start.  See also sim.setStringSignal, the other signal functions,  the data packing/unpacking functions  and sim.persistentDataRead. signalName: name of the signalstringLength: the size of the returned string, since it may contain any data (also embedded zeros).signalName: name of the signalstringLength: the size of the returned string, since it may contain any data (also embedded zeros). NULL if operation was not successful or signal does not exist, otherwise the value of the string signal (which may contain any value, including embedded zeros). In that case the returned buffer should be released with simReleaseBuffer"
    }, 
    "sim.handle_all_except_self": {
        "body": "sim.handle_all_except_self", 
        "scope": "source.lua", 
        "prefix": "sim.handle_all_except_self", 
        "description": "Constants"
    }, 
    "simUI.setNodeText": {
        "body": "simUI.setNodeText(${0:handle},${1:id},${2:nodeId},${3:text})", 
        "scope": "source.lua", 
        "prefix": "simUI.setNodeText", 
        "description": "simUI.setNodeText(number handle,number id,number nodeId,string text)"
    }, 
    "sim.vortex_body_secmangulararaxisfrictionmodel": {
        "body": "sim.vortex_body_secmangulararaxisfrictionmodel", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_secmangulararaxisfrictionmodel", 
        "description": "Constants"
    }, 
    "simOMPL.setGoalState": {
        "body": "simOMPL.setGoalState(${0:taskHandle},${1:state})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.setGoalState", 
        "description": "number result = simOMPL.setGoalState(number taskHandle,table state)"
    }, 
    "math.atan2": {
        "body": "math.atan2(${0:...})", 
        "scope": "source.lua", 
        "prefix": "math.atan2", 
        "description": "5.1,5.2\n\nmath.atan2 (y, x)"
    }, 
    "sim.readProximitySensor": {
        "body": "sim.readProximitySensor(${0:sensorHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.readProximitySensor", 
        "description": "number result,number distance,table_3 detectedPoint,number detectedObjectHandle,table_3 normalVector = sim.readProximitySensor(number sensorHandle)Reads the state of a proximity sensor. This function doesn't perform detection, it merely reads the result from a previous call to sim.handleProximitySensor (sim.handleProximitySensor is called in the default main script). See also sim.checkProximitySensor, sim.checkProximitySensorEx and sim.resetProximitySensor. sensorHandle: handle of a proximity sensor objectdetectedPoint: coordinates of the closest detected point (x, y and z: detectedPoint[0]-detectedPoint[2]) relative to the sensor reference frame, and distance to the detected point (1 value: detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of the object that was detected. Can be NULLdetectedSurfaceNormalVector: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Can be NULLsensorHandle: handle of a proximity sensor objectdetectedPoint: coordinates of the closest detected point (x, y and z: detectedPoint[0]-detectedPoint[2]) relative to the sensor reference frame, and distance to the detected point (1 value: detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of the object that was detected. Can be NULLdetectedSurfaceNormalVector: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Can be NULLsensorHandle: handle of a proximity sensor objectdetectedPoint: coordinates of the closest detected point (x, y and z: detectedPoint[0]-detectedPoint[2]) relative to the sensor reference frame, and distance to the detected point (1 value: detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of the object that was detected. Can be NULLdetectedSurfaceNormalVector: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Can be NULLsensorHandle: handle of a proximity sensor objectdetectedPoint: coordinates of the closest detected point (x, y and z: detectedPoint[0]-detectedPoint[2]) relative to the sensor reference frame, and distance to the detected point (1 value: detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of the object that was detected. Can be NULLdetectedSurfaceNormalVector: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Can be NULLsensorHandle: handle of a proximity sensor objectdetectedPoint: coordinates of the closest detected point (x, y and z: detectedPoint[0]-detectedPoint[2]) relative to the sensor reference frame, and distance to the detected point (1 value: detectedPoint[3]). Can be NULLdetectedObjectHandle: handle of the object that was detected. Can be NULLdetectedSurfaceNormalVector: normal vector (normalized) of the detected surface. Relative to the sensor reference frame. Can be NULL detection state (0 or 1), or -1 in case of an error, or if simHandleProximitySensor was never called, or if simResetProximitySensor was previously called."
    }, 
    "sim.rmlPos": {
        "body": "sim.rmlPos(${0:dofs},${1:smallestTimeStep},${2:flags},${3:currentPosVelAccel},${4:maxVelAccelJerk},${5:selection},${6:targetPosVel})", 
        "scope": "source.lua", 
        "prefix": "sim.rmlPos", 
        "description": "number handle = sim.rmlPos(number dofs,number smallestTimeStep,number flags,table currentPosVelAccel,table maxVelAccelJerk,table selection,table targetPosVel)"
    }, 
    "sim.api_warning_output": {
        "body": "sim.api_warning_output", 
        "scope": "source.lua", 
        "prefix": "sim.api_warning_output", 
        "description": "Constants"
    }, 
    "sim.dynmat_foot": {
        "body": "sim.dynmat_foot", 
        "scope": "source.lua", 
        "prefix": "sim.dynmat_foot", 
        "description": "Constants"
    }, 
    "sim.setVisionSensorImage": {
        "body": "sim.setVisionSensorImage(${0:sensorHandle},${1:imageBuffer})", 
        "scope": "source.lua", 
        "prefix": "sim.setVisionSensorImage", 
        "description": "number result = sim.setVisionSensorImage(number sensorHandle,table imageBuffer)Sets the rgb-image of a vision sensor (and applies any image processing filter if specified in the vision sensor dialog). Make sure the vision sensor is flagged as external input. Use sim.getVisionSensorResolution to know the size of the image buffer that you need to provide (buffer size=resolutionX *resolutionY*3). The regular use of this function is to first read the data from a vision sensor with sim.getVisionSensorImage, do some custom filtering, then write the modified image back. The alternate use of this function is to display textures, video images, etc. by using a vision sensor object (without however making use of the vision sensor functionality), since a vision sensor can be looked through like camera objects. See also sim.setVisionSensorCharImage. sensorHandle: handle of the vision sensor object. Can be combined with sim_handleflag_greyscale (simply add sim_handleflag_greyscale to sensorHandle), if you wish to provide grey scale values instead of rgb values.image: rgb buffer containing the image (buffer size must be resolutionX*resolutionY*3). Values in the buffer should vary between 0 and 1. In case a grey scale image is provided, the buffer size must be resolutionX*resolutionY.sensorHandle: handle of the vision sensor object. Can be combined with sim_handleflag_greyscale (simply add sim_handleflag_greyscale to sensorHandle), if you wish to provide grey scale values instead of rgb values.image: rgb buffer containing the image (buffer size must be resolutionX*resolutionY*3). Values in the buffer should vary between 0 and 1. In case a grey scale image is provided, the buffer size must be resolutionX*resolutionY.sensorHandle: handle of the vision sensor object. Can be combined with sim_handleflag_greyscale (simply add sim_handleflag_greyscale to sensorHandle), if you wish to provide grey scale values instead of rgb values.image: rgb buffer containing the image (buffer size must be resolutionX*resolutionY*3). Values in the buffer should vary between 0 and 1. In case a grey scale image is provided, the buffer size must be resolutionX*resolutionY. -1 if operation was not successful. 0 if the applied filter didn't trigger anything, 1 if the appIied filter triggered a detection"
    }, 
    "simRemoteApi.start": {
        "body": "simRemoteApi.start(${0:socketPort},${1:maxPacketSize=1300},${2:debug=false})", 
        "scope": "source.lua", 
        "prefix": "simRemoteApi.start", 
        "description": "number result= simRemoteApi.start(number socketPort,number maxPacketSize=1300,boolean debug=false)"
    }, 
    "simUI.curve_scatter_shape.triangle_inverted": {
        "body": "simUI.curve_scatter_shape.triangle_inverted", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_scatter_shape.triangle_inverted", 
        "description": "Constants"
    }, 
    "sim.ode_joint_bounce": {
        "body": "sim.ode_joint_bounce", 
        "scope": "source.lua", 
        "prefix": "sim.ode_joint_bounce", 
        "description": "Constants"
    }, 
    "sim.handle_single": {
        "body": "sim.handle_single", 
        "scope": "source.lua", 
        "prefix": "sim.handle_single", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_vortex_dep_multiplication": {
        "body": "sim.jointfloatparam_vortex_dep_multiplication", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_vortex_dep_multiplication", 
        "description": "Constants"
    }, 
    "simRRS1.SELECT_TARGET_TYPE": {
        "body": "simRRS1.SELECT_TARGET_TYPE(${0:rcsHandle},${1:targetType},${2:cartPos},${3:jointPos})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SELECT_TARGET_TYPE", 
        "description": "int status= simRRS1.SELECT_TARGET_TYPE(bitstring2 rcsHandle,int targetType,cartPosType cartPos,jointPosType jointPos)"
    }, 
    "sim.setShapeMaterial": {
        "body": "sim.setShapeMaterial(${0:shapeHandle},${1:materialIdOrShapeHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.setShapeMaterial", 
        "description": "number result = sim.setShapeMaterial(number shapeHandle,number materialIdOrShapeHandle)Sets the material (used by the physics engines) of a specific shape. You might have to also call sim.resetDynamicObject for changes to take effect. shapeHandle: the handle of the shape. See also simGetObjectHandle.materialIdOrShapeHandle: a predefined dynamic material ID, or the handle of another shape you wish to copy the material properties from.shapeHandle: the handle of the shape. See also simGetObjectHandle.materialIdOrShapeHandle: a predefined dynamic material ID, or the handle of another shape you wish to copy the material properties from. -1 in case of an error."
    }, 
    "dofile": {
        "body": "dofile(${1:[filename]})", 
        "scope": "source.lua", 
        "prefix": "dofile", 
        "description": "5.1,5.2,5.3\n\ndofile ([filename])"
    }, 
    "ver": {
        "body": "_VERSION", 
        "scope": "source.lua", 
        "prefix": "ver", 
        "description": "_VERSION"
    }, 
    "sim.intersectPointsWithPointCloud": {
        "body": "sim.intersectPointsWithPointCloud(${0:pointCloudHandle},${1:options},${2:points},${3:tolerance})", 
        "scope": "source.lua", 
        "prefix": "sim.intersectPointsWithPointCloud", 
        "description": "number totalPointCnt = sim.intersectPointsWithPointCloud(number pointCloudHandle,number options,table points,number tolerance)Removes points from a point cloud, that do not intersect with the provided points (i.e. the result in the point cloud will be the intersection between the two sets of points). When a point cloud doesn't use an octree calculation structure, then this operation cannot be performed. See also sim.insertPointsIntoPointCloud, sim.setPointCloudOptions and the other point cloud related functions. pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framepts: a pointer to the point positions specified as X/Y/Z coordinates. ptCnt: the number of point coordinates contained in ptstolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framepts: a pointer to the point positions specified as X/Y/Z coordinates. ptCnt: the number of point coordinates contained in ptstolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framepts: a pointer to the point positions specified as X/Y/Z coordinates. ptCnt: the number of point coordinates contained in ptstolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framepts: a pointer to the point positions specified as X/Y/Z coordinates. ptCnt: the number of point coordinates contained in ptstolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framepts: a pointer to the point positions specified as X/Y/Z coordinates. ptCnt: the number of point coordinates contained in ptstolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framepts: a pointer to the point positions specified as X/Y/Z coordinates. ptCnt: the number of point coordinates contained in ptstolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framepts: a pointer to the point positions specified as X/Y/Z coordinates. ptCnt: the number of point coordinates contained in ptstolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULL -1 if operation was not successful, otherwise the total number of points in the point cloud"
    }, 
    "sim.isScriptRunningInThread": {
        "body": "sim.isScriptRunningInThread()", 
        "scope": "source.lua", 
        "prefix": "sim.isScriptRunningInThread", 
        "description": "number result = sim.isScriptRunningInThread()"
    }, 
    "sim.vortex_joint_a2frictionmaxforce": {
        "body": "sim.vortex_joint_a2frictionmaxforce", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a2frictionmaxforce", 
        "description": "Constants"
    }, 
    "sim.ik_avoidance_constraint": {
        "body": "sim.ik_avoidance_constraint", 
        "scope": "source.lua", 
        "prefix": "sim.ik_avoidance_constraint", 
        "description": "Constants"
    }, 
    "math.huge": {
        "body": "math.huge(${0:...})", 
        "scope": "source.lua", 
        "prefix": "math.huge", 
        "description": "5.1,5.2,5.3\n\nmath.huge"
    }, 
    "sim.stringparam_video_filename": {
        "body": "sim.stringparam_video_filename", 
        "scope": "source.lua", 
        "prefix": "sim.stringparam_video_filename", 
        "description": "Constants"
    }, 
    "simOMPL.setGoal": {
        "body": "simOMPL.setGoal(${0:taskHandle},${1:robotDummy},${2:goalDummy},${3:tolerance=0.001f},${4:0.1}},${5:refDummy=-1})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.setGoal", 
        "description": "number result = simOMPL.setGoal(number taskHandle,number robotDummy,number goalDummy,number tolerance=0.001f,table metric={1.0, 1.0, 1.0, 0.1},number refDummy=-1)"
    }, 
    "sim.handleflag_camera": {
        "body": "sim.handleflag_camera", 
        "scope": "source.lua", 
        "prefix": "sim.handleflag_camera", 
        "description": "Constants"
    }, 
    "sim.handle_app": {
        "body": "sim.handle_app", 
        "scope": "source.lua", 
        "prefix": "sim.handle_app", 
        "description": "Constants"
    }, 
    "simOMPL.Algorithm.STRIDE": {
        "body": "simOMPL.Algorithm.STRIDE", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.STRIDE", 
        "description": "Constants"
    }, 
    "sim.packTable": {
        "body": "sim.packTable(${0:aTable})", 
        "scope": "source.lua", 
        "prefix": "sim.packTable", 
        "description": "string buffer = sim.packTable(table aTable)Packs a table into a buffer. The table may contain other nested tables, nil, boolean, number or string values. All other types (e.g. functions) will be considered as nil values. See also sim.unpackTable, the other stack functions  and the other packing/unpacking functions. stackHandle: a stack handle obtained with simCreateStack. There must be a table located at the top of the stack.bufferSize: the size of the returned buffer.stackHandle: a stack handle obtained with simCreateStack. There must be a table located at the top of the stack.bufferSize: the size of the returned buffer. NULL in case of an error, otherwise a data buffer. The user is in charge of releasing the returned buffer with simReleaseBuffer."
    }, 
    "package.loadlib": {
        "body": "package.loadlib(${0:...})", 
        "scope": "source.lua", 
        "prefix": "package.loadlib", 
        "description": "5.1,5.2,5.3\n\npackage.loadlib (libname, funcname)"
    }, 
    "string.find": {
        "body": "string.find( ${1:s},${2:pattern}${3:[, init]}${4:[, plain]} )", 
        "scope": "source.lua", 
        "prefix": "string.find", 
        "description": "5.1,5.2,5.3\n\nstring.find"
    }, 
    "bit32.extract": {
        "body": "bit32.extract(${0:...})", 
        "scope": "source.lua", 
        "prefix": "bit32.extract", 
        "description": "5.2\n\nbit32.extract (n, field [, width])"
    }, 
    "sim.resetMill": {
        "body": "sim.resetMill(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.resetMill", 
        "description": "number result = sim.resetMill(number objectHandle)Clears all previously set mill calculation results (list of cut objects, surface and volume that were cut). See also sim.handleMill. millHandle: handle of the mill object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all mill objects, while sim_handle_all_except_explicit will only reset those that are not marked as explicit handling)millHandle: handle of the mill object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all mill objects, while sim_handle_all_except_explicit will only reset those that are not marked as explicit handling) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simx.getBooleanParameter": {
        "body": "simx.getBooleanParameter(${0:clientId},${1:paramIdentifier})", 
        "scope": "source.lua", 
        "prefix": "simx.getBooleanParameter", 
        "description": "number returnCode,boolean paramValue= simx.getBooleanParameter(number clientId,number paramIdentifier)Retrieves a boolean value. See the Boolean parameter identifiers. See also simx.setBooleanParameter, simx.getIntegerParameter, simx.getFloatingParameter, simx.getArrayParameter and simx.getStringParameter. clientID: the client ID. refer to simx.start.paramIdentifier: a Boolean parameter identifieroperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking (if not called on a regular basis) returnCode: a remote API function return codeparamValue: the parameter value"
    }, 
    "simx.setObjectIntParameter": {
        "body": "simx.setObjectIntParameter(${0:clientId},${1:objectHandle},${2:paramIdentifier},${3:paramValue})", 
        "scope": "source.lua", 
        "prefix": "simx.setObjectIntParameter", 
        "description": "number returnCode= simx.setObjectIntParameter(number clientId,number objectHandle,number paramIdentifier,number paramValue)Sets an integer parameter of a object. See also simx.getObjectIntParameter and simx.setObjectFloatParameter. clientID: the client ID. refer to simx.start.objectHandle: handle of the objectparameterID: identifier of the parameter to set. See the list of all possible object parameter identifiersparameterValue: the desired value of the parameteroperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "simROS.imageTransportPublish": {
        "body": "simROS.imageTransportPublish(${0:publisherHandle},${1:data},${2:width},${3:height},${4:frame_id})", 
        "scope": "source.lua", 
        "prefix": "simROS.imageTransportPublish", 
        "description": "simROS.imageTransportPublish(number publisherHandle,string data,number width,number height,string frame_id)"
    }, 
    "sim.serialOpen": {
        "body": "sim.serialOpen(${0:portString},${1:baudRate})", 
        "scope": "source.lua", 
        "prefix": "sim.serialOpen", 
        "description": "number portHandle = sim.serialOpen(string portString,number baudRate)Opens a serial port (RS-232) for communication. When called from a script, the function can only be called when the simulation is running (and in that case the port is automatically closed at simulation stop). See also sim.serialClose, sim.serialSend, sim.serialCheck and sim.serialRead. portString: a string specifying the port to open. Under Windows, use something similar to \\.\\COM1. Under MacOS and Linux, use something similar to /dev/* (check the /dev folder to know what file to specify). Under Linux, you might have to launch V-REP with super user priviledges in order to access the serial port.baudRate: the baudratereserved1: reserved for future extension. Keep at NULL.reserved2: reserved for future extension. Keep at NULL.portString: a string specifying the port to open. Under Windows, use something similar to \\.\\COM1. Under MacOS and Linux, use something similar to /dev/* (check the /dev folder to know what file to specify). Under Linux, you might have to launch V-REP with super user priviledges in order to access the serial port.baudRate: the baudratereserved1: reserved for future extension. Keep at NULL.reserved2: reserved for future extension. Keep at NULL.portString: a string specifying the port to open. Under Windows, use something similar to \\.\\COM1. Under MacOS and Linux, use something similar to /dev/* (check the /dev folder to know what file to specify). Under Linux, you might have to launch V-REP with super user priviledges in order to access the serial port.baudRate: the baudratereserved1: reserved for future extension. Keep at NULL.reserved2: reserved for future extension. Keep at NULL.portString: a string specifying the port to open. Under Windows, use something similar to \\.\\COM1. Under MacOS and Linux, use something similar to /dev/* (check the /dev folder to know what file to specify). Under Linux, you might have to launch V-REP with super user priviledges in order to access the serial port.baudRate: the baudratereserved1: reserved for future extension. Keep at NULL.reserved2: reserved for future extension. Keep at NULL.portString: a string specifying the port to open. Under Windows, use something similar to \\.\\COM1. Under MacOS and Linux, use something similar to /dev/* (check the /dev folder to know what file to specify). Under Linux, you might have to launch V-REP with super user priviledges in order to access the serial port.baudRate: the baudratereserved1: reserved for future extension. Keep at NULL.reserved2: reserved for future extension. Keep at NULL. -1 if operation was not successful, otherwise a port handle"
    }, 
    "sim.getEngineFloatParameter": {
        "body": "sim.getEngineFloatParameter(${0:paramId},${1:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getEngineFloatParameter", 
        "description": "number floatParam = sim.getEngineFloatParameter(number paramId,number objectHandle)Retrieves a float value from the physics engine properties. See also the other engine properties setter and getter API functions. paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to retrieve a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to retrieve a global engine parameter. If NULL, then the objectHandle argument will be evaluated.ok: an optional pointer to a value that can be used to determine the success of the API call. Can be NULL.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to retrieve a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to retrieve a global engine parameter. If NULL, then the objectHandle argument will be evaluated.ok: an optional pointer to a value that can be used to determine the success of the API call. Can be NULL.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to retrieve a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to retrieve a global engine parameter. If NULL, then the objectHandle argument will be evaluated.ok: an optional pointer to a value that can be used to determine the success of the API call. Can be NULL.paramId: the engine parameter identifier.objectHandle: the handle of the shape or joint, or -1 to retrieve a global engine parameter. If -1, then the object argument will be evaluated.object: a pointer to a shape or joint objects, or NULL to retrieve a global engine parameter. If NULL, then the objectHandle argument will be evaluated.ok: an optional pointer to a value that can be used to determine the success of the API call. Can be NULL. value of the requested parameter. This function call doesn't generate any error message."
    }, 
    "sim.particle_respondable1to4": {
        "body": "sim.particle_respondable1to4", 
        "scope": "source.lua", 
        "prefix": "sim.particle_respondable1to4", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_pid_i": {
        "body": "sim.jointfloatparam_pid_i", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_pid_i", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_pid_d": {
        "body": "sim.jointfloatparam_pid_d", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_pid_d", 
        "description": "Constants"
    }, 
    "sim.objectproperty_cannotdeleteduringsim": {
        "body": "sim.objectproperty_cannotdeleteduringsim", 
        "scope": "source.lua", 
        "prefix": "sim.objectproperty_cannotdeleteduringsim", 
        "description": "Constants"
    }, 
    "math.exp": {
        "body": "math.exp( ${1:x} )", 
        "scope": "source.lua", 
        "prefix": "math.exp", 
        "description": "5.1,5.2,5.3\n\nmath.exp"
    }, 
    "sim.colorcomponent_ambient": {
        "body": "sim.colorcomponent_ambient", 
        "scope": "source.lua", 
        "prefix": "sim.colorcomponent_ambient", 
        "description": "Constants"
    }, 
    "sim.bullet_body_friction": {
        "body": "sim.bullet_body_friction", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_body_friction", 
        "description": "Constants"
    }, 
    "sim.distcalcmethod_dac": {
        "body": "sim.distcalcmethod_dac", 
        "scope": "source.lua", 
        "prefix": "sim.distcalcmethod_dac", 
        "description": "Constants"
    }, 
    "os.rename": {
        "body": "os.rename(${0:...})", 
        "scope": "source.lua", 
        "prefix": "os.rename", 
        "description": "5.1,5.2,5.3\n\nos.rename (oldname, newname)"
    }, 
    "io.open": {
        "body": "io.open(${0:...})", 
        "scope": "source.lua", 
        "prefix": "io.open", 
        "description": "5.1,5.2,5.3\n\nio.open (filename [, mode])"
    }, 
    "simOMPL.Algorithm.PDST": {
        "body": "simOMPL.Algorithm.PDST", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.PDST", 
        "description": "Constants"
    }, 
    "sim.removeParticleObject": {
        "body": "sim.removeParticleObject(${0:particleObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.removeParticleObject", 
        "description": "number result = sim.removeParticleObject(number particleObjectHandle)Removes a previously added particle object. See also sim.addParticleObject and sim.addParticleObjectItem objectHandle: handle of a previously added particle object. sim_handle_all removes all particle objects from the sceneobjectHandle: handle of a previously added particle object. sim_handle_all removes all particle objects from the scene -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simROS.setParamDouble": {
        "body": "simROS.setParamDouble(${0:name},${1:value})", 
        "scope": "source.lua", 
        "prefix": "simROS.setParamDouble", 
        "description": "simROS.setParamDouble(string name,number value)"
    }, 
    "simROS.subscriberTreatUInt8ArrayAsString": {
        "body": "simROS.subscriberTreatUInt8ArrayAsString(${0:subscriberHandle})", 
        "scope": "source.lua", 
        "prefix": "simROS.subscriberTreatUInt8ArrayAsString", 
        "description": "simROS.subscriberTreatUInt8ArrayAsString(number subscriberHandle)"
    }, 
    "sim.getPointCloudOptions": {
        "body": "sim.getPointCloudOptions(${0:pointCloudHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getPointCloudOptions", 
        "description": "number maxVoxelSize,number maxPtCntPerVoxel,number options,number pointSize = sim.getPointCloudOptions(number pointCloudHandle)Gets various properties of a point cloud. See also sim.setPointCloudOptions and the other point cloud related functions. pointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULL 1 if operation was successful"
    }, 
    "sim.ode_global_stepsize": {
        "body": "sim.ode_global_stepsize", 
        "scope": "source.lua", 
        "prefix": "sim.ode_global_stepsize", 
        "description": "Constants"
    }, 
    "simMTB.getJoints": {
        "body": "simMTB.getJoints()", 
        "scope": "source.lua", 
        "prefix": "simMTB.getJoints", 
        "description": "table_4 jointValues= simMTB.getJoints()"
    }, 
    "simx.loadModel": {
        "body": "simx.loadModel(${0:clientId},${1:modelPathAndName},${2:options})", 
        "scope": "source.lua", 
        "prefix": "simx.loadModel", 
        "description": "number returnCode,number baseHandle= simx.loadModel(number clientId,string modelPathAndName,number options)Loads a previously saved model. See also simx.loadScene and simx.transferFile. clientID: the client ID. refer to simx.start.modelPathAndName: the model filename, including the path and extension (ttm). The file is relative to the client or server system depending on the options value (see next argument)modelPathAndName: the model filename, including the path and extension (ttm). The file is relative to the client or server system depending on the options value (see next argument)options: options, bit-coded:operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return codebaseHandle: the loaded model base"
    }, 
    "sim.childscriptcall_sensing": {
        "body": "sim.childscriptcall_sensing", 
        "scope": "source.lua", 
        "prefix": "sim.childscriptcall_sensing", 
        "description": "Constants"
    }, 
    "simx.headeroffset_scene_id": {
        "body": "simx.headeroffset_scene_id", 
        "scope": "source.lua", 
        "prefix": "simx.headeroffset_scene_id", 
        "description": "Constants"
    }, 
    "sim.intparam_program_version": {
        "body": "sim.intparam_program_version", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_program_version", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_p2frictionloss": {
        "body": "sim.vortex_joint_p2frictionloss", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p2frictionloss", 
        "description": "Constants"
    }, 
    "sim.getExplicitHandling": {
        "body": "sim.getExplicitHandling(${0:generalObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getExplicitHandling", 
        "description": "number explicitHandlingFlags = sim.getExplicitHandling(number generalObjectHandle)Retrieves the explicit handling flags for a general object. See also sim.setExplicitHandling. generalObjectHandle: handle of a general object. Can be a scene object, collision object, distance object, etc.generalObjectHandle: handle of a general object. Can be a scene object, collision object, distance object, etc. -1 if command was not successful, otherwise the explicit handling flags for the specified general object (for now only bit 0 is used)."
    }, 
    "sim.ode_joint_normalcfm": {
        "body": "sim.ode_joint_normalcfm", 
        "scope": "source.lua", 
        "prefix": "sim.ode_joint_normalcfm", 
        "description": "Constants"
    }, 
    "sim.copyMatrix": {
        "body": "sim.copyMatrix(${0:matrixToCopy})", 
        "scope": "source.lua", 
        "prefix": "sim.copyMatrix", 
        "description": "table_12 matrix = sim.copyMatrix(table_12 matrixToCopy)Copies a transformation matrix. See also the other matrix/transformation functions. matrixIn: matrix to be copiedmatrixOut: copy of matrixIn (after the call)matrixIn and matrixOut are pointers to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn: matrix to be copiedmatrixOut: copy of matrixIn (after the call)matrixIn and matrixOut are pointers to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn: matrix to be copiedmatrixOut: copy of matrixIn (after the call)matrixIn and matrixOut are pointers to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn: matrix to be copiedmatrixOut: copy of matrixIn (after the call)matrixIn and matrixOut are pointers to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn: matrix to be copiedmatrixOut: copy of matrixIn (after the call)matrixIn and matrixOut are pointers to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn: matrix to be copiedmatrixOut: copy of matrixIn (after the call)matrixIn and matrixOut are pointers to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrixIn: matrix to be copiedmatrixOut: copy of matrixIn (after the call)matrixIn and matrixOut are pointers to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11]) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.buffer_double": {
        "body": "sim.buffer_double", 
        "scope": "source.lua", 
        "prefix": "sim.buffer_double", 
        "description": "Constants"
    }, 
    "simx.clearFloatSignal": {
        "body": "simx.clearFloatSignal(${0:clientId},${1:signalName})", 
        "scope": "source.lua", 
        "prefix": "simx.clearFloatSignal", 
        "description": "number returnCode= simx.clearFloatSignal(number clientId,string signalName)Clears a float signal (removes it). See also simx.setFloatSignal, simx.clearIntegerSignal and simx.clearStringSignal. clientID: the client ID. refer to simx.start.signalName: name of the signal or an empty string to clear all float signalsoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "sim.bullet_body_usenondefaultcollisionmarginconvex": {
        "body": "sim.bullet_body_usenondefaultcollisionmarginconvex", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_body_usenondefaultcollisionmarginconvex", 
        "description": "Constants"
    }, 
    "sim.addPointCloud": {
        "body": "sim.addPointCloud(${0:pageMask},${1:layerMask},${2:objectHandle},${3:options},${4:pointSize},${5:pointCoordinates},${6:defaultColors=nil},${7:pointColors=nil},${8:pointNormals=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.addPointCloud", 
        "description": "number pointCloudHandle = sim.addPointCloud(number pageMask,number layerMask,number objectHandle,number options,number pointSize,table pointCoordinates,table_12 defaultColors=nil,table pointColors=nil,table pointNormals=nil)"
    }, 
    "sim.resetVisionSensor": {
        "body": "sim.resetVisionSensor(${0:sensorHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.resetVisionSensor", 
        "description": "number result = sim.resetVisionSensor(number sensorHandle)Clears the detection state, etc. of a proximity sensor object. See also sim.handleVisionSensor. sensorHandle: handle of the vision sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all vision sensor objects, while sim_handle_all_except_explicit will only reset those that are not marked as explicit handling)sensorHandle: handle of the vision sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all vision sensor objects, while sim_handle_all_except_explicit will only reset those that are not marked as explicit handling) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "math.pow": {
        "body": "math.pow(${0:...})", 
        "scope": "source.lua", 
        "prefix": "math.pow", 
        "description": "5.1,5.2\n\nmath.pow (x, y)"
    }, 
    "simUI.curve_scatter_shape.star": {
        "body": "simUI.curve_scatter_shape.star", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_scatter_shape.star", 
        "description": "Constants"
    }, 
    "sim.checkIkGroup": {
        "body": "sim.checkIkGroup(${0:ikGroupHandle},${1:jointHandles},${2:jointOptions=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.checkIkGroup", 
        "description": "number ikCalculationResult,table jointValues = sim.checkIkGroup(number ikGroupHandle,table jointHandles,table jointOptions=nil)Solves a registered IK group, but unlike the sim.handleIkGroup function, sim.checkIkGroup will not apply the calculated joint values, but instead return them in an array. See also sim.handleIkGroup, sim.computeJacobian and sim.generateIkPath. ikGroupHandle: handle of the IK group. Only IK groups that are flagged as explicitely handled will be considered as valid handles for this function. See also simGetIkGroupHandlejointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.jointValues (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.jointOptions: a bit-coded value corresponding to each specified joint handle. Can also be NULL. Bit 0 (i.e. (1) indicates the corresponding joint is dependent of another joint.ikGroupHandle: handle of the IK group. Only IK groups that are flagged as explicitely handled will be considered as valid handles for this function. See also simGetIkGroupHandlejointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.jointValues (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.jointOptions: a bit-coded value corresponding to each specified joint handle. Can also be NULL. Bit 0 (i.e. (1) indicates the corresponding joint is dependent of another joint.ikGroupHandle: handle of the IK group. Only IK groups that are flagged as explicitely handled will be considered as valid handles for this function. See also simGetIkGroupHandlejointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.jointValues (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.jointOptions: a bit-coded value corresponding to each specified joint handle. Can also be NULL. Bit 0 (i.e. (1) indicates the corresponding joint is dependent of another joint.ikGroupHandle: handle of the IK group. Only IK groups that are flagged as explicitely handled will be considered as valid handles for this function. See also simGetIkGroupHandlejointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.jointValues (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.jointOptions: a bit-coded value corresponding to each specified joint handle. Can also be NULL. Bit 0 (i.e. (1) indicates the corresponding joint is dependent of another joint.ikGroupHandle: handle of the IK group. Only IK groups that are flagged as explicitely handled will be considered as valid handles for this function. See also simGetIkGroupHandlejointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.jointValues (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.jointOptions: a bit-coded value corresponding to each specified joint handle. Can also be NULL. Bit 0 (i.e. (1) indicates the corresponding joint is dependent of another joint. -1 in case of an error, otherwise an IK calculation result."
    }, 
    "simx.setSphericalJointMatrix": {
        "body": "simx.setSphericalJointMatrix(${0:clientId},${1:jointHandle},${2:matrix})", 
        "scope": "source.lua", 
        "prefix": "simx.setSphericalJointMatrix", 
        "description": "number returnCode= simx.setSphericalJointMatrix(number clientId,number jointHandle,table_12 matrix)Sets the intrinsic orientation matrix of a spherical joint object. This function cannot be used with non-spherical joints (use simx.setJointPosition instead). See also simx.getJointMatrix.. clientID: the client ID. refer to simx.start.jointHandle: handle of the jointmatrix: a table with 12 number values. See the regular API equivalent function for detailsoperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_oneshot or simx.opmode_streaming returnCode: a remote API function return code"
    }, 
    "bit32.bxor": {
        "body": "bit32.bxor(${0:...})", 
        "scope": "source.lua", 
        "prefix": "bit32.bxor", 
        "description": "5.2\n\nbit32.bxor (...)"
    }, 
    "sim.resetGraph": {
        "body": "sim.resetGraph(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.resetGraph", 
        "description": "number result = sim.resetGraph(number objectHandle)Clears a graph object (resets all its data streams). See also sim.handleGraph. graphHandle: handle of the graph object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all graph objects, while sim_handle_all_except_explicit will only reset those that are not marked as explicit handling)graphHandle: handle of the graph object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all graph objects, while sim_handle_all_except_explicit will only reset those that are not marked as explicit handling) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.buffer_uint8bgr": {
        "body": "sim.buffer_uint8bgr", 
        "scope": "source.lua", 
        "prefix": "sim.buffer_uint8bgr", 
        "description": "Constants"
    }, 
    "os.difftime": {
        "body": "os.difftime(${0:...})", 
        "scope": "source.lua", 
        "prefix": "os.difftime", 
        "description": "5.1,5.2,5.3\n\nos.difftime (t2, t1)"
    }, 
    "sim.objstringparam_dna": {
        "body": "sim.objstringparam_dna", 
        "scope": "source.lua", 
        "prefix": "sim.objstringparam_dna", 
        "description": "Constants"
    }, 
    "simx.setObjectSelection": {
        "body": "simx.setObjectSelection(${0:clientId},${1:objectHandles})", 
        "scope": "source.lua", 
        "prefix": "simx.setObjectSelection", 
        "description": "number returnCode= simx.setObjectSelection(number clientId,table objectHandles)Sets the selection state for objects. See also simx.getObjectSelection. clientID: the client ID. refer to simx.start.objectHandles: the handles of the objects to selectoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot or simx.opmode_blocking depending on the intent. returnCode: a remote API function return code"
    }, 
    "sim.sendData": {
        "body": "sim.sendData(${0:targetID},${1:dataHeader},${2:dataName},${3:data},${4:antennaHandle=sim_handle_self},${5:actionRadius=100},${6:emissionAngle1=3.1415},${7:emissionAngle2=6.283},${8:persistence=0})", 
        "scope": "source.lua", 
        "prefix": "sim.sendData", 
        "description": "number result = sim.sendData(number targetID,number dataHeader,string dataName,string data,number antennaHandle=sim_handle_self,number actionRadius=100,number emissionAngle1=3.1415,number emissionAngle2=6.283,number persistence=0)Sends (or broadcasts) wireless data (in a simulation). See also sim.receiveData and sim.tubeOpen. Cannot be called from add-ons. Wireless emissions can be visualized globally via the environment dialog, or individually as in following example:sim.setBoolParameter(sim.boolparam_force_show_wireless_emission,true)sim.sendData(...)sim.setBoolParameter(sim.boolparam_force_show_wireless_emission,false) targetID: indicates what receivers will receive the message. Can be sim_handle_all, or the handle of a scriptdataHeader: number indicating who designed the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the Help menu, in the About item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.dataName: name indicating the type of message. dataHeader and dataName will be used to filter out all unwanted messages when trying to receive a specific message (see simReceiveData)data: data to transmitdataLength: length of the data to transmitantennaHandle: handle of the scene object that should operate as the antenna for this transmission. Use sim_handle_default to simulate an antenna coinciding with the world reference frameactionRadius: radius of the transmission area. If the sender's antenna and receiver's antenna are farther apart than the actionRadius, the receiver can't receive the dataemissionAngle1: opening angle of the transmission area, vertically (along the antenna's z-axis). Value can vary between 0 and pi. If pi, and emissionAngle2 is 2pi, then the transmission area is spherical.emissionAngle2: opening angle of the transmission area, horizontally (along the antenna's x/y-axis). Value can vary between 0 and 2pi. If 2pi, and emissionAngle1 is pi, then the transmission area is spherical.persistence: the simulation time duration after which the data is not available to receivers anymore, or 0.0 for a persistence of 1.5*simulationTimeStep (default)targetID: indicates what receivers will receive the message. Can be sim_handle_all, or the handle of a scriptdataHeader: number indicating who designed the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the Help menu, in the About item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.dataName: name indicating the type of message. dataHeader and dataName will be used to filter out all unwanted messages when trying to receive a specific message (see simReceiveData)data: data to transmitdataLength: length of the data to transmitantennaHandle: handle of the scene object that should operate as the antenna for this transmission. Use sim_handle_default to simulate an antenna coinciding with the world reference frameactionRadius: radius of the transmission area. If the sender's antenna and receiver's antenna are farther apart than the actionRadius, the receiver can't receive the dataemissionAngle1: opening angle of the transmission area, vertically (along the antenna's z-axis). Value can vary between 0 and pi. If pi, and emissionAngle2 is 2pi, then the transmission area is spherical.emissionAngle2: opening angle of the transmission area, horizontally (along the antenna's x/y-axis). Value can vary between 0 and 2pi. If 2pi, and emissionAngle1 is pi, then the transmission area is spherical.persistence: the simulation time duration after which the data is not available to receivers anymore, or 0.0 for a persistence of 1.5*simulationTimeStep (default)targetID: indicates what receivers will receive the message. Can be sim_handle_all, or the handle of a scriptdataHeader: number indicating who designed the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the Help menu, in the About item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.dataName: name indicating the type of message. dataHeader and dataName will be used to filter out all unwanted messages when trying to receive a specific message (see simReceiveData)data: data to transmitdataLength: length of the data to transmitantennaHandle: handle of the scene object that should operate as the antenna for this transmission. Use sim_handle_default to simulate an antenna coinciding with the world reference frameactionRadius: radius of the transmission area. If the sender's antenna and receiver's antenna are farther apart than the actionRadius, the receiver can't receive the dataemissionAngle1: opening angle of the transmission area, vertically (along the antenna's z-axis). Value can vary between 0 and pi. If pi, and emissionAngle2 is 2pi, then the transmission area is spherical.emissionAngle2: opening angle of the transmission area, horizontally (along the antenna's x/y-axis). Value can vary between 0 and 2pi. If 2pi, and emissionAngle1 is pi, then the transmission area is spherical.persistence: the simulation time duration after which the data is not available to receivers anymore, or 0.0 for a persistence of 1.5*simulationTimeStep (default)targetID: indicates what receivers will receive the message. Can be sim_handle_all, or the handle of a scriptdataHeader: number indicating who designed the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the Help menu, in the About item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.dataName: name indicating the type of message. dataHeader and dataName will be used to filter out all unwanted messages when trying to receive a specific message (see simReceiveData)data: data to transmitdataLength: length of the data to transmitantennaHandle: handle of the scene object that should operate as the antenna for this transmission. Use sim_handle_default to simulate an antenna coinciding with the world reference frameactionRadius: radius of the transmission area. If the sender's antenna and receiver's antenna are farther apart than the actionRadius, the receiver can't receive the dataemissionAngle1: opening angle of the transmission area, vertically (along the antenna's z-axis). Value can vary between 0 and pi. If pi, and emissionAngle2 is 2pi, then the transmission area is spherical.emissionAngle2: opening angle of the transmission area, horizontally (along the antenna's x/y-axis). Value can vary between 0 and 2pi. If 2pi, and emissionAngle1 is pi, then the transmission area is spherical.persistence: the simulation time duration after which the data is not available to receivers anymore, or 0.0 for a persistence of 1.5*simulationTimeStep (default)targetID: indicates what receivers will receive the message. Can be sim_handle_all, or the handle of a scriptdataHeader: number indicating who designed the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the Help menu, in the About item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.dataName: name indicating the type of message. dataHeader and dataName will be used to filter out all unwanted messages when trying to receive a specific message (see simReceiveData)data: data to transmitdataLength: length of the data to transmitantennaHandle: handle of the scene object that should operate as the antenna for this transmission. Use sim_handle_default to simulate an antenna coinciding with the world reference frameactionRadius: radius of the transmission area. If the sender's antenna and receiver's antenna are farther apart than the actionRadius, the receiver can't receive the dataemissionAngle1: opening angle of the transmission area, vertically (along the antenna's z-axis). Value can vary between 0 and pi. If pi, and emissionAngle2 is 2pi, then the transmission area is spherical.emissionAngle2: opening angle of the transmission area, horizontally (along the antenna's x/y-axis). Value can vary between 0 and 2pi. If 2pi, and emissionAngle1 is pi, then the transmission area is spherical.persistence: the simulation time duration after which the data is not available to receivers anymore, or 0.0 for a persistence of 1.5*simulationTimeStep (default)targetID: indicates what receivers will receive the message. Can be sim_handle_all, or the handle of a scriptdataHeader: number indicating who designed the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the Help menu, in the About item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.dataName: name indicating the type of message. dataHeader and dataName will be used to filter out all unwanted messages when trying to receive a specific message (see simReceiveData)data: data to transmitdataLength: length of the data to transmitantennaHandle: handle of the scene object that should operate as the antenna for this transmission. Use sim_handle_default to simulate an antenna coinciding with the world reference frameactionRadius: radius of the transmission area. If the sender's antenna and receiver's antenna are farther apart than the actionRadius, the receiver can't receive the dataemissionAngle1: opening angle of the transmission area, vertically (along the antenna's z-axis). Value can vary between 0 and pi. If pi, and emissionAngle2 is 2pi, then the transmission area is spherical.emissionAngle2: opening angle of the transmission area, horizontally (along the antenna's x/y-axis). Value can vary between 0 and 2pi. If 2pi, and emissionAngle1 is pi, then the transmission area is spherical.persistence: the simulation time duration after which the data is not available to receivers anymore, or 0.0 for a persistence of 1.5*simulationTimeStep (default)targetID: indicates what receivers will receive the message. Can be sim_handle_all, or the handle of a scriptdataHeader: number indicating who designed the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the Help menu, in the About item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.dataName: name indicating the type of message. dataHeader and dataName will be used to filter out all unwanted messages when trying to receive a specific message (see simReceiveData)data: data to transmitdataLength: length of the data to transmitantennaHandle: handle of the scene object that should operate as the antenna for this transmission. Use sim_handle_default to simulate an antenna coinciding with the world reference frameactionRadius: radius of the transmission area. If the sender's antenna and receiver's antenna are farther apart than the actionRadius, the receiver can't receive the dataemissionAngle1: opening angle of the transmission area, vertically (along the antenna's z-axis). Value can vary between 0 and pi. If pi, and emissionAngle2 is 2pi, then the transmission area is spherical.emissionAngle2: opening angle of the transmission area, horizontally (along the antenna's x/y-axis). Value can vary between 0 and 2pi. If 2pi, and emissionAngle1 is pi, then the transmission area is spherical.persistence: the simulation time duration after which the data is not available to receivers anymore, or 0.0 for a persistence of 1.5*simulationTimeStep (default)targetID: indicates what receivers will receive the message. Can be sim_handle_all, or the handle of a scriptdataHeader: number indicating who designed the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the Help menu, in the About item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.dataName: name indicating the type of message. dataHeader and dataName will be used to filter out all unwanted messages when trying to receive a specific message (see simReceiveData)data: data to transmitdataLength: length of the data to transmitantennaHandle: handle of the scene object that should operate as the antenna for this transmission. Use sim_handle_default to simulate an antenna coinciding with the world reference frameactionRadius: radius of the transmission area. If the sender's antenna and receiver's antenna are farther apart than the actionRadius, the receiver can't receive the dataemissionAngle1: opening angle of the transmission area, vertically (along the antenna's z-axis). Value can vary between 0 and pi. If pi, and emissionAngle2 is 2pi, then the transmission area is spherical.emissionAngle2: opening angle of the transmission area, horizontally (along the antenna's x/y-axis). Value can vary between 0 and 2pi. If 2pi, and emissionAngle1 is pi, then the transmission area is spherical.persistence: the simulation time duration after which the data is not available to receivers anymore, or 0.0 for a persistence of 1.5*simulationTimeStep (default)targetID: indicates what receivers will receive the message. Can be sim_handle_all, or the handle of a scriptdataHeader: number indicating who designed the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the Help menu, in the About item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.dataName: name indicating the type of message. dataHeader and dataName will be used to filter out all unwanted messages when trying to receive a specific message (see simReceiveData)data: data to transmitdataLength: length of the data to transmitantennaHandle: handle of the scene object that should operate as the antenna for this transmission. Use sim_handle_default to simulate an antenna coinciding with the world reference frameactionRadius: radius of the transmission area. If the sender's antenna and receiver's antenna are farther apart than the actionRadius, the receiver can't receive the dataemissionAngle1: opening angle of the transmission area, vertically (along the antenna's z-axis). Value can vary between 0 and pi. If pi, and emissionAngle2 is 2pi, then the transmission area is spherical.emissionAngle2: opening angle of the transmission area, horizontally (along the antenna's x/y-axis). Value can vary between 0 and 2pi. If 2pi, and emissionAngle1 is pi, then the transmission area is spherical.persistence: the simulation time duration after which the data is not available to receivers anymore, or 0.0 for a persistence of 1.5*simulationTimeStep (default)targetID: indicates what receivers will receive the message. Can be sim_handle_all, or the handle of a scriptdataHeader: number indicating who designed the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the Help menu, in the About item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.dataName: name indicating the type of message. dataHeader and dataName will be used to filter out all unwanted messages when trying to receive a specific message (see simReceiveData)data: data to transmitdataLength: length of the data to transmitantennaHandle: handle of the scene object that should operate as the antenna for this transmission. Use sim_handle_default to simulate an antenna coinciding with the world reference frameactionRadius: radius of the transmission area. If the sender's antenna and receiver's antenna are farther apart than the actionRadius, the receiver can't receive the dataemissionAngle1: opening angle of the transmission area, vertically (along the antenna's z-axis). Value can vary between 0 and pi. If pi, and emissionAngle2 is 2pi, then the transmission area is spherical.emissionAngle2: opening angle of the transmission area, horizontally (along the antenna's x/y-axis). Value can vary between 0 and 2pi. If 2pi, and emissionAngle1 is pi, then the transmission area is spherical.persistence: the simulation time duration after which the data is not available to receivers anymore, or 0.0 for a persistence of 1.5*simulationTimeStep (default)targetID: indicates what receivers will receive the message. Can be sim_handle_all, or the handle of a scriptdataHeader: number indicating who designed the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the Help menu, in the About item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.dataName: name indicating the type of message. dataHeader and dataName will be used to filter out all unwanted messages when trying to receive a specific message (see simReceiveData)data: data to transmitdataLength: length of the data to transmitantennaHandle: handle of the scene object that should operate as the antenna for this transmission. Use sim_handle_default to simulate an antenna coinciding with the world reference frameactionRadius: radius of the transmission area. If the sender's antenna and receiver's antenna are farther apart than the actionRadius, the receiver can't receive the dataemissionAngle1: opening angle of the transmission area, vertically (along the antenna's z-axis). Value can vary between 0 and pi. If pi, and emissionAngle2 is 2pi, then the transmission area is spherical.emissionAngle2: opening angle of the transmission area, horizontally (along the antenna's x/y-axis). Value can vary between 0 and 2pi. If 2pi, and emissionAngle1 is pi, then the transmission area is spherical.persistence: the simulation time duration after which the data is not available to receivers anymore, or 0.0 for a persistence of 1.5*simulationTimeStep (default) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simQHull.compute": {
        "body": "simQHull.compute(${0:vertices})", 
        "scope": "source.lua", 
        "prefix": "simQHull.compute", 
        "description": "table vertices[,table indices]= simQHull.compute(table vertices)"
    }, 
    "sim.buttonproperty_horizontallycentered": {
        "body": "sim.buttonproperty_horizontallycentered", 
        "scope": "source.lua", 
        "prefix": "sim.buttonproperty_horizontallycentered", 
        "description": "Constants"
    }, 
    "simUI.clearTree": {
        "body": "simUI.clearTree(${0:handle},${1:id},${2:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.clearTree", 
        "description": "simUI.clearTree(number handle,number id,bool suppressEvents=true)"
    }, 
    "simUI.rescaleAxesAll": {
        "body": "simUI.rescaleAxesAll(${0:handle},${1:id},${2:onlyEnlargeX=false},${3:onlyEnlargeY=false})", 
        "scope": "source.lua", 
        "prefix": "simUI.rescaleAxesAll", 
        "description": "simUI.rescaleAxesAll(number handle,number id,bool onlyEnlargeX=false,bool onlyEnlargeY=false)"
    }, 
    "sim.proximitysensor_cone_subtype": {
        "body": "sim.proximitysensor_cone_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.proximitysensor_cone_subtype", 
        "description": "Constants"
    }, 
    "sim.getBoolParameter": {
        "body": "sim.getBoolParameter(${0:parameter})", 
        "scope": "source.lua", 
        "prefix": "sim.getBoolParameter", 
        "description": "boolean boolState = sim.getBoolParameter(number parameter)Retrieves a boolean value. See the Boolean parameter identifiers. See also sim.setBoolParameter, sim.getInt32Parameter, sim.getFloatParameter, sim.getArrayParameter and sim.getStringParameter. parameter: boolean parameter identifierparameter: boolean parameter identifier value of the parameter (0 or 1) or -1 in case of an error"
    }, 
    "sim.filtercomponent_keeporremovecolors": {
        "body": "sim.filtercomponent_keeporremovecolors", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_keeporremovecolors", 
        "description": "Constants"
    }, 
    "sim.vortex_body_primangularaxisstaticfrictionscale": {
        "body": "sim.vortex_body_primangularaxisstaticfrictionscale", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_primangularaxisstaticfrictionscale", 
        "description": "Constants"
    }, 
    "sim.object_octree_type": {
        "body": "sim.object_octree_type", 
        "scope": "source.lua", 
        "prefix": "sim.object_octree_type", 
        "description": "Constants"
    }, 
    "simUI.curve_scatter_shape.plus": {
        "body": "simUI.curve_scatter_shape.plus", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_scatter_shape.plus", 
        "description": "Constants"
    }, 
    "simUI.setUrl": {
        "body": "simUI.setUrl(${0:handle},${1:id},${2:url})", 
        "scope": "source.lua", 
        "prefix": "simUI.setUrl", 
        "description": "simUI.setUrl(number handle,number id,string url)"
    }, 
    "simUI.removeConnection": {
        "body": "simUI.removeConnection(${0:handle},${1:id},${2:srcNodeId},${3:srcOutlet},${4:dstNodeId},${5:dstInlet})", 
        "scope": "source.lua", 
        "prefix": "simUI.removeConnection", 
        "description": "simUI.removeConnection(number handle,number id,number srcNodeId,number srcOutlet,number dstNodeId,number dstInlet)"
    }, 
    "sim.dlgstyle_input": {
        "body": "sim.dlgstyle_input", 
        "scope": "source.lua", 
        "prefix": "sim.dlgstyle_input", 
        "description": "Constants"
    }, 
    "sim.addForce": {
        "body": "sim.addForce(${0:shapeHandle},${1:position},${2:force})", 
        "scope": "source.lua", 
        "prefix": "sim.addForce", 
        "description": "number result = sim.addForce(number shapeHandle,table_3 position,table_3 force)Adds a non-central force to a shape object that is dynamically enabled. Added forces are cumulative, and are reset to zero after sim.handleDynamics was called. See also sim.addForceAndTorque. shapeHandle: handle of a dynamically enabled shapeposition: pointer to 3 values that represent the relative position where the force should be applied.force: pointer to 3 values that represent the force (in relative coordinates) to add.shapeHandle: handle of a dynamically enabled shapeposition: pointer to 3 values that represent the relative position where the force should be applied.force: pointer to 3 values that represent the force (in relative coordinates) to add.shapeHandle: handle of a dynamically enabled shapeposition: pointer to 3 values that represent the relative position where the force should be applied.force: pointer to 3 values that represent the force (in relative coordinates) to add.shapeHandle: handle of a dynamically enabled shapeposition: pointer to 3 values that represent the relative position where the force should be applied.force: pointer to 3 values that represent the force (in relative coordinates) to add. -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.bullet_body_usenondefaultcollisionmargin": {
        "body": "sim.bullet_body_usenondefaultcollisionmargin", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_body_usenondefaultcollisionmargin", 
        "description": "Constants"
    }, 
    "sim.rmlMoveToJointPositions": {
        "body": "sim.rmlMoveToJointPositions(${0:jointHandles},${1:flags},${2:currentVel},${3:currentAccel},${4:maxVel},${5:maxAccel},${6:maxJerk},${7:targetPos},${8:targetVel},${9:direction=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.rmlMoveToJointPositions", 
        "description": "number result,table newPos,table newVel,table newAccel,number timeLeft = sim.rmlMoveToJointPositions(table jointHandles,number flags,table currentVel,table currentAccel,table maxVel,table maxAccel,table maxJerk,table targetPos,table targetVel,table direction=nil)"
    }, 
    "simx.return_initialize_error_flag": {
        "body": "simx.return_initialize_error_flag", 
        "scope": "source.lua", 
        "prefix": "simx.return_initialize_error_flag", 
        "description": "Constants"
    }, 
    "simOMPL.Algorithm.LBTRRT": {
        "body": "simOMPL.Algorithm.LBTRRT", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.LBTRRT", 
        "description": "Constants"
    }, 
    "sim.setReferencedHandles": {
        "body": "sim.setReferencedHandles(${0:objectHandle},${1:referencedHandles})", 
        "scope": "source.lua", 
        "prefix": "sim.setReferencedHandles", 
        "description": "number result = sim.setReferencedHandles(number objectHandle,table referencedHandles)Attaches a list of custom handles to a given scene object. Those custom handles are handles of other objects, that are linked to the given scene object (for whatever purpose). The advantage of storing references to other objects with this function is that V-REP will take care of correctly adjusting the references if needed: For instance, imaging objectA storing the handle of objectB via this function. If objectB is deleted, then the stored handle will become -1. If objectA and objectB are duplicated at the same time, then the duplicate of objectA will store the handle of the duplicate of objectB. See also sim.getReferencedHandles.  objectHandle: handle of the scene object that will store the list of handlescount: the number of handles to storereferencedHandles: a list of handles. Handles of following object types are supported: scene objects, collision objects, distance objects, IK groups, collections, and geometric constraint solver objects.reserved1: reserved for future extensionsreserved2: reserved for future extensionsobjectHandle: handle of the scene object that will store the list of handlescount: the number of handles to storereferencedHandles: a list of handles. Handles of following object types are supported: scene objects, collision objects, distance objects, IK groups, collections, and geometric constraint solver objects.reserved1: reserved for future extensionsreserved2: reserved for future extensionsobjectHandle: handle of the scene object that will store the list of handlescount: the number of handles to storereferencedHandles: a list of handles. Handles of following object types are supported: scene objects, collision objects, distance objects, IK groups, collections, and geometric constraint solver objects.reserved1: reserved for future extensionsreserved2: reserved for future extensionsobjectHandle: handle of the scene object that will store the list of handlescount: the number of handles to storereferencedHandles: a list of handles. Handles of following object types are supported: scene objects, collision objects, distance objects, IK groups, collections, and geometric constraint solver objects.reserved1: reserved for future extensionsreserved2: reserved for future extensionsobjectHandle: handle of the scene object that will store the list of handlescount: the number of handles to storereferencedHandles: a list of handles. Handles of following object types are supported: scene objects, collision objects, distance objects, IK groups, collections, and geometric constraint solver objects.reserved1: reserved for future extensionsreserved2: reserved for future extensions -1 in case of an error."
    }, 
    "sim.boolparam_video_recording_triggered": {
        "body": "sim.boolparam_video_recording_triggered", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_video_recording_triggered", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_todepthoutput": {
        "body": "sim.filtercomponent_todepthoutput", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_todepthoutput", 
        "description": "Constants"
    }, 
    "sim.newton_global_bitcoded": {
        "body": "sim.newton_global_bitcoded", 
        "scope": "source.lua", 
        "prefix": "sim.newton_global_bitcoded", 
        "description": "Constants"
    }, 
    "sim.quitSimulator": {
        "body": "sim.quitSimulator(${0:doNotDisplayMessages})", 
        "scope": "source.lua", 
        "prefix": "sim.quitSimulator", 
        "description": "sim.quitSimulator(boolean doNotDisplayMessages)Triggers a quit signal that will eventually quits the application. See also simRunSimulator. doNotDisplayMessages: when true, will force quit. -"
    }, 
    "simUI.setColumnHeaderText": {
        "body": "simUI.setColumnHeaderText(${0:handle},${1:id},${2:column},${3:text})", 
        "scope": "source.lua", 
        "prefix": "simUI.setColumnHeaderText", 
        "description": "simUI.setColumnHeaderText(number handle,number id,number column,string text)"
    }, 
    "sim.createProximitySensor": {
        "body": "sim.createProximitySensor(${0:sensorType},${1:subType},${2:options},${3:intParams},${4:floatParams},${5:color=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.createProximitySensor", 
        "description": "number sensorHandle = sim.createProximitySensor(number sensorType,number subType,number options,table_8 intParams,table_15 floatParams,table_48 color=nil)Creates a proximity sensor.  sensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default valuessensorType: the desired proximity sensor type (e.g. sim_proximitysensor_cone_subtype)subType: the desired proximity sensor sub-type (e.g. sim_objectspecialproperty_detectable_ultrasonic)options: bit-coded options:bit 0 set (1): the sensor will be explicitely handledbit 1 set (2): the detection volumes are not shown when detecting somethingbit 2 set (4): the detection volumes are not shown when not detecting anythingbit 3 set (8): front faces are not detectedbit 4 set (16): back faces are not detectedbit 5 set (32): fast detection (i.e. not exact detection)bit 6 set (64): the normal of the detected surface with the detection ray will have to lie below a specified threshold anglebit 7 set (128): occlusion check is activebit 8 set (256): smallest distance threshold will be activebit 9 set (512): randomized detection (only with ray-type proximity sensors)intParams (input): 8 integer parameters:intParams[0]: face count (volume description)intParams[1]: face count far (volume description)intParams[2]: subdivisions (volume description)intParams[3]: subdivisions far (volume description)intParams[4]: randomized detection, sample count per readingintParams[5]: randomized detection, individual ray detection count for triggeringintParams[6]: reserved. Set to 0intParams[7]: reserved. Set to 0floatParams (input): 15 floating point parameters:floatParams[0]: offset (volume description)floatParams[1]: range (volume description)floatParams[2]: x size (volume description)floatParams[3]: y size (volume description)floatParams[4]: x size far (volume description)floatParams[5]: y size far (volume description)floatParams[6]: inside gap (volume description)floatParams[7]: radius (volume description)floatParams[8]: radius far (volume description)floatParams[9]: angle (volume description)floatParams[10]: threshold angle for limited angle detection (see bit 6 above)floatParams[11]: smallest detection distance (see bit 8 above)floatParams[12]: sensing point sizefloatParams[13]: reserved. Set to 0.0floatParams[14]: reserved. Set to 0.0color: pointer to 4x4x3 values representing the various colors of the sensor ((passive, active, ray, closest distance) x (ambient_diffuse rgb, 3 reserved values (set to zer0), specular rgb and emission rgb)). Can be NULL for default values -1 if operation was not successful, otherwise the handle of the force sensor"
    }, 
    "sim.vortex_body_autoslip": {
        "body": "sim.vortex_body_autoslip", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_autoslip", 
        "description": "Constants"
    }, 
    "simx.opmode_streaming": {
        "body": "simx.opmode_streaming", 
        "scope": "source.lua", 
        "prefix": "simx.opmode_streaming", 
        "description": "Constants"
    }, 
    "sim.persistentDataWrite": {
        "body": "sim.persistentDataWrite(${0:dataName},${1:dataValue},${2:options=0})", 
        "scope": "source.lua", 
        "prefix": "sim.persistentDataWrite", 
        "description": "number result = sim.persistentDataWrite(string dataName,string dataValue,number options=0)Writes a persistent data block. Persistent data, valid across all opened simulator scenes, remains until the simulator ends, or until it is cleared by writing an empty data block. If the options flag is set appropriately, then persistent data can also be stored on file, and be automatically reloaded next time V-REP starts. See also sim.persistentDataRead, sim.setStringSignal, sim.setIntegerSignal, sim.setFloatSignal and sim.writeCustomDataBlock. dataName: name of the data blockdataValue: content of the data block (which may contain any value, including embedded zeros). If dataValue is an empty string, then the data block is cleared (if present).dataLength: the size of the data block.options: bit-coded. If bit 0 is set (1), then the data is also stored on file (system/persistentData.dat), and automatically reloaded next time V-REP start.dataName: name of the data blockdataValue: content of the data block (which may contain any value, including embedded zeros). If dataValue is an empty string, then the data block is cleared (if present).dataLength: the size of the data block.options: bit-coded. If bit 0 is set (1), then the data is also stored on file (system/persistentData.dat), and automatically reloaded next time V-REP start.dataName: name of the data blockdataValue: content of the data block (which may contain any value, including embedded zeros). If dataValue is an empty string, then the data block is cleared (if present).dataLength: the size of the data block.options: bit-coded. If bit 0 is set (1), then the data is also stored on file (system/persistentData.dat), and automatically reloaded next time V-REP start.dataName: name of the data blockdataValue: content of the data block (which may contain any value, including embedded zeros). If dataValue is an empty string, then the data block is cleared (if present).dataLength: the size of the data block.options: bit-coded. If bit 0 is set (1), then the data is also stored on file (system/persistentData.dat), and automatically reloaded next time V-REP start. -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simOMPL.Algorithm.FMT": {
        "body": "simOMPL.Algorithm.FMT", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.FMT", 
        "description": "Constants"
    }, 
    "sim.objfloatparam_objbbox_min_y": {
        "body": "sim.objfloatparam_objbbox_min_y", 
        "scope": "source.lua", 
        "prefix": "sim.objfloatparam_objbbox_min_y", 
        "description": "Constants"
    }, 
    "sim.checkVisionSensorEx": {
        "body": "sim.checkVisionSensorEx(${0:sensorHandle},${1:entityHandle},${2:returnImage})", 
        "scope": "source.lua", 
        "prefix": "sim.checkVisionSensorEx", 
        "description": "table buffer = sim.checkVisionSensorEx(number sensorHandle,number entityHandle,boolean returnImage)Checks whether the vision sensor detects the indicated entity. This is the extended functionality version of sim.checkVisionSensor. Detection is silent (no visual feedback) compared to sim.handleVisionSensor. Also, the renderable flag of the entity is overridden if the entity is an object. See also sim.readVisionSensor.  sensorHandle: handle of the vision sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsreturnImage: specifies what should be returned. If true, the sensor's image buffer is returned, otherwise its depth buffer is returnedsensorHandle: handle of the vision sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsreturnImage: specifies what should be returned. If true, the sensor's image buffer is returned, otherwise its depth buffer is returnedsensorHandle: handle of the vision sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsreturnImage: specifies what should be returned. If true, the sensor's image buffer is returned, otherwise its depth buffer is returnedsensorHandle: handle of the vision sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsreturnImage: specifies what should be returned. If true, the sensor's image buffer is returned, otherwise its depth buffer is returned image or depth buffer (use simGetVisionSensorResolution for correct size), or NULL in case of an error. The user is in charge of releasing the returned buffer with simReleaseBuffer"
    }, 
    "table.move": {
        "body": "table.move(${0:...})", 
        "scope": "source.lua", 
        "prefix": "table.move", 
        "description": "5.3\n\ntable.move (a1, f, e, t [,a2])"
    }, 
    "sim.handleIkGroup": {
        "body": "sim.handleIkGroup(${0:ikGroupHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.handleIkGroup", 
        "description": "number performedIkGroupCalculationCount = sim.handleIkGroup(number ikGroupHandle)Handles (solves) a registered IK group. IK groups can be registered while editing a scene. See also sim.checkIkGroup, sim.computeJacobian and sim.generateIkPath. ikGroupHandle: handle of the IK group or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all IK groups, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling). See also simGetIkGroupHandle. number of performed calculations (i.e. IK group calculation results are different from sim_ikresult_not_performed) if no specific IK group was specified, or a value of type IK result if a specific IK group was specified, -1 in case of an error (a failed IK group calculation is not considered as an error)"
    }, 
    "sysCall_customCallback1": {
        "body": "sysCall_customCallback1(${0:script.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_customCallback1", 
        "description": "sysCall_customCallback1(Can be called by a customized main script.)"
    }, 
    "sim.appobj_ik_type": {
        "body": "sim.appobj_ik_type", 
        "scope": "source.lua", 
        "prefix": "sim.appobj_ik_type", 
        "description": "Constants"
    }, 
    "sysCall_customCallback3": {
        "body": "sysCall_customCallback3(${0:script.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_customCallback3", 
        "description": "sysCall_customCallback3(Can be called by a customized main script.)"
    }, 
    "sim.visionintparam_entity_to_render": {
        "body": "sim.visionintparam_entity_to_render", 
        "scope": "source.lua", 
        "prefix": "sim.visionintparam_entity_to_render", 
        "description": "Constants"
    }, 
    "sysCall_customCallback4": {
        "body": "sysCall_customCallback4(${0:script.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_customCallback4", 
        "description": "sysCall_customCallback4(Can be called by a customized main script.)"
    }, 
    "simUI.curve_scatter_shape.plus_square": {
        "body": "simUI.curve_scatter_shape.plus_square", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_scatter_shape.plus_square", 
        "description": "Constants"
    }, 
    "sim.ode_global_bitcoded": {
        "body": "sim.ode_global_bitcoded", 
        "scope": "source.lua", 
        "prefix": "sim.ode_global_bitcoded", 
        "description": "Constants"
    }, 
    "sim.generateIkPath": {
        "body": "sim.generateIkPath(${0:ikGroupHandle},${1:jointHandles},${2:ptCnt},${3:collisionPairs=nil},${4:jointOptions=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.generateIkPath", 
        "description": "table path = sim.generateIkPath(number ikGroupHandle,table jointHandles,number ptCnt,table collisionPairs=nil,table jointOptions=nil)Generates a path that drives a robot from its current configuration to its target dummy in a straight line (i.e. shortest path in Cartesian space). ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.ptCnt: the desired number of path points. Each path point contains a robot configuration. A minimum of two path points is required. If the tip-target dummy distance is large, a larger number for ptCnt leads to better results for this function.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.ptCnt: the desired number of path points. Each path point contains a robot configuration. A minimum of two path points is required. If the tip-target dummy distance is large, a larger number for ptCnt leads to better results for this function.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.ptCnt: the desired number of path points. Each path point contains a robot configuration. A minimum of two path points is required. If the tip-target dummy distance is large, a larger number for ptCnt leads to better results for this function.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.ptCnt: the desired number of path points. Each path point contains a robot configuration. A minimum of two path points is required. If the tip-target dummy distance is large, a larger number for ptCnt leads to better results for this function.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.ptCnt: the desired number of path points. Each path point contains a robot configuration. A minimum of two path points is required. If the tip-target dummy distance is large, a larger number for ptCnt leads to better results for this function.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.ptCnt: the desired number of path points. Each path point contains a robot configuration. A minimum of two path points is required. If the tip-target dummy distance is large, a larger number for ptCnt leads to better results for this function.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.ptCnt: the desired number of path points. Each path point contains a robot configuration. A minimum of two path points is required. If the tip-target dummy distance is large, a larger number for ptCnt leads to better results for this function.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.ptCnt: the desired number of path points. Each path point contains a robot configuration. A minimum of two path points is required. If the tip-target dummy distance is large, a larger number for ptCnt leads to better results for this function.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.reserved: reserved for future extension. Set to NULL. a pointer to the computed path, or NULL if no path could be computed. The pointer points to ptCnt*jointCnt values, representing ptCnt robot configurations. The user is in charge of releasing the returned array with simReleaseBuffer."
    }, 
    "math.acos": {
        "body": "math.acos( ${1:x} )", 
        "scope": "source.lua", 
        "prefix": "math.acos", 
        "description": "5.1,5.2,5.3\n\nmath.acos"
    }, 
    "sim.filtercomponent_sharpen": {
        "body": "sim.filtercomponent_sharpen", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_sharpen", 
        "description": "Constants"
    }, 
    "simOMPL.StateSpaceType.joint_position": {
        "body": "simOMPL.StateSpaceType.joint_position", 
        "scope": "source.lua", 
        "prefix": "simOMPL.StateSpaceType.joint_position", 
        "description": "Constants"
    }, 
    "bit32.bor": {
        "body": "bit32.bor(${0:...})", 
        "scope": "source.lua", 
        "prefix": "bit32.bor", 
        "description": "5.2\n\nbit32.bor (...)"
    }, 
    "simMTB.getInput": {
        "body": "simMTB.getInput()", 
        "scope": "source.lua", 
        "prefix": "simMTB.getInput", 
        "description": "table_4 inputValues= simMTB.getInput()"
    }, 
    "sim.getObjectChild": {
        "body": "sim.getObjectChild(${0:objectHandle},${1:index})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectChild", 
        "description": "number childObjectHandle = sim.getObjectChild(number objectHandle,number index)Retrieves the handle of an object's child object. See also sim.getObjectParent and sim.getObjectsInTree. objectHandle: handle of the objectindex: zero-based index of the child's position. To retrieve all children of an object, call the function by increasing the index until the return value is -1objectHandle: handle of the objectindex: zero-based index of the child's position. To retrieve all children of an object, call the function by increasing the index until the return value is -1objectHandle: handle of the objectindex: zero-based index of the child's position. To retrieve all children of an object, call the function by increasing the index until the return value is -1 handle of child object or -1 if the child doesn't exist at that index or in case of an error"
    }, 
    "sim.tubeOpen": {
        "body": "sim.tubeOpen(${0:dataHeader},${1:dataName},${2:readBufferSize})", 
        "scope": "source.lua", 
        "prefix": "sim.tubeOpen", 
        "description": "number tubeHandle = sim.tubeOpen(number dataHeader,string dataName,number readBufferSize)Opens a tube for communication within V-REP. A tube is similar to a bidirectional communication pipe. Messages written on one side can be read on the other side in the same order as they were written. Tubes opened via a script will automatically close upon simulation end. A scene switch will close all communication tubes and tube handles will not be valid anymore. See also sim.tubeClose, sim.tubeWrite, sim.tubeRead, sim.tubeStatus, sim.sendData and sim.receiveData. dataHeader: number indicating who designed the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the Help menu, in the About item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.dataName: name indicating the type of message. A tube will only be able to connect if its two sides have the same dataHeader and dataNamereadBufferSize: the number of data packets that can be stored in the input buffer of this side of the tubenotUsedButKeepFalse: not used. Keep to false.dataHeader: number indicating who designed the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the Help menu, in the About item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.dataName: name indicating the type of message. A tube will only be able to connect if its two sides have the same dataHeader and dataNamereadBufferSize: the number of data packets that can be stored in the input buffer of this side of the tubenotUsedButKeepFalse: not used. Keep to false.dataHeader: number indicating who designed the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the Help menu, in the About item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.dataName: name indicating the type of message. A tube will only be able to connect if its two sides have the same dataHeader and dataNamereadBufferSize: the number of data packets that can be stored in the input buffer of this side of the tubenotUsedButKeepFalse: not used. Keep to false.dataHeader: number indicating who designed the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the Help menu, in the About item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.dataName: name indicating the type of message. A tube will only be able to connect if its two sides have the same dataHeader and dataNamereadBufferSize: the number of data packets that can be stored in the input buffer of this side of the tubenotUsedButKeepFalse: not used. Keep to false.dataHeader: number indicating who designed the communication message. Always use the same header (because only you will know the meaning of the message) and stick to it. The best is to use the serial number of your V-REP copy (check the Help menu, in the About item for the serial number). Otherwise, you risk collision with other developer's messages which might use the same header as yours.dataName: name indicating the type of message. A tube will only be able to connect if its two sides have the same dataHeader and dataNamereadBufferSize: the number of data packets that can be stored in the input buffer of this side of the tubenotUsedButKeepFalse: not used. Keep to false. -1 if operation was not successful, otherwise the tube handle."
    }, 
    "sim.ode_body_angulardamping": {
        "body": "sim.ode_body_angulardamping", 
        "scope": "source.lua", 
        "prefix": "sim.ode_body_angulardamping", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_intrinsic_qw": {
        "body": "sim.jointfloatparam_intrinsic_qw", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_intrinsic_qw", 
        "description": "Constants"
    }, 
    "simx.setStringSignal": {
        "body": "simx.setStringSignal(${0:clientId},${1:signalName},${2:signalValue})", 
        "scope": "source.lua", 
        "prefix": "simx.setStringSignal", 
        "description": "number returnCode= simx.setStringSignal(number clientId,string signalName,string signalValue)Sets the value of a string signal. If that signal is not yet present, it is added. To pack/unpack integers/floats into/from a string, refer to simx.packInts, simx.packFloats, simx.unpackInts and simx.unpackFloats. See also simx.writeStringStream, simx.getStringSignal, simx.clearStringSignal, simx.setIntegerSignal and simx.setFloatSignal. clientID: the client ID. refer to simx.start.signalName: name of the signalsignalValue: value of the signal (which may contain any value, including embedded zeros)operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "sim.jointfloatparam_intrinsic_qz": {
        "body": "sim.jointfloatparam_intrinsic_qz", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_intrinsic_qz", 
        "description": "Constants"
    }, 
    "sim.handleMechanism": {
        "body": "sim.handleMechanism(${0:mechanismHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.handleMechanism", 
        "description": "number result = sim.handleMechanism(number mechanismHandle)Handles a mechanism registered with the geometric constraint solver functionality. Mechanisms can be registered while editing a scene. mechanismHandle: handle of the mechanism or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all registered mechanisms, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling)mechanismHandle: handle of the mechanism or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will handle all registered mechanisms, while sim_handle_all_except_explicit will only handle those that are not marked as explicit handling) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.jointfloatparam_intrinsic_qx": {
        "body": "sim.jointfloatparam_intrinsic_qx", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_intrinsic_qx", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_intrinsic_qy": {
        "body": "sim.jointfloatparam_intrinsic_qy", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_intrinsic_qy", 
        "description": "Constants"
    }, 
    "sim.setJointMode": {
        "body": "sim.setJointMode(${0:jointHandle},${1:jointMode},${2:options})", 
        "scope": "source.lua", 
        "prefix": "sim.setJointMode", 
        "description": "number result = sim.setJointMode(number jointHandle,number jointMode,number options)Sets the operation mode of a joint. Might have as side-effect the change of additional properties of the joint. See also sim.getJointMode. jointHandle: handle of the joint objectjointMode: a joint mode valueoptions: bit-coded. For now only bit 0 is used (if set (1), the joint operates in hybrid mode)jointHandle: handle of the joint objectjointMode: a joint mode valueoptions: bit-coded. For now only bit 0 is used (if set (1), the joint operates in hybrid mode)jointHandle: handle of the joint objectjointMode: a joint mode valueoptions: bit-coded. For now only bit 0 is used (if set (1), the joint operates in hybrid mode)jointHandle: handle of the joint objectjointMode: a joint mode valueoptions: bit-coded. For now only bit 0 is used (if set (1), the joint operates in hybrid mode) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simUI.getCurrentTab": {
        "body": "simUI.getCurrentTab(${0:handle},${1:id})", 
        "scope": "source.lua", 
        "prefix": "simUI.getCurrentTab", 
        "description": "number index = simUI.getCurrentTab(number handle,number id)"
    }, 
    "sim.boolparam_console_visible": {
        "body": "sim.boolparam_console_visible", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_console_visible", 
        "description": "Constants"
    }, 
    "sim.intparam_mouse_x": {
        "body": "sim.intparam_mouse_x", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_mouse_x", 
        "description": "Constants"
    }, 
    "sim.intparam_mouse_y": {
        "body": "sim.intparam_mouse_y", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_mouse_y", 
        "description": "Constants"
    }, 
    "simUI.setTableSelection": {
        "body": "simUI.setTableSelection(${0:handle},${1:id},${2:row},${3:column},${4:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setTableSelection", 
        "description": "simUI.setTableSelection(number handle,number id,number row,number column,bool suppressEvents=true)"
    }, 
    "sim.ik_pseudo_inverse_method": {
        "body": "sim.ik_pseudo_inverse_method", 
        "scope": "source.lua", 
        "prefix": "sim.ik_pseudo_inverse_method", 
        "description": "Constants"
    }, 
    "sim.vortex_body_primlinearaxisfrictionmodel": {
        "body": "sim.vortex_body_primlinearaxisfrictionmodel", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_primlinearaxisfrictionmodel", 
        "description": "Constants"
    }, 
    "sim.setPointCloudOptions": {
        "body": "sim.setPointCloudOptions(${0:pointCloudHandle},${1:maxVoxelSize},${2:maxPtCntPerVoxel},${3:options},${4:pointSize})", 
        "scope": "source.lua", 
        "prefix": "sim.setPointCloudOptions", 
        "description": "number result = sim.setPointCloudOptions(number pointCloudHandle,number maxVoxelSize,number maxPtCntPerVoxel,number options,number pointSize)Sets various properties of a point cloud. See also sim.getPointCloudOptions and the other point cloud related functions. pointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandlemaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULL 1 if operation was successful"
    }, 
    "simVision.handleSpherical": {
        "body": "simVision.handleSpherical(${0:passiveVisionSensorHandleForRGB},${1:activeVisionSensorHandles},${2:horizontalAngle},${3:verticalAngle})", 
        "scope": "source.lua", 
        "prefix": "simVision.handleSpherical", 
        "description": "number result= simVision.handleSpherical(number passiveVisionSensorHandleForRGB,table_6 activeVisionSensorHandles,\nnumber horizontalAngle,number verticalAngle)"
    }, 
    "sim.createDummy": {
        "body": "sim.createDummy(${0:size},${1:color=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.createDummy", 
        "description": "number dummyHandle = sim.createDummy(number size,table_12 color=nil)Creates a dummy.  size: the dummy sizecolor: pointer to 4x3 values representing the dummy color (ambient/diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default valuessize: the dummy sizecolor: pointer to 4x3 values representing the dummy color (ambient/diffuse rgb, 3 reserved values (set to zero), specular rgb and emission rgb). Can be NULL for default values -1 if operation was not successful, otherwise the handle of the dummy"
    }, 
    "simx.setObjectOrientation": {
        "body": "simx.setObjectOrientation(${0:clientId},${1:objectHandle},${2:relativeToObjectHandle},${3:eulerAngles})", 
        "scope": "source.lua", 
        "prefix": "simx.setObjectOrientation", 
        "description": "number returnCode= simx.setObjectOrientation(number clientId,number objectHandle,number relativeToObjectHandle,table_3 eulerAngles)Sets the orientation (Euler angles) of an object. Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling sim.resetDynamicObject just before). See also simx.getObjectOrientation, simx.setObjectQuaternion and simx.setObjectPosition. clientID: the client ID. refer to simx.start.objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the orientation is specified. Specify -1 to set the absolute orientation, sim.handle_parent to set the orientation relative to the object's parent, or an object handle relative to whose reference frame the orientation is specified.eulerAngles: Euler angles (alpha, beta and gamma)operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "simx.setArrayParameter": {
        "body": "simx.setArrayParameter(${0:clientId},${1:paramIdentifier},${2:paramValues})", 
        "scope": "source.lua", 
        "prefix": "simx.setArrayParameter", 
        "description": "number returnCode= simx.setArrayParameter(number clientId,number paramIdentifier,table_3 paramValues)Sets 3 values of an array parameter. See also simx.getArrayParameter, simx.setBooleanParameter, simx.setIntegerParameter and simx.setFloatingParameter. clientID: the client ID. refer to simx.start.paramIdentifier: an array parameter identifierparamValues: a tablecontaining the 3 values to setoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "simx.cmdheaderoffset_mem_size": {
        "body": "simx.cmdheaderoffset_mem_size", 
        "scope": "source.lua", 
        "prefix": "simx.cmdheaderoffset_mem_size", 
        "description": "Constants"
    }, 
    "sim.objectspecialproperty_detectable_ultrasonic": {
        "body": "sim.objectspecialproperty_detectable_ultrasonic", 
        "scope": "source.lua", 
        "prefix": "sim.objectspecialproperty_detectable_ultrasonic", 
        "description": "Constants"
    }, 
    "string.rep": {
        "body": "string.rep( ${1:s}, ${2:n}${3:[, rep]} )", 
        "scope": "source.lua", 
        "prefix": "string.rep", 
        "description": "5.1,5.2,5.3\n\nstring.rep"
    }, 
    "simUI.expandAll": {
        "body": "simUI.expandAll(${0:handle},${1:id},${2:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.expandAll", 
        "description": "simUI.expandAll(number handle,number id,bool suppressEvents=true)"
    }, 
    "sim.vortex_body_primlinearaxisslip": {
        "body": "sim.vortex_body_primlinearaxisslip", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_primlinearaxisslip", 
        "description": "Constants"
    }, 
    "next": {
        "body": "next(${1:table}${2:[, index]})", 
        "scope": "source.lua", 
        "prefix": "next", 
        "description": "5.1,5.2,5.3\n\nnext (table [, index])"
    }, 
    "sim.ode_joint_fudgefactor": {
        "body": "sim.ode_joint_fudgefactor", 
        "scope": "source.lua", 
        "prefix": "sim.ode_joint_fudgefactor", 
        "description": "Constants"
    }, 
    "simx.getConnectionId": {
        "body": "simx.getConnectionId()", 
        "scope": "source.lua", 
        "prefix": "simx.getConnectionId", 
        "description": "number connectionId= simx.getConnectionId()Returns the ID of the current connection. Use this function to track the connection state to the server. See also simx.start. This is a remote API helper function. clientID: the client ID. refer to simx.start. connectionID: a connection ID, or -1 if the client is not connected to the server. Different connection IDs indicate temporary disconections in-between."
    }, 
    "simUI.mouse.move": {
        "body": "simUI.mouse.move", 
        "scope": "source.lua", 
        "prefix": "simUI.mouse.move", 
        "description": "Constants"
    }, 
    "sim.vortex_body_normangaxissameasprimangaxis": {
        "body": "sim.vortex_body_normangaxissameasprimangaxis", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_normangaxissameasprimangaxis", 
        "description": "Constants"
    }, 
    "sim.invertMatrix": {
        "body": "sim.invertMatrix(${0:matrix})", 
        "scope": "source.lua", 
        "prefix": "sim.invertMatrix", 
        "description": "number result = sim.invertMatrix(table_12 matrix)Inverts a transformation matrix. See also the other matrix/transformation functions. matrix: pointer to 12 simFloat values representing the matrix that should be inverted (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrix: pointer to 12 simFloat values representing the matrix that should be inverted (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrix: pointer to 12 simFloat values representing the matrix that should be inverted (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrix: pointer to 12 simFloat values representing the matrix that should be inverted (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrix: pointer to 12 simFloat values representing the matrix that should be inverted (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11]) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.vortex_body_secangularaxisslide": {
        "body": "sim.vortex_body_secangularaxisslide", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_secangularaxisslide", 
        "description": "Constants"
    }, 
    "sim.vortex_global_bitcoded": {
        "body": "sim.vortex_global_bitcoded", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_global_bitcoded", 
        "description": "Constants"
    }, 
    "sim.stopSimulation": {
        "body": "sim.stopSimulation()", 
        "scope": "source.lua", 
        "prefix": "sim.stopSimulation", 
        "description": "number result = sim.stopSimulation()Requests a stop of the running simulation. See also sim.startSimulation, sim.pauseSimulation and sim.getSimulationState. See also the simulation state diagram. None -1 in case of an error, 0 if the operation could not be performed. >0 in case of success."
    }, 
    "simx.getStringParameter": {
        "body": "simx.getStringParameter(${0:clientId},${1:paramIdentifier})", 
        "scope": "source.lua", 
        "prefix": "simx.getStringParameter", 
        "description": "number returnCode,string paramValue= simx.getStringParameter(number clientId,number paramIdentifier)Retrieves a string value. See the string parameter identifiers. See also simx.getBooleanParameter, simx.getIntegerParameter, simx.getArrayParameter and simx.getFloatingParameter. clientID: the client ID. refer to simx.start.paramIdentifier: a string parameter identifieroperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking (if not called on a regular basis) returnCode: a remote API function return codeparamValue: the string value"
    }, 
    "simURDF.import": {
        "body": "simURDF.import(${0:urdf},${1:hideCollisionLinks},${2:hideJoints},${3:convexDecomposeNonConvexCollidables},${4:createVisualIfNone},${5:showConvexDecompositionDlg},${6:centerAboveGround},${7:makeModel},${8:noSelfCollision},${9:positionCtrl})", 
        "scope": "source.lua", 
        "prefix": "simURDF.import", 
        "description": "string robot_name= simURDF.import(string urdf,bool hideCollisionLinks,bool hideJoints,bool convexDecomposeNonConvexCollidables,bool createVisualIfNone,bool showConvexDecompositionDlg,bool centerAboveGround,bool makeModel,bool noSelfCollision,bool positionCtrl)"
    }, 
    "simOMPL.setProjectionEvaluationCallback": {
        "body": "simOMPL.setProjectionEvaluationCallback(${0:taskHandle},${1:callback},${2:projectionSize})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.setProjectionEvaluationCallback", 
        "description": "number result = simOMPL.setProjectionEvaluationCallback(number taskHandle,string callback,number projectionSize)"
    }, 
    "sim.dynmat_gripper": {
        "body": "sim.dynmat_gripper", 
        "scope": "source.lua", 
        "prefix": "sim.dynmat_gripper", 
        "description": "Constants"
    }, 
    "sim.unpackInt32Table": {
        "body": "sim.unpackInt32Table(${0:data},${1:startInt32Index=0},${2:int32Count=0},${3:additionalByteOffset=0})", 
        "scope": "source.lua", 
        "prefix": "sim.unpackInt32Table", 
        "description": "table int32Numbers = sim.unpackInt32Table(string data,number startInt32Index=0,number int32Count=0,number additionalByteOffset=0)Unpacks a string (or part of it) into a table of int32 numbers. See also sim.packInt32Table and the other packing/unpacking functions. - -"
    }, 
    "xpcall": {
        "body": "xpcall(${0:...})", 
        "scope": "source.lua", 
        "prefix": "xpcall", 
        "description": "5.1,5.2,5.3\n\nxpcall (f, err)"
    }, 
    "package.path": {
        "body": "package.path(${0:...})", 
        "scope": "source.lua", 
        "prefix": "package.path", 
        "description": "5.1,5.2,5.3\n\npackage.path"
    }, 
    "sim.jointfloatparam_intrinsic_x": {
        "body": "sim.jointfloatparam_intrinsic_x", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_intrinsic_x", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_intrinsic_y": {
        "body": "sim.jointfloatparam_intrinsic_y", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_intrinsic_y", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_intrinsic_z": {
        "body": "sim.jointfloatparam_intrinsic_z", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_intrinsic_z", 
        "description": "Constants"
    }, 
    "sim.handleSimulationStart": {
        "body": "sim.handleSimulationStart()", 
        "scope": "source.lua", 
        "prefix": "sim.handleSimulationStart", 
        "description": "number result = sim.handleSimulationStart()Initializes various functionality (e.g. camera tracking during simulation, object velocity calculation, etc.). Should only be called from the main script, as the first instruction in the initialization section. See also sim.handleSensingStart. - -"
    }, 
    "sim.displayattribute_mirror": {
        "body": "sim.displayattribute_mirror", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_mirror", 
        "description": "Constants"
    }, 
    "sim.tubeWrite": {
        "body": "sim.tubeWrite(${0:tubeHandle},${1:data})", 
        "scope": "source.lua", 
        "prefix": "sim.tubeWrite", 
        "description": "number result = sim.tubeWrite(number tubeHandle,string data)Sends a data packet into a communication tube previously opened with sim.tubeOpen. The tube needs to be connected (see sim.tubeStatus). tubeHandle: the handle of the tube that was returned by the simTubeOpen function.data: pointer to a data packet. simTubeWrite will copy that packet so that it can directly be releaseddataLength: size of the data packettubeHandle: the handle of the tube that was returned by the simTubeOpen function.data: pointer to a data packet. simTubeWrite will copy that packet so that it can directly be releaseddataLength: size of the data packettubeHandle: the handle of the tube that was returned by the simTubeOpen function.data: pointer to a data packet. simTubeWrite will copy that packet so that it can directly be releaseddataLength: size of the data packettubeHandle: the handle of the tube that was returned by the simTubeOpen function.data: pointer to a data packet. simTubeWrite will copy that packet so that it can directly be releaseddataLength: size of the data packet 1 if operation was successful. In a future release, a more differentiated return value might be available"
    }, 
    "utf8.char": {
        "body": "utf8.char(${0:...})", 
        "scope": "source.lua", 
        "prefix": "utf8.char", 
        "description": "5.3\n\nutf8.char (...)"
    }, 
    "sim.getIkGroupMatrix": {
        "body": "sim.getIkGroupMatrix(${0:ikGroupHandle},${1:options})", 
        "scope": "source.lua", 
        "prefix": "sim.getIkGroupMatrix", 
        "description": "table matrix,table_2 matrixSize = sim.getIkGroupMatrix(number ikGroupHandle,number options)Retrieves various information from an IK group, such as the Jacobian. For the result to be valid, the Jacobian must previously have been computed via the sim.computeJacobian, sim.handleIkGroup or sim.checkIkGroup functions. Following situations have to be differentiated:a) If you call sim.computeJacobian just before calling sim.getIkGroupMatrix, then the returned Jacobian will be the one at the current state/configuration of the mechanism. This is the recommended way to retrieve the Jacobian.b) If you call sim.handleIkGroup or sim.checkIkGroup just before calling sim.getIkGroupMatrix, then the returned Jacobian will be the one computed last, while trying to reach the target (since it usually takes at least 2-3 iterations to reach a target because of the linearization), which is not the current state/configuration of the mechanism, unless the target overlaps the tip.See also sim.getIkGroupHandle. ikGroupHandle: handle of an IK groupoptions: a value indicating what kind of information to retrieve:0: to retrieve the last calculated Jacobian. matrixSize[0] is the number of rows (the number of DoFs), matrixSize[1] is the number of columns. See further down how to extract the Jacobian.1: to retrieve the manipulability value, i.e. sqrt(det(J*JT)), where J is the Jacobian, and JT the Jacobian transpose. The returned pointer points onto a single value.matrixSize: the dimensions of the returned matrix (x=rows, y=columns)USAGE EXAMPLE (to correctly interpret the Jacobian):float jacobianSize[2];float* jacobian=simGetIkGroupMatrix(ikGroupHandle,0,jacobianSize);// jacobianSize[0] represents the row count of the Jacobian // (i.e. the number of equations or the number of joints involved// in the IK resolution of the given kinematic chain)// Joints appear from tip to base.// jacobianSize[1] represents the column count of the Jacobian // (i.e. the number of constraints, e.g. x,y,z,alpha,beta,gamma,jointDependency)// The Jacobian data is ordered row-wise, i.e.:// [row0,col0],[row1,col0],..,[rowN,col0],[row0,col1],[row1,col1],etc.for (int i=0;i<jacobianSize[0];i++){    std::string str;    for (int j=0;j<jacobianSize[1];j++)    {        if (str.size()==0)            str+=, ;        str+=boost::str(boost::format(%.1e) % jacobian[j*jacobianSize[0]+i]);    }    printf(str.c_str());}ikGroupHandle: handle of an IK groupoptions: a value indicating what kind of information to retrieve:0: to retrieve the last calculated Jacobian. matrixSize[0] is the number of rows (the number of DoFs), matrixSize[1] is the number of columns. See further down how to extract the Jacobian.1: to retrieve the manipulability value, i.e. sqrt(det(J*JT)), where J is the Jacobian, and JT the Jacobian transpose. The returned pointer points onto a single value.matrixSize: the dimensions of the returned matrix (x=rows, y=columns)USAGE EXAMPLE (to correctly interpret the Jacobian):float jacobianSize[2];float* jacobian=simGetIkGroupMatrix(ikGroupHandle,0,jacobianSize);// jacobianSize[0] represents the row count of the Jacobian // (i.e. the number of equations or the number of joints involved// in the IK resolution of the given kinematic chain)// Joints appear from tip to base.// jacobianSize[1] represents the column count of the Jacobian // (i.e. the number of constraints, e.g. x,y,z,alpha,beta,gamma,jointDependency)// The Jacobian data is ordered row-wise, i.e.:// [row0,col0],[row1,col0],..,[rowN,col0],[row0,col1],[row1,col1],etc.for (int i=0;i<jacobianSize[0];i++){    std::string str;    for (int j=0;j<jacobianSize[1];j++)    {        if (str.size()==0)            str+=, ;        str+=boost::str(boost::format(%.1e) % jacobian[j*jacobianSize[0]+i]);    }    printf(str.c_str());}ikGroupHandle: handle of an IK groupoptions: a value indicating what kind of information to retrieve:0: to retrieve the last calculated Jacobian. matrixSize[0] is the number of rows (the number of DoFs), matrixSize[1] is the number of columns. See further down how to extract the Jacobian.1: to retrieve the manipulability value, i.e. sqrt(det(J*JT)), where J is the Jacobian, and JT the Jacobian transpose. The returned pointer points onto a single value.matrixSize: the dimensions of the returned matrix (x=rows, y=columns)USAGE EXAMPLE (to correctly interpret the Jacobian):float jacobianSize[2];float* jacobian=simGetIkGroupMatrix(ikGroupHandle,0,jacobianSize);// jacobianSize[0] represents the row count of the Jacobian // (i.e. the number of equations or the number of joints involved// in the IK resolution of the given kinematic chain)// Joints appear from tip to base.// jacobianSize[1] represents the column count of the Jacobian // (i.e. the number of constraints, e.g. x,y,z,alpha,beta,gamma,jointDependency)// The Jacobian data is ordered row-wise, i.e.:// [row0,col0],[row1,col0],..,[rowN,col0],[row0,col1],[row1,col1],etc.for (int i=0;i<jacobianSize[0];i++){    std::string str;    for (int j=0;j<jacobianSize[1];j++)    {        if (str.size()==0)            str+=, ;        str+=boost::str(boost::format(%.1e) % jacobian[j*jacobianSize[0]+i]);    }    printf(str.c_str());}ikGroupHandle: handle of an IK groupoptions: a value indicating what kind of information to retrieve:0: to retrieve the last calculated Jacobian. matrixSize[0] is the number of rows (the number of DoFs), matrixSize[1] is the number of columns. See further down how to extract the Jacobian.1: to retrieve the manipulability value, i.e. sqrt(det(J*JT)), where J is the Jacobian, and JT the Jacobian transpose. The returned pointer points onto a single value.matrixSize: the dimensions of the returned matrix (x=rows, y=columns)USAGE EXAMPLE (to correctly interpret the Jacobian):float jacobianSize[2];float* jacobian=simGetIkGroupMatrix(ikGroupHandle,0,jacobianSize);// jacobianSize[0] represents the row count of the Jacobian // (i.e. the number of equations or the number of joints involved// in the IK resolution of the given kinematic chain)// Joints appear from tip to base.// jacobianSize[1] represents the column count of the Jacobian // (i.e. the number of constraints, e.g. x,y,z,alpha,beta,gamma,jointDependency)// The Jacobian data is ordered row-wise, i.e.:// [row0,col0],[row1,col0],..,[rowN,col0],[row0,col1],[row1,col1],etc.for (int i=0;i<jacobianSize[0];i++){    std::string str;    for (int j=0;j<jacobianSize[1];j++)    {        if (str.size()==0)            str+=, ;        str+=boost::str(boost::format(%.1e) % jacobian[j*jacobianSize[0]+i]);    }    printf(str.c_str());}ikGroupHandle: handle of an IK groupoptions: a value indicating what kind of information to retrieve:0: to retrieve the last calculated Jacobian. matrixSize[0] is the number of rows (the number of DoFs), matrixSize[1] is the number of columns. See further down how to extract the Jacobian.1: to retrieve the manipulability value, i.e. sqrt(det(J*JT)), where J is the Jacobian, and JT the Jacobian transpose. The returned pointer points onto a single value.matrixSize: the dimensions of the returned matrix (x=rows, y=columns)USAGE EXAMPLE (to correctly interpret the Jacobian):float jacobianSize[2];float* jacobian=simGetIkGroupMatrix(ikGroupHandle,0,jacobianSize);// jacobianSize[0] represents the row count of the Jacobian // (i.e. the number of equations or the number of joints involved// in the IK resolution of the given kinematic chain)// Joints appear from tip to base.// jacobianSize[1] represents the column count of the Jacobian // (i.e. the number of constraints, e.g. x,y,z,alpha,beta,gamma,jointDependency)// The Jacobian data is ordered row-wise, i.e.:// [row0,col0],[row1,col0],..,[rowN,col0],[row0,col1],[row1,col1],etc.for (int i=0;i<jacobianSize[0];i++){    std::string str;    for (int j=0;j<jacobianSize[1];j++)    {        if (str.size()==0)            str+=, ;        str+=boost::str(boost::format(%.1e) % jacobian[j*jacobianSize[0]+i]);    }    printf(str.c_str());}ikGroupHandle: handle of an IK groupoptions: a value indicating what kind of information to retrieve:0: to retrieve the last calculated Jacobian. matrixSize[0] is the number of rows (the number of DoFs), matrixSize[1] is the number of columns. See further down how to extract the Jacobian.1: to retrieve the manipulability value, i.e. sqrt(det(J*JT)), where J is the Jacobian, and JT the Jacobian transpose. The returned pointer points onto a single value.matrixSize: the dimensions of the returned matrix (x=rows, y=columns)USAGE EXAMPLE (to correctly interpret the Jacobian):float jacobianSize[2];float* jacobian=simGetIkGroupMatrix(ikGroupHandle,0,jacobianSize);// jacobianSize[0] represents the row count of the Jacobian // (i.e. the number of equations or the number of joints involved// in the IK resolution of the given kinematic chain)// Joints appear from tip to base.// jacobianSize[1] represents the column count of the Jacobian // (i.e. the number of constraints, e.g. x,y,z,alpha,beta,gamma,jointDependency)// The Jacobian data is ordered row-wise, i.e.:// [row0,col0],[row1,col0],..,[rowN,col0],[row0,col1],[row1,col1],etc.for (int i=0;i<jacobianSize[0];i++){    std::string str;    for (int j=0;j<jacobianSize[1];j++)    {        if (str.size()==0)            str+=, ;        str+=boost::str(boost::format(%.1e) % jacobian[j*jacobianSize[0]+i]);    }    printf(str.c_str());} A pointer to x*y float values. The values should be copied since the pointer might not remain valid."
    }, 
    "simUI.curve_scatter_shape.cross": {
        "body": "simUI.curve_scatter_shape.cross", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_scatter_shape.cross", 
        "description": "Constants"
    }, 
    "sim.modelproperty_not_cuttable": {
        "body": "sim.modelproperty_not_cuttable", 
        "scope": "source.lua", 
        "prefix": "sim.modelproperty_not_cuttable", 
        "description": "Constants"
    }, 
    "sim.appobj_ui_type": {
        "body": "sim.appobj_ui_type", 
        "scope": "source.lua", 
        "prefix": "sim.appobj_ui_type", 
        "description": "Constants"
    }, 
    "simRRS1.SET_MOTION_FILTER": {
        "body": "simRRS1.SET_MOTION_FILTER(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_MOTION_FILTER", 
        "description": "int status= simRRS1.SET_MOTION_FILTER(bitstring2 rcsHandle)"
    }, 
    "sim.getShapeMesh": {
        "body": "sim.getShapeMesh(${0:shapeHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getShapeMesh", 
        "description": "table vertices,table indices,table normals = sim.getShapeMesh(number shapeHandle)Retrieves a shape's mesh information. See also sim.getShapeViz, sim.createMeshShape and sim.exportMesh for a usage example. shapeHandle: handle of the shapevertices: receives the vertices. The user is in charge of destroying the array with simReleaseBuffer. See simExportMesh for a usage example.verticesSize: receives the size of the vertices array. See simExportMesh for a usage example.indices: receives the indices. The user is in charge of destroying the array with simReleaseBuffer. See simExportMesh for a usage example.indicesSize: receives the size of the indice array. See simExportMesh for a usage example.normals: receives the normals (3 times the size of indicesSize). The user is in charge of destroying the array with simReleaseBuffer. Can be NULL.shapeHandle: handle of the shapevertices: receives the vertices. The user is in charge of destroying the array with simReleaseBuffer. See simExportMesh for a usage example.verticesSize: receives the size of the vertices array. See simExportMesh for a usage example.indices: receives the indices. The user is in charge of destroying the array with simReleaseBuffer. See simExportMesh for a usage example.indicesSize: receives the size of the indice array. See simExportMesh for a usage example.normals: receives the normals (3 times the size of indicesSize). The user is in charge of destroying the array with simReleaseBuffer. Can be NULL.shapeHandle: handle of the shapevertices: receives the vertices. The user is in charge of destroying the array with simReleaseBuffer. See simExportMesh for a usage example.verticesSize: receives the size of the vertices array. See simExportMesh for a usage example.indices: receives the indices. The user is in charge of destroying the array with simReleaseBuffer. See simExportMesh for a usage example.indicesSize: receives the size of the indice array. See simExportMesh for a usage example.normals: receives the normals (3 times the size of indicesSize). The user is in charge of destroying the array with simReleaseBuffer. Can be NULL.shapeHandle: handle of the shapevertices: receives the vertices. The user is in charge of destroying the array with simReleaseBuffer. See simExportMesh for a usage example.verticesSize: receives the size of the vertices array. See simExportMesh for a usage example.indices: receives the indices. The user is in charge of destroying the array with simReleaseBuffer. See simExportMesh for a usage example.indicesSize: receives the size of the indice array. See simExportMesh for a usage example.normals: receives the normals (3 times the size of indicesSize). The user is in charge of destroying the array with simReleaseBuffer. Can be NULL.shapeHandle: handle of the shapevertices: receives the vertices. The user is in charge of destroying the array with simReleaseBuffer. See simExportMesh for a usage example.verticesSize: receives the size of the vertices array. See simExportMesh for a usage example.indices: receives the indices. The user is in charge of destroying the array with simReleaseBuffer. See simExportMesh for a usage example.indicesSize: receives the size of the indice array. See simExportMesh for a usage example.normals: receives the normals (3 times the size of indicesSize). The user is in charge of destroying the array with simReleaseBuffer. Can be NULL.shapeHandle: handle of the shapevertices: receives the vertices. The user is in charge of destroying the array with simReleaseBuffer. See simExportMesh for a usage example.verticesSize: receives the size of the vertices array. See simExportMesh for a usage example.indices: receives the indices. The user is in charge of destroying the array with simReleaseBuffer. See simExportMesh for a usage example.indicesSize: receives the size of the indice array. See simExportMesh for a usage example.normals: receives the normals (3 times the size of indicesSize). The user is in charge of destroying the array with simReleaseBuffer. Can be NULL.shapeHandle: handle of the shapevertices: receives the vertices. The user is in charge of destroying the array with simReleaseBuffer. See simExportMesh for a usage example.verticesSize: receives the size of the vertices array. See simExportMesh for a usage example.indices: receives the indices. The user is in charge of destroying the array with simReleaseBuffer. See simExportMesh for a usage example.indicesSize: receives the size of the indice array. See simExportMesh for a usage example.normals: receives the normals (3 times the size of indicesSize). The user is in charge of destroying the array with simReleaseBuffer. Can be NULL. -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sysCall_suspended": {
        "body": "sysCall_suspended(${0:suspended.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_suspended", 
        "description": "sysCall_suspended(Called when simulation is suspended.)"
    }, 
    "simx.cmdheaderoffset_status": {
        "body": "simx.cmdheaderoffset_status", 
        "scope": "source.lua", 
        "prefix": "simx.cmdheaderoffset_status", 
        "description": "Constants"
    }, 
    "sim.buffer_int16": {
        "body": "sim.buffer_int16", 
        "scope": "source.lua", 
        "prefix": "sim.buffer_int16", 
        "description": "Constants"
    }, 
    "sim.stringparam_scene_name": {
        "body": "sim.stringparam_scene_name", 
        "scope": "source.lua", 
        "prefix": "sim.stringparam_scene_name", 
        "description": "Constants"
    }, 
    "sim.volume_randomizedray": {
        "body": "sim.volume_randomizedray", 
        "scope": "source.lua", 
        "prefix": "sim.volume_randomizedray", 
        "description": "Constants"
    }, 
    "sim.scripttype_contactcallback": {
        "body": "sim.scripttype_contactcallback", 
        "scope": "source.lua", 
        "prefix": "sim.scripttype_contactcallback", 
        "description": "Constants"
    }, 
    "sim.cameraintparam_pov_blur_samples": {
        "body": "sim.cameraintparam_pov_blur_samples", 
        "scope": "source.lua", 
        "prefix": "sim.cameraintparam_pov_blur_samples", 
        "description": "Constants"
    }, 
    "sim.addonscriptcall_initialization": {
        "body": "sim.addonscriptcall_initialization", 
        "scope": "source.lua", 
        "prefix": "sim.addonscriptcall_initialization", 
        "description": "Constants"
    }, 
    "bit32.rrotate": {
        "body": "bit32.rrotate(${0:...})", 
        "scope": "source.lua", 
        "prefix": "bit32.rrotate", 
        "description": "5.2\n\nbit32.rrotate (x, disp)"
    }, 
    "simRRS1.SET_CARTESIAN_POSITION_ACCELERATION": {
        "body": "simRRS1.SET_CARTESIAN_POSITION_ACCELERATION(${0:rcsHandle},${1:accelValue})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_CARTESIAN_POSITION_ACCELERATION", 
        "description": "int status= simRRS1.SET_CARTESIAN_POSITION_ACCELERATION(bitstring2 rcsHandle,real accelValue)"
    }, 
    "simUI.create": {
        "body": "simUI.create(${0:xml})", 
        "scope": "source.lua", 
        "prefix": "simUI.create", 
        "description": "number uiHandle = simUI.create(string xml)"
    }, 
    "sim.mainscriptcall_cleanup": {
        "body": "sim.mainscriptcall_cleanup", 
        "scope": "source.lua", 
        "prefix": "sim.mainscriptcall_cleanup", 
        "description": "Constants"
    }, 
    "simSkeleton.getData": {
        "body": "simSkeleton.getData(${0:data1})", 
        "scope": "source.lua", 
        "prefix": "simSkeleton.getData", 
        "description": "...= simSkeleton.getData(string data1)"
    }, 
    "math.cosh": {
        "body": "math.cosh(${0:...})", 
        "scope": "source.lua", 
        "prefix": "math.cosh", 
        "description": "5.1,5.2\n\nmath.cosh (x)"
    }, 
    "simUI.destroy": {
        "body": "simUI.destroy(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "simUI.destroy", 
        "description": "simUI.destroy(number handle)"
    }, 
    "math.tointeger": {
        "body": "math.tointeger( ${1:x} )", 
        "scope": "source.lua", 
        "prefix": "math.tointeger", 
        "description": "5.3\n\nmath.tointeger"
    }, 
    "sim.getObjectVelocity": {
        "body": "sim.getObjectVelocity(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectVelocity", 
        "description": "table_3 linearVelocity,table_3 angularVelocity = sim.getObjectVelocity(number objectHandle)Retrieves the linear and/or angular velocity of an object, in absolute coordinates. The velocity is a measured velocity (i.e. from one simulation step to the next), and is available for all objects in the scene. See also sim.getVelocity. objectHandle: handle of a scene object.linearVelocity: pointer to 3 values that will receive the linear velocity. Can be NULLangularVelocity: pointer to 3 values that will receive the angular velocity. Can be NULLobjectHandle: handle of a scene object.linearVelocity: pointer to 3 values that will receive the linear velocity. Can be NULLangularVelocity: pointer to 3 values that will receive the angular velocity. Can be NULLobjectHandle: handle of a scene object.linearVelocity: pointer to 3 values that will receive the linear velocity. Can be NULLangularVelocity: pointer to 3 values that will receive the angular velocity. Can be NULLobjectHandle: handle of a scene object.linearVelocity: pointer to 3 values that will receive the linear velocity. Can be NULLangularVelocity: pointer to 3 values that will receive the angular velocity. Can be NULL -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.setObjectStringParameter": {
        "body": "sim.setObjectStringParameter(${0:objectHandle},${1:parameterID},${2:parameter})", 
        "scope": "source.lua", 
        "prefix": "sim.setObjectStringParameter", 
        "description": "number result = sim.setObjectStringParameter(number objectHandle,number parameterID,string parameter)Sets a string parameter of a scene object or calculation object. See also sim.getObjectStringParameter, sim.setObjectInt32Parameter and sim.setObjectFloatParameter objectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: parameter value (can contain embedded zeros)parameterLength: the length of the parameter valueobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: parameter value (can contain embedded zeros)parameterLength: the length of the parameter valueobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: parameter value (can contain embedded zeros)parameterLength: the length of the parameter valueobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: parameter value (can contain embedded zeros)parameterLength: the length of the parameter valueobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: parameter value (can contain embedded zeros)parameterLength: the length of the parameter value -1 in case of an error, 0 if the parameter could not be set (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful"
    }, 
    "sim.buttonproperty_ignoremouse": {
        "body": "sim.buttonproperty_ignoremouse", 
        "scope": "source.lua", 
        "prefix": "sim.buttonproperty_ignoremouse", 
        "description": "Constants"
    }, 
    "sim.filedlg_type_load": {
        "body": "sim.filedlg_type_load", 
        "scope": "source.lua", 
        "prefix": "sim.filedlg_type_load", 
        "description": "Constants"
    }, 
    "sim.simulation_advancing_firstafterpause": {
        "body": "sim.simulation_advancing_firstafterpause", 
        "scope": "source.lua", 
        "prefix": "sim.simulation_advancing_firstafterpause", 
        "description": "Constants"
    }, 
    "simUI.addCurve": {
        "body": "simUI.addCurve(${0:handle},${1:id},${2:type},${3:name},${4:color},${5:style},${6:options})", 
        "scope": "source.lua", 
        "prefix": "simUI.addCurve", 
        "description": "simUI.addCurve(number handle,number id,number type,string name,table color,number style,curve_options options)"
    }, 
    "sim.setLightParameters": {
        "body": "sim.setLightParameters(${0:lightHandle},${1:state},${2:nil},${3:diffusePart},${4:specularPart})", 
        "scope": "source.lua", 
        "prefix": "sim.setLightParameters", 
        "description": "number result = sim.setLightParameters(number lightHandle,number state,nil,table_3 diffusePart,table_3 specularPart)Sets various parameters of a light object. See also sim.getLightParameters. objectHandle: handle of the lightstate: bit-coded. for now, only bit 0 is used: 1=light onsetToNULL: not used, set to NULLdiffusePart: red, green and blue component of the light's diffuse part. Can be NULLspecularPart: red, green and blue component of the light's specular part. Can be NULLobjectHandle: handle of the lightstate: bit-coded. for now, only bit 0 is used: 1=light onsetToNULL: not used, set to NULLdiffusePart: red, green and blue component of the light's diffuse part. Can be NULLspecularPart: red, green and blue component of the light's specular part. Can be NULLobjectHandle: handle of the lightstate: bit-coded. for now, only bit 0 is used: 1=light onsetToNULL: not used, set to NULLdiffusePart: red, green and blue component of the light's diffuse part. Can be NULLspecularPart: red, green and blue component of the light's specular part. Can be NULLobjectHandle: handle of the lightstate: bit-coded. for now, only bit 0 is used: 1=light onsetToNULL: not used, set to NULLdiffusePart: red, green and blue component of the light's diffuse part. Can be NULLspecularPart: red, green and blue component of the light's specular part. Can be NULLobjectHandle: handle of the lightstate: bit-coded. for now, only bit 0 is used: 1=light onsetToNULL: not used, set to NULLdiffusePart: red, green and blue component of the light's diffuse part. Can be NULLspecularPart: red, green and blue component of the light's specular part. Can be NULLobjectHandle: handle of the lightstate: bit-coded. for now, only bit 0 is used: 1=light onsetToNULL: not used, set to NULLdiffusePart: red, green and blue component of the light's diffuse part. Can be NULLspecularPart: red, green and blue component of the light's specular part. Can be NULL -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.msgBox": {
        "body": "sim.msgBox(${0:dlgType},${1:buttons},${2:title},${3:message})", 
        "scope": "source.lua", 
        "prefix": "sim.msgBox", 
        "description": "number returnValue = sim.msgBox(number dlgType,number buttons,string title,string message)Opens a modal message box for interaction with the user.  See also sim.fileDialog and sim.displayDialog dlgType: the message box type.buttons: the buttons to display.title: title of the dialogmessage: the message to displaydlgType: the message box type.buttons: the buttons to display.title: title of the dialogmessage: the message to displaydlgType: the message box type.buttons: the buttons to display.title: title of the dialogmessage: the message to displaydlgType: the message box type.buttons: the buttons to display.title: title of the dialogmessage: the message to display a message box return value"
    }, 
    "sim.packInt32Table": {
        "body": "sim.packInt32Table(${0:int32Numbers},${1:startInt32Index=0},${2:int32Count=0})", 
        "scope": "source.lua", 
        "prefix": "sim.packInt32Table", 
        "description": "string data = sim.packInt32Table(table int32Numbers,number startInt32Index=0,number int32Count=0)Packs a table of int32 numbers into a string. See also sim.unpackInt32Table and the other packing/unpacking functions. - -"
    }, 
    "sim.vortex_joint_a1damping": {
        "body": "sim.vortex_joint_a1damping", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a1damping", 
        "description": "Constants"
    }, 
    "table.sort": {
        "body": "table.sort( ${1:tablename}${2:, sortfunction} )", 
        "scope": "source.lua", 
        "prefix": "table.sort", 
        "description": "5.1,5.2,5.3\n\ntable.sort"
    }, 
    "sim.drawing_50percenttransparency": {
        "body": "sim.drawing_50percenttransparency", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_50percenttransparency", 
        "description": "Constants"
    }, 
    "simOMPL.Algorithm.BiTRRT": {
        "body": "simOMPL.Algorithm.BiTRRT", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.BiTRRT", 
        "description": "Constants"
    }, 
    "sim.executeScriptString": {
        "body": "sim.executeScriptString(${0:stringAtScriptName},${1:scriptHandleOrType})", 
        "scope": "source.lua", 
        "prefix": "sim.executeScriptString", 
        "description": "number result,executionResult = sim.executeScriptString(string stringAtScriptName,number scriptHandleOrType)Executes some Lua code in a specific script (from a plugin, the main client application, or from another script). Call this only:a) from the main thread, or:b) from a thread that originated from a threaded child script. In that case, you cannot call non-threaded child scripts.When calling simulation scripts, then simulation must be running. See also sim.callScriptFunction. Data exchange between a plugin and a script happens via a stack. Reading and writing arguments from/to the stack gives you a maximum of flexibility, and you wil be able to exchange also complex data structures. But it can also be tedious and error prone. Use instead the helper classes located in programming/common/stack and programming/include/stack: they will greatly simplify the task. Have a look at the example plugins v_repExtSkeletonPlugin and v_repExtSkeletonPluginNG. scriptHandleOrType: the handle of the script, otherwise the type of the script:sim_scripttype_mainscript (0): the main script.sim_scripttype_childscript (1): a child script. In that case, stringAtScriptName should also contain the name of the object associated with the script.sim_scripttype_customizationscript (6): a customization script. In that case, stringAtScriptName should also contain the name of the object associated with the script.sim_scripttype_sandboxscript (8): the sandbox script.stringAtScriptName: some Lua code to execute in the specified script. If scriptHandleOrType is sim_scripttype_childscript, or sim_scripttype_customizationscript, then stringAtScriptName should also contain the name of the object associated with the script: string@objectName.stackId: 0 (for no stack) or a stack handle. The stack holds possible out values. See also the available stack functions.scriptHandleOrType: the handle of the script, otherwise the type of the script:sim_scripttype_mainscript (0): the main script.sim_scripttype_childscript (1): a child script. In that case, stringAtScriptName should also contain the name of the object associated with the script.sim_scripttype_customizationscript (6): a customization script. In that case, stringAtScriptName should also contain the name of the object associated with the script.sim_scripttype_sandboxscript (8): the sandbox script.stringAtScriptName: some Lua code to execute in the specified script. If scriptHandleOrType is sim_scripttype_childscript, or sim_scripttype_customizationscript, then stringAtScriptName should also contain the name of the object associated with the script: string@objectName.stackId: 0 (for no stack) or a stack handle. The stack holds possible out values. See also the available stack functions.scriptHandleOrType: the handle of the script, otherwise the type of the script:sim_scripttype_mainscript (0): the main script.sim_scripttype_childscript (1): a child script. In that case, stringAtScriptName should also contain the name of the object associated with the script.sim_scripttype_customizationscript (6): a customization script. In that case, stringAtScriptName should also contain the name of the object associated with the script.sim_scripttype_sandboxscript (8): the sandbox script.stringAtScriptName: some Lua code to execute in the specified script. If scriptHandleOrType is sim_scripttype_childscript, or sim_scripttype_customizationscript, then stringAtScriptName should also contain the name of the object associated with the script: string@objectName.stackId: 0 (for no stack) or a stack handle. The stack holds possible out values. See also the available stack functions.scriptHandleOrType: the handle of the script, otherwise the type of the script:sim_scripttype_mainscript (0): the main script.sim_scripttype_childscript (1): a child script. In that case, stringAtScriptName should also contain the name of the object associated with the script.sim_scripttype_customizationscript (6): a customization script. In that case, stringAtScriptName should also contain the name of the object associated with the script.sim_scripttype_sandboxscript (8): the sandbox script.stringAtScriptName: some Lua code to execute in the specified script. If scriptHandleOrType is sim_scripttype_childscript, or sim_scripttype_customizationscript, then stringAtScriptName should also contain the name of the object associated with the script: string@objectName.stackId: 0 (for no stack) or a stack handle. The stack holds possible out values. See also the available stack functions.scriptHandleOrType: the handle of the script, otherwise the type of the script:sim_scripttype_mainscript (0): the main script.sim_scripttype_childscript (1): a child script. In that case, stringAtScriptName should also contain the name of the object associated with the script.sim_scripttype_customizationscript (6): a customization script. In that case, stringAtScriptName should also contain the name of the object associated with the script.sim_scripttype_sandboxscript (8): the sandbox script.stringAtScriptName: some Lua code to execute in the specified script. If scriptHandleOrType is sim_scripttype_childscript, or sim_scripttype_customizationscript, then stringAtScriptName should also contain the name of the object associated with the script: string@objectName.stackId: 0 (for no stack) or a stack handle. The stack holds possible out values. See also the available stack functions.scriptHandleOrType: the handle of the script, otherwise the type of the script:sim_scripttype_mainscript (0): the main script.sim_scripttype_childscript (1): a child script. In that case, stringAtScriptName should also contain the name of the object associated with the script.sim_scripttype_customizationscript (6): a customization script. In that case, stringAtScriptName should also contain the name of the object associated with the script.sim_scripttype_sandboxscript (8): the sandbox script.stringAtScriptName: some Lua code to execute in the specified script. If scriptHandleOrType is sim_scripttype_childscript, or sim_scripttype_customizationscript, then stringAtScriptName should also contain the name of the object associated with the script: string@objectName.stackId: 0 (for no stack) or a stack handle. The stack holds possible out values. See also the available stack functions.scriptHandleOrType: the handle of the script, otherwise the type of the script:sim_scripttype_mainscript (0): the main script.sim_scripttype_childscript (1): a child script. In that case, stringAtScriptName should also contain the name of the object associated with the script.sim_scripttype_customizationscript (6): a customization script. In that case, stringAtScriptName should also contain the name of the object associated with the script.sim_scripttype_sandboxscript (8): the sandbox script.stringAtScriptName: some Lua code to execute in the specified script. If scriptHandleOrType is sim_scripttype_childscript, or sim_scripttype_customizationscript, then stringAtScriptName should also contain the name of the object associated with the script: string@objectName.stackId: 0 (for no stack) or a stack handle. The stack holds possible out values. See also the available stack functions. -1 in case of an error"
    }, 
    "bit32.bnot": {
        "body": "bit32.bnot(${0:...})", 
        "scope": "source.lua", 
        "prefix": "bit32.bnot", 
        "description": "5.2\n\nbit32.bnot (x)"
    }, 
    "bit32.lshift": {
        "body": "bit32.lshift(${0:...})", 
        "scope": "source.lua", 
        "prefix": "bit32.lshift", 
        "description": "5.2\n\nbit32.lshift (x, disp)"
    }, 
    "simUI.removeTreeItem": {
        "body": "simUI.removeTreeItem(${0:handle},${1:id},${2:item_id},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.removeTreeItem", 
        "description": "simUI.removeTreeItem(number handle,number id,number item_id,bool suppressEvents=true)"
    }, 
    "sim.clearFloatSignal": {
        "body": "sim.clearFloatSignal(${0:signalName})", 
        "scope": "source.lua", 
        "prefix": "sim.clearFloatSignal", 
        "description": "number clearCount = sim.clearFloatSignal(string signalName)Clears a float signal (removes it). See also the other signal functions. signalName: name of the signal or NULL to clear all float signalssignalName: name of the signal or NULL to clear all float signals -1 if operation was not successful, otherwise the number of signals cleared"
    }, 
    "sim.clearIntegerSignal": {
        "body": "sim.clearIntegerSignal(${0:signalName})", 
        "scope": "source.lua", 
        "prefix": "sim.clearIntegerSignal", 
        "description": "number clearCount = sim.clearIntegerSignal(string signalName)Clears an integer signal (removes it). See also the other signal functions. signalName: name of the signal or NULL to clear all integer signalssignalName: name of the signal or NULL to clear all integer signals -1 if operation was not successful, otherwise the number of signals cleared"
    }, 
    "sim.appobj_object_type": {
        "body": "sim.appobj_object_type", 
        "scope": "source.lua", 
        "prefix": "sim.appobj_object_type", 
        "description": "Constants"
    }, 
    "simROS.getParamBool": {
        "body": "simROS.getParamBool(${0:name},${1:defaultValue=false})", 
        "scope": "source.lua", 
        "prefix": "simROS.getParamBool", 
        "description": "bool exists,bool value = simROS.getParamBool(string name,bool defaultValue=false)"
    }, 
    "sim.displayattribute_selected": {
        "body": "sim.displayattribute_selected", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_selected", 
        "description": "Constants"
    }, 
    "sim.drawing_followparentvisibility": {
        "body": "sim.drawing_followparentvisibility", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_followparentvisibility", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_5x5filter": {
        "body": "sim.filtercomponent_5x5filter", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_5x5filter", 
        "description": "Constants"
    }, 
    "simRRS1.SELECT_TRACKING": {
        "body": "simRRS1.SELECT_TRACKING(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SELECT_TRACKING", 
        "description": "int status= simRRS1.SELECT_TRACKING(bitstring2 rcsHandle)"
    }, 
    "simOMPL.destroyStateSpace": {
        "body": "simOMPL.destroyStateSpace(${0:stateSpaceHandle})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.destroyStateSpace", 
        "description": "number result = simOMPL.destroyStateSpace(number stateSpaceHandle)"
    }, 
    "simUI.getRowCount": {
        "body": "simUI.getRowCount(${0:handle},${1:id})", 
        "scope": "source.lua", 
        "prefix": "simUI.getRowCount", 
        "description": "number count = simUI.getRowCount(number handle,number id)"
    }, 
    "sim.customizationscriptcall_firstaftersimulation": {
        "body": "sim.customizationscriptcall_firstaftersimulation", 
        "scope": "source.lua", 
        "prefix": "sim.customizationscriptcall_firstaftersimulation", 
        "description": "Constants"
    }, 
    "_VERSION": {
        "body": "_VERSION(${0:...})", 
        "scope": "source.lua", 
        "prefix": "_VERSION", 
        "description": "5.1,5.2,5.3\n\n_VERSION"
    }, 
    "sim.buttonproperty_isdown": {
        "body": "sim.buttonproperty_isdown", 
        "scope": "source.lua", 
        "prefix": "sim.buttonproperty_isdown", 
        "description": "Constants"
    }, 
    "sim.boolparam_force_show_wireless_emission": {
        "body": "sim.boolparam_force_show_wireless_emission", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_force_show_wireless_emission", 
        "description": "Constants"
    }, 
    "sim.getObjectConfiguration": {
        "body": "sim.getObjectConfiguration(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectConfiguration", 
        "description": "number rawBufferHandle = sim.getObjectConfiguration(number objectHandle)Retrieves configuration information for an object (object relative position/orientation, joint/path value). See also sim.setObjectConfiguration and sim.getConfigurationTree. objectHandle: handle of the objectobjectHandle: handle of the object Pointer to configuration data if operation was successful, NULL otherwise. The returned data should be deleted with simReleaseBuffer when not used anymore"
    }, 
    "sim.setJointForce": {
        "body": "sim.setJointForce(${0:objectHandle},${1:forceOrTorque})", 
        "scope": "source.lua", 
        "prefix": "sim.setJointForce", 
        "description": "number result = sim.setJointForce(number objectHandle,number forceOrTorque)Sets the maximum force or torque that a joint can exert. This function has no effect when the joint is not dynamically enabled, or when it is a spherical joint. See also sim.getJointForce. objectHandle: handle of the joint objectforceOrTorque: the maximum force or torque that the joint can exertobjectHandle: handle of the joint objectforceOrTorque: the maximum force or torque that the joint can exertobjectHandle: handle of the joint objectforceOrTorque: the maximum force or torque that the joint can exert -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "collectgarbage": {
        "body": "collectgarbage(${1:[opt]}${2:[, arg]})", 
        "scope": "source.lua", 
        "prefix": "collectgarbage", 
        "description": "5.1,5.2,5.3\n\ncollectgarbage()"
    }, 
    "sim.scripttype_jointctrlcallback": {
        "body": "sim.scripttype_jointctrlcallback", 
        "scope": "source.lua", 
        "prefix": "sim.scripttype_jointctrlcallback", 
        "description": "Constants"
    }, 
    "simOMPL.destroyTask": {
        "body": "simOMPL.destroyTask(${0:taskHandle})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.destroyTask", 
        "description": "number result = simOMPL.destroyTask(number taskHandle)"
    }, 
    "sim.newton_global_constraintsolvingiterations": {
        "body": "sim.newton_global_constraintsolvingiterations", 
        "scope": "source.lua", 
        "prefix": "sim.newton_global_constraintsolvingiterations", 
        "description": "Constants"
    }, 
    "simVision.createVelodyneVPL16": {
        "body": "simVision.createVelodyneVPL16(${0:visionSensorHandles},${1:frequency},${2:options=0},${3:pointSize=2},${4:coloring_closeFarDist={1},${5:5}})", 
        "scope": "source.lua", 
        "prefix": "simVision.createVelodyneVPL16", 
        "description": "number velodyneHandle= simVision.createVelodyneVPL16(table_4 visionSensorHandles,number frequency,number options=0,number pointSize=2,table_2 coloring_closeFarDist={1,5})"
    }, 
    "simOMPL.Algorithm.TRRT": {
        "body": "simOMPL.Algorithm.TRRT", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.TRRT", 
        "description": "Constants"
    }, 
    "sim.volume_cone": {
        "body": "sim.volume_cone", 
        "scope": "source.lua", 
        "prefix": "sim.volume_cone", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_lowerlimitstiffness": {
        "body": "sim.vortex_joint_lowerlimitstiffness", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_lowerlimitstiffness", 
        "description": "Constants"
    }, 
    "sim.dynmat_floor": {
        "body": "sim.dynmat_floor", 
        "scope": "source.lua", 
        "prefix": "sim.dynmat_floor", 
        "description": "Constants"
    }, 
    "sim.message_bannerclicked": {
        "body": "sim.message_bannerclicked", 
        "scope": "source.lua", 
        "prefix": "sim.message_bannerclicked", 
        "description": "Constants"
    }, 
    "sim.object_mill_type": {
        "body": "sim.object_mill_type", 
        "scope": "source.lua", 
        "prefix": "sim.object_mill_type", 
        "description": "Constants"
    }, 
    "simROS.advertise": {
        "body": "simROS.advertise(${0:topicName},${1:topicType},${2:queueSize=1},${3:latch=false})", 
        "scope": "source.lua", 
        "prefix": "simROS.advertise", 
        "description": "number publisherHandle = simROS.advertise(string topicName,string topicType,number queueSize=1,bool latch=false)"
    }, 
    "math.fmod": {
        "body": "math.fmod( ${1:x},${2:y} )", 
        "scope": "source.lua", 
        "prefix": "math.fmod", 
        "description": "5.1,5.2,5.3\n\nmath.fmod"
    }, 
    "sim.vortex_joint_a0damping": {
        "body": "sim.vortex_joint_a0damping", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a0damping", 
        "description": "Constants"
    }, 
    "sim.ik_x_constraint": {
        "body": "sim.ik_x_constraint", 
        "scope": "source.lua", 
        "prefix": "sim.ik_x_constraint", 
        "description": "Constants"
    }, 
    "sim.banner_backfaceculling": {
        "body": "sim.banner_backfaceculling", 
        "scope": "source.lua", 
        "prefix": "sim.banner_backfaceculling", 
        "description": "Constants"
    }, 
    "simUI.getNodeInletCount": {
        "body": "simUI.getNodeInletCount(${0:handle},${1:id},${2:nodeId})", 
        "scope": "source.lua", 
        "prefix": "simUI.getNodeInletCount", 
        "description": "number count = simUI.getNodeInletCount(number handle,number id,number nodeId)"
    }, 
    "simOMPL.StateSpaceType.position2d": {
        "body": "simOMPL.StateSpaceType.position2d", 
        "scope": "source.lua", 
        "prefix": "simOMPL.StateSpaceType.position2d", 
        "description": "Constants"
    }, 
    "sim.getObjectUniqueIdentifier": {
        "body": "sim.getObjectUniqueIdentifier(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectUniqueIdentifier", 
        "description": "number uniqueIdentifier = sim.getObjectUniqueIdentifier(number objectHandle)Retrieves an object's unique identifier (an object handle is unique, but not across opened scenes. Additionally, if a huge amount of objects are created/destroyed (>2000000), then handles of destroyed objects will be reused. This is not the case with unique identifiers). objectHandle: object handle, or sim_handle_all to retrieve all object identifiersuniqueIdentifier: pointer to the unique identifier, or if sim_handle_all is specified as the object handle, then the pointer points to several values. The user is in charge of reserving the buffer (size 1 if handle is specified, or number of objects in the scene if sim_handle_all is specified)objectHandle: object handle, or sim_handle_all to retrieve all object identifiersuniqueIdentifier: pointer to the unique identifier, or if sim_handle_all is specified as the object handle, then the pointer points to several values. The user is in charge of reserving the buffer (size 1 if handle is specified, or number of objects in the scene if sim_handle_all is specified)objectHandle: object handle, or sim_handle_all to retrieve all object identifiersuniqueIdentifier: pointer to the unique identifier, or if sim_handle_all is specified as the object handle, then the pointer points to several values. The user is in charge of reserving the buffer (size 1 if handle is specified, or number of objects in the scene if sim_handle_all is specified) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simRRS1.SET_WEAVING_GROUP_PARAMETER": {
        "body": "simRRS1.SET_WEAVING_GROUP_PARAMETER(${0:rcsHandle},${1:groupNo},${2:paramNo})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_WEAVING_GROUP_PARAMETER", 
        "description": "int status= simRRS1.SET_WEAVING_GROUP_PARAMETER(bitstring2 rcsHandle,int groupNo,int paramNo)"
    }, 
    "sim.dlgret_cancel": {
        "body": "sim.dlgret_cancel", 
        "scope": "source.lua", 
        "prefix": "sim.dlgret_cancel", 
        "description": "Constants"
    }, 
    "sim.drawing_cubepoints": {
        "body": "sim.drawing_cubepoints", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_cubepoints", 
        "description": "Constants"
    }, 
    "sim.proximitysensor_disc_subtype": {
        "body": "sim.proximitysensor_disc_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.proximitysensor_disc_subtype", 
        "description": "Constants"
    }, 
    "simVision.createVelodyneHDL64E": {
        "body": "simVision.createVelodyneHDL64E(${0:visionSensorHandles},${1:frequency},${2:options=0},${3:pointSize=2},${4:coloring_closeFarDist={1},${5:5}})", 
        "scope": "source.lua", 
        "prefix": "simVision.createVelodyneHDL64E", 
        "description": "number velodyneHandle= simVision.createVelodyneHDL64E(table_4 visionSensorHandles,number frequency,number options=0,number pointSize=2,table_2 coloring_closeFarDist={1,5})"
    }, 
    "sim.dynmat_lowfriction": {
        "body": "sim.dynmat_lowfriction", 
        "scope": "source.lua", 
        "prefix": "sim.dynmat_lowfriction", 
        "description": "Constants"
    }, 
    "simUI.setPlotXLabel": {
        "body": "simUI.setPlotXLabel(${0:handle},${1:id},${2:label})", 
        "scope": "source.lua", 
        "prefix": "simUI.setPlotXLabel", 
        "description": "simUI.setPlotXLabel(number handle,number id,string label)"
    }, 
    "simROS.serviceClient": {
        "body": "simROS.serviceClient(${0:serviceName},${1:serviceType})", 
        "scope": "source.lua", 
        "prefix": "simROS.serviceClient", 
        "description": "number serviceClientHandle = simROS.serviceClient(string serviceName,string serviceType)"
    }, 
    "sim.ikresult_not_performed": {
        "body": "sim.ikresult_not_performed", 
        "scope": "source.lua", 
        "prefix": "sim.ikresult_not_performed", 
        "description": "Constants"
    }, 
    "sim.shapeintparam_edge_visibility": {
        "body": "sim.shapeintparam_edge_visibility", 
        "scope": "source.lua", 
        "prefix": "sim.shapeintparam_edge_visibility", 
        "description": "Constants"
    }, 
    "sim.mainscriptcall_regular": {
        "body": "sim.mainscriptcall_regular", 
        "scope": "source.lua", 
        "prefix": "sim.mainscriptcall_regular", 
        "description": "Constants"
    }, 
    "io.type": {
        "body": "io.type(${0:...})", 
        "scope": "source.lua", 
        "prefix": "io.type", 
        "description": "5.1,5.2,5.3\n\nio.type (obj)"
    }, 
    "os.exit": {
        "body": "os.exit(${0:...})", 
        "scope": "source.lua", 
        "prefix": "os.exit", 
        "description": "5.1,5.2,5.3\n\nos.exit ([code])"
    }, 
    "sim.particle_itemcolors": {
        "body": "sim.particle_itemcolors", 
        "scope": "source.lua", 
        "prefix": "sim.particle_itemcolors", 
        "description": "Constants"
    }, 
    "simRRS1.GET_ROBOT_STAMP": {
        "body": "simRRS1.GET_ROBOT_STAMP()", 
        "scope": "source.lua", 
        "prefix": "simRRS1.GET_ROBOT_STAMP", 
        "description": "int status,string manipulator,string controller,string software= simRRS1.GET_ROBOT_STAMP()"
    }, 
    "sim.ode_body_softcfm": {
        "body": "sim.ode_body_softcfm", 
        "scope": "source.lua", 
        "prefix": "sim.ode_body_softcfm", 
        "description": "Constants"
    }, 
    "sim.vortex_body_normalangularaxisslide": {
        "body": "sim.vortex_body_normalangularaxisslide", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_normalangularaxisslide", 
        "description": "Constants"
    }, 
    "sim.dlgstyle_message": {
        "body": "sim.dlgstyle_message", 
        "scope": "source.lua", 
        "prefix": "sim.dlgstyle_message", 
        "description": "Constants"
    }, 
    "sim.removeScript": {
        "body": "sim.removeScript(${0:scriptHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.removeScript", 
        "description": "number result = sim.removeScript(number scriptHandle)Removes a script. Not all script types can be removed, and it will also depend on whether simulation is running or not. See also sim.addScript. scriptHandle: handle of the script to remove or sim_handle_all to remove all scriptsscriptHandle: handle of the script to remove or sim_handle_all to remove all scripts -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.intparam_scene_unique_id": {
        "body": "sim.intparam_scene_unique_id", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_scene_unique_id", 
        "description": "Constants"
    }, 
    "sim.getShapeViz": {
        "body": "sim.getShapeViz(${0:shapeHandle},${1:itemIndex})", 
        "scope": "source.lua", 
        "prefix": "sim.getShapeViz", 
        "description": "map data = sim.getShapeViz(number shapeHandle,number itemIndex)Retrieves a shape's visual information. shapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colorsshapeHandle: handle of the shapeindex: 0-based index of the shape element to retrieve (compound shapes contain more than one shape element)info: visual information about the shape:vertices: array of vertices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.verticesSize: the size of the vertices arrayindices: array of indices. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.indicesSize: the size of the indices arraynormals: array of normals. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 0.shadingAngle: the gouraud shading anglecolors[9]: array of colors: RGB for ambient-diffuse,  specular, and  emission.texture: the RGBA texture (32bit/pixel). The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureId: a texture id (to identify textures shared among several shapes)textureRes[2]: the resolution of the texturetextureCoords: the texture coordinates. The user is in charge of releasing this buffer with simReleaseBuffer if the return value is > 1.textureApplyMode: 0=modulate, 1=decal, 2=addtextureOptions: bit-coded:bit0 set (1): repeat Ubit1 set (2): repeat Vbit2 set (4): interpolate colors -1 if operation was not successful, 0 if there is no shape element at the given indexm, 1 if the shape element does not contain any texture, 2 if the shape element contains a texture"
    }, 
    "sim.objfloatparam_transparency_offset": {
        "body": "sim.objfloatparam_transparency_offset", 
        "scope": "source.lua", 
        "prefix": "sim.objfloatparam_transparency_offset", 
        "description": "Constants"
    }, 
    "simx.setObjectParent": {
        "body": "simx.setObjectParent(${0:clientId},${1:objectHandle},${2:parentObject},${3:keepInPlace})", 
        "scope": "source.lua", 
        "prefix": "simx.setObjectParent", 
        "description": "number returnCode= simx.setObjectParent(number clientId,number objectHandle,number parentObject,boolean keepInPlace)Sets an object's parent object. See also simx.getObjectParent. clientID: the client ID. refer to simx.start.objectHandle: handle of the object that will become child of the parent object.  Can be combined with sim.handleflag_assembly, if the two objects can be assembled via a predefined assembly transformation (refer to the assembling option in the object common properties). In that case, parentObject can't be -1, and keepInPlace should be set to false.objectHandle: handle of the object that will become child of the parent object.  Can be combined with sim.handleflag_assembly, if the two objects can be assembled via a predefined assembly transformation (refer to the assembling option in the object common properties). In that case, parentObject can't be -1, and keepInPlace should be set to false.objectHandle: handle of the object that will become child of the parent object.  Can be combined with sim.handleflag_assembly, if the two objects can be assembled via a predefined assembly transformation (refer to the assembling option in the object common properties). In that case, parentObject can't be -1, and keepInPlace should be set to false.objectHandle: handle of the object that will become child of the parent object.  Can be combined with sim.handleflag_assembly, if the two objects can be assembled via a predefined assembly transformation (refer to the assembling option in the object common properties). In that case, parentObject can't be -1, and keepInPlace should be set to false.parentObject: handle of the object that will become parent, or -1 if the object should become parentlesskeepInPlace: indicates whether the object's absolute position and orientation should stay sameoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot or simx.opmode_blocking depending on the intent returnCode: a remote API function return code"
    }, 
    "simK3.setArmPosition": {
        "body": "simK3.setArmPosition(${0:k3Handle},${1:position})", 
        "scope": "source.lua", 
        "prefix": "simK3.setArmPosition", 
        "description": "boolean result = simK3.setArmPosition(number k3Handle,number position)"
    }, 
    "sim.vortex_body_restitution": {
        "body": "sim.vortex_body_restitution", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_restitution", 
        "description": "Constants"
    }, 
    "sim.objectspecialproperty_cuttable": {
        "body": "sim.objectspecialproperty_cuttable", 
        "scope": "source.lua", 
        "prefix": "sim.objectspecialproperty_cuttable", 
        "description": "Constants"
    }, 
    "sysCall_addOnScriptResume": {
        "body": "sysCall_addOnScriptResume(${0:resumes.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_addOnScriptResume", 
        "description": "sysCall_addOnScriptResume(Called just before the add-on script execution resumes.)"
    }, 
    "sim.displayattribute_colorcoded": {
        "body": "sim.displayattribute_colorcoded", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_colorcoded", 
        "description": "Constants"
    }, 
    "sim.exportMesh": {
        "body": "sim.exportMesh(${0:fileformat},${1:pathAndFilename},${2:options},${3:scalingFactor},${4:vertices},${5:indices},${6:nil},${7:names})", 
        "scope": "source.lua", 
        "prefix": "sim.exportMesh", 
        "description": "number result = sim.exportMesh(number fileformat,string pathAndFilename,number options,number scalingFactor,table_of_table vertices,table_of_table indices,nil,table names)Exports a mesh to a file. See also sim.importMesh and sim.getShapeMesh fileformat: the fileformat to export to. 0 for OBJ format, 1 for DXF format and 4 for BINARY STL formatpathAndFilename: the location of the file to create.options: keep at 0scalingFactor: the scaling factor to apply to the vertices to exportvertices: an array to vertice arrays. See the example belowverticesSizes: an array indicating the individual vertice array sizes. See the example belowindices: an array to indice arrays. See the example belowindicesSizes: an array indicating the individual indice array sizes. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names. See the example belowUSAGE EXAMPLE:// Exports all shapes in the scenesimInt shapeCount=0;while (simGetObjects(shapeCount++,sim_object_shape_type)!=-1);shapeCount--;simFloat** vertices=new simFloat*[shapeCount];simInt* verticesSizes=new simInt[shapeCount];simInt** indices=new simInt*[shapeCount];simInt* indicesSizes=new simInt[shapeCount];simChar** names=new simChar*[shapeCount];simInt index=0;while (true){    simInt shapeHandle=simGetObjects(index++,sim_object_shape_type);    if (shapeHandle<0)        break;    simFloat* vert;    simInt vertS;    simInt* ind;    simInt indS;    simGetShapeMesh(shapeHandle,&vert,&vertS,&ind,&indS,NULL);    vertices[index-1]=vert;    verticesSizes[index-1]=vertS;    indices[index-1]=ind;    indicesSizes[index-1]=indS;    names[index-1]=simGetObjectName(shapeHandle);    simFloat m[12];    simGetObjectMatrix(shapeHandle,-1,m);    for (simInt i=0;i<vertS/3;i++)    {        simFloat v[3]={vert[3*i+0],vert[3*i+1],vert[3*i+2]};        simTransformVector(m,v);        vert[3*i+0]=v[0];        vert[3*i+1]=v[1];        vert[3*i+2]=v[2];    }}simExportMesh(1,d:\\example.dxf,0,1,shapeCount,vertices,                 verticesSizes,indices,indicesSizes,NULL,names);for (simInt i=0;i<shapeCount;i++){    simReleaseBuffer((simChar*)vertices[i]);    simReleaseBuffer((simChar*)indices[i]);    simReleaseBuffer(names[i]);}delete[] vertices;delete[] verticesSizes;delete[] indices;delete[] indicesSizes;delete[] names;fileformat: the fileformat to export to. 0 for OBJ format, 1 for DXF format and 4 for BINARY STL formatpathAndFilename: the location of the file to create.options: keep at 0scalingFactor: the scaling factor to apply to the vertices to exportvertices: an array to vertice arrays. See the example belowverticesSizes: an array indicating the individual vertice array sizes. See the example belowindices: an array to indice arrays. See the example belowindicesSizes: an array indicating the individual indice array sizes. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names. See the example belowUSAGE EXAMPLE:// Exports all shapes in the scenesimInt shapeCount=0;while (simGetObjects(shapeCount++,sim_object_shape_type)!=-1);shapeCount--;simFloat** vertices=new simFloat*[shapeCount];simInt* verticesSizes=new simInt[shapeCount];simInt** indices=new simInt*[shapeCount];simInt* indicesSizes=new simInt[shapeCount];simChar** names=new simChar*[shapeCount];simInt index=0;while (true){    simInt shapeHandle=simGetObjects(index++,sim_object_shape_type);    if (shapeHandle<0)        break;    simFloat* vert;    simInt vertS;    simInt* ind;    simInt indS;    simGetShapeMesh(shapeHandle,&vert,&vertS,&ind,&indS,NULL);    vertices[index-1]=vert;    verticesSizes[index-1]=vertS;    indices[index-1]=ind;    indicesSizes[index-1]=indS;    names[index-1]=simGetObjectName(shapeHandle);    simFloat m[12];    simGetObjectMatrix(shapeHandle,-1,m);    for (simInt i=0;i<vertS/3;i++)    {        simFloat v[3]={vert[3*i+0],vert[3*i+1],vert[3*i+2]};        simTransformVector(m,v);        vert[3*i+0]=v[0];        vert[3*i+1]=v[1];        vert[3*i+2]=v[2];    }}simExportMesh(1,d:\\example.dxf,0,1,shapeCount,vertices,                 verticesSizes,indices,indicesSizes,NULL,names);for (simInt i=0;i<shapeCount;i++){    simReleaseBuffer((simChar*)vertices[i]);    simReleaseBuffer((simChar*)indices[i]);    simReleaseBuffer(names[i]);}delete[] vertices;delete[] verticesSizes;delete[] indices;delete[] indicesSizes;delete[] names;fileformat: the fileformat to export to. 0 for OBJ format, 1 for DXF format and 4 for BINARY STL formatpathAndFilename: the location of the file to create.options: keep at 0scalingFactor: the scaling factor to apply to the vertices to exportvertices: an array to vertice arrays. See the example belowverticesSizes: an array indicating the individual vertice array sizes. See the example belowindices: an array to indice arrays. See the example belowindicesSizes: an array indicating the individual indice array sizes. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names. See the example belowUSAGE EXAMPLE:// Exports all shapes in the scenesimInt shapeCount=0;while (simGetObjects(shapeCount++,sim_object_shape_type)!=-1);shapeCount--;simFloat** vertices=new simFloat*[shapeCount];simInt* verticesSizes=new simInt[shapeCount];simInt** indices=new simInt*[shapeCount];simInt* indicesSizes=new simInt[shapeCount];simChar** names=new simChar*[shapeCount];simInt index=0;while (true){    simInt shapeHandle=simGetObjects(index++,sim_object_shape_type);    if (shapeHandle<0)        break;    simFloat* vert;    simInt vertS;    simInt* ind;    simInt indS;    simGetShapeMesh(shapeHandle,&vert,&vertS,&ind,&indS,NULL);    vertices[index-1]=vert;    verticesSizes[index-1]=vertS;    indices[index-1]=ind;    indicesSizes[index-1]=indS;    names[index-1]=simGetObjectName(shapeHandle);    simFloat m[12];    simGetObjectMatrix(shapeHandle,-1,m);    for (simInt i=0;i<vertS/3;i++)    {        simFloat v[3]={vert[3*i+0],vert[3*i+1],vert[3*i+2]};        simTransformVector(m,v);        vert[3*i+0]=v[0];        vert[3*i+1]=v[1];        vert[3*i+2]=v[2];    }}simExportMesh(1,d:\\example.dxf,0,1,shapeCount,vertices,                 verticesSizes,indices,indicesSizes,NULL,names);for (simInt i=0;i<shapeCount;i++){    simReleaseBuffer((simChar*)vertices[i]);    simReleaseBuffer((simChar*)indices[i]);    simReleaseBuffer(names[i]);}delete[] vertices;delete[] verticesSizes;delete[] indices;delete[] indicesSizes;delete[] names;fileformat: the fileformat to export to. 0 for OBJ format, 1 for DXF format and 4 for BINARY STL formatpathAndFilename: the location of the file to create.options: keep at 0scalingFactor: the scaling factor to apply to the vertices to exportvertices: an array to vertice arrays. See the example belowverticesSizes: an array indicating the individual vertice array sizes. See the example belowindices: an array to indice arrays. See the example belowindicesSizes: an array indicating the individual indice array sizes. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names. See the example belowUSAGE EXAMPLE:// Exports all shapes in the scenesimInt shapeCount=0;while (simGetObjects(shapeCount++,sim_object_shape_type)!=-1);shapeCount--;simFloat** vertices=new simFloat*[shapeCount];simInt* verticesSizes=new simInt[shapeCount];simInt** indices=new simInt*[shapeCount];simInt* indicesSizes=new simInt[shapeCount];simChar** names=new simChar*[shapeCount];simInt index=0;while (true){    simInt shapeHandle=simGetObjects(index++,sim_object_shape_type);    if (shapeHandle<0)        break;    simFloat* vert;    simInt vertS;    simInt* ind;    simInt indS;    simGetShapeMesh(shapeHandle,&vert,&vertS,&ind,&indS,NULL);    vertices[index-1]=vert;    verticesSizes[index-1]=vertS;    indices[index-1]=ind;    indicesSizes[index-1]=indS;    names[index-1]=simGetObjectName(shapeHandle);    simFloat m[12];    simGetObjectMatrix(shapeHandle,-1,m);    for (simInt i=0;i<vertS/3;i++)    {        simFloat v[3]={vert[3*i+0],vert[3*i+1],vert[3*i+2]};        simTransformVector(m,v);        vert[3*i+0]=v[0];        vert[3*i+1]=v[1];        vert[3*i+2]=v[2];    }}simExportMesh(1,d:\\example.dxf,0,1,shapeCount,vertices,                 verticesSizes,indices,indicesSizes,NULL,names);for (simInt i=0;i<shapeCount;i++){    simReleaseBuffer((simChar*)vertices[i]);    simReleaseBuffer((simChar*)indices[i]);    simReleaseBuffer(names[i]);}delete[] vertices;delete[] verticesSizes;delete[] indices;delete[] indicesSizes;delete[] names;fileformat: the fileformat to export to. 0 for OBJ format, 1 for DXF format and 4 for BINARY STL formatpathAndFilename: the location of the file to create.options: keep at 0scalingFactor: the scaling factor to apply to the vertices to exportvertices: an array to vertice arrays. See the example belowverticesSizes: an array indicating the individual vertice array sizes. See the example belowindices: an array to indice arrays. See the example belowindicesSizes: an array indicating the individual indice array sizes. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names. See the example belowUSAGE EXAMPLE:// Exports all shapes in the scenesimInt shapeCount=0;while (simGetObjects(shapeCount++,sim_object_shape_type)!=-1);shapeCount--;simFloat** vertices=new simFloat*[shapeCount];simInt* verticesSizes=new simInt[shapeCount];simInt** indices=new simInt*[shapeCount];simInt* indicesSizes=new simInt[shapeCount];simChar** names=new simChar*[shapeCount];simInt index=0;while (true){    simInt shapeHandle=simGetObjects(index++,sim_object_shape_type);    if (shapeHandle<0)        break;    simFloat* vert;    simInt vertS;    simInt* ind;    simInt indS;    simGetShapeMesh(shapeHandle,&vert,&vertS,&ind,&indS,NULL);    vertices[index-1]=vert;    verticesSizes[index-1]=vertS;    indices[index-1]=ind;    indicesSizes[index-1]=indS;    names[index-1]=simGetObjectName(shapeHandle);    simFloat m[12];    simGetObjectMatrix(shapeHandle,-1,m);    for (simInt i=0;i<vertS/3;i++)    {        simFloat v[3]={vert[3*i+0],vert[3*i+1],vert[3*i+2]};        simTransformVector(m,v);        vert[3*i+0]=v[0];        vert[3*i+1]=v[1];        vert[3*i+2]=v[2];    }}simExportMesh(1,d:\\example.dxf,0,1,shapeCount,vertices,                 verticesSizes,indices,indicesSizes,NULL,names);for (simInt i=0;i<shapeCount;i++){    simReleaseBuffer((simChar*)vertices[i]);    simReleaseBuffer((simChar*)indices[i]);    simReleaseBuffer(names[i]);}delete[] vertices;delete[] verticesSizes;delete[] indices;delete[] indicesSizes;delete[] names;fileformat: the fileformat to export to. 0 for OBJ format, 1 for DXF format and 4 for BINARY STL formatpathAndFilename: the location of the file to create.options: keep at 0scalingFactor: the scaling factor to apply to the vertices to exportvertices: an array to vertice arrays. See the example belowverticesSizes: an array indicating the individual vertice array sizes. See the example belowindices: an array to indice arrays. See the example belowindicesSizes: an array indicating the individual indice array sizes. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names. See the example belowUSAGE EXAMPLE:// Exports all shapes in the scenesimInt shapeCount=0;while (simGetObjects(shapeCount++,sim_object_shape_type)!=-1);shapeCount--;simFloat** vertices=new simFloat*[shapeCount];simInt* verticesSizes=new simInt[shapeCount];simInt** indices=new simInt*[shapeCount];simInt* indicesSizes=new simInt[shapeCount];simChar** names=new simChar*[shapeCount];simInt index=0;while (true){    simInt shapeHandle=simGetObjects(index++,sim_object_shape_type);    if (shapeHandle<0)        break;    simFloat* vert;    simInt vertS;    simInt* ind;    simInt indS;    simGetShapeMesh(shapeHandle,&vert,&vertS,&ind,&indS,NULL);    vertices[index-1]=vert;    verticesSizes[index-1]=vertS;    indices[index-1]=ind;    indicesSizes[index-1]=indS;    names[index-1]=simGetObjectName(shapeHandle);    simFloat m[12];    simGetObjectMatrix(shapeHandle,-1,m);    for (simInt i=0;i<vertS/3;i++)    {        simFloat v[3]={vert[3*i+0],vert[3*i+1],vert[3*i+2]};        simTransformVector(m,v);        vert[3*i+0]=v[0];        vert[3*i+1]=v[1];        vert[3*i+2]=v[2];    }}simExportMesh(1,d:\\example.dxf,0,1,shapeCount,vertices,                 verticesSizes,indices,indicesSizes,NULL,names);for (simInt i=0;i<shapeCount;i++){    simReleaseBuffer((simChar*)vertices[i]);    simReleaseBuffer((simChar*)indices[i]);    simReleaseBuffer(names[i]);}delete[] vertices;delete[] verticesSizes;delete[] indices;delete[] indicesSizes;delete[] names;fileformat: the fileformat to export to. 0 for OBJ format, 1 for DXF format and 4 for BINARY STL formatpathAndFilename: the location of the file to create.options: keep at 0scalingFactor: the scaling factor to apply to the vertices to exportvertices: an array to vertice arrays. See the example belowverticesSizes: an array indicating the individual vertice array sizes. See the example belowindices: an array to indice arrays. See the example belowindicesSizes: an array indicating the individual indice array sizes. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names. See the example belowUSAGE EXAMPLE:// Exports all shapes in the scenesimInt shapeCount=0;while (simGetObjects(shapeCount++,sim_object_shape_type)!=-1);shapeCount--;simFloat** vertices=new simFloat*[shapeCount];simInt* verticesSizes=new simInt[shapeCount];simInt** indices=new simInt*[shapeCount];simInt* indicesSizes=new simInt[shapeCount];simChar** names=new simChar*[shapeCount];simInt index=0;while (true){    simInt shapeHandle=simGetObjects(index++,sim_object_shape_type);    if (shapeHandle<0)        break;    simFloat* vert;    simInt vertS;    simInt* ind;    simInt indS;    simGetShapeMesh(shapeHandle,&vert,&vertS,&ind,&indS,NULL);    vertices[index-1]=vert;    verticesSizes[index-1]=vertS;    indices[index-1]=ind;    indicesSizes[index-1]=indS;    names[index-1]=simGetObjectName(shapeHandle);    simFloat m[12];    simGetObjectMatrix(shapeHandle,-1,m);    for (simInt i=0;i<vertS/3;i++)    {        simFloat v[3]={vert[3*i+0],vert[3*i+1],vert[3*i+2]};        simTransformVector(m,v);        vert[3*i+0]=v[0];        vert[3*i+1]=v[1];        vert[3*i+2]=v[2];    }}simExportMesh(1,d:\\example.dxf,0,1,shapeCount,vertices,                 verticesSizes,indices,indicesSizes,NULL,names);for (simInt i=0;i<shapeCount;i++){    simReleaseBuffer((simChar*)vertices[i]);    simReleaseBuffer((simChar*)indices[i]);    simReleaseBuffer(names[i]);}delete[] vertices;delete[] verticesSizes;delete[] indices;delete[] indicesSizes;delete[] names;fileformat: the fileformat to export to. 0 for OBJ format, 1 for DXF format and 4 for BINARY STL formatpathAndFilename: the location of the file to create.options: keep at 0scalingFactor: the scaling factor to apply to the vertices to exportvertices: an array to vertice arrays. See the example belowverticesSizes: an array indicating the individual vertice array sizes. See the example belowindices: an array to indice arrays. See the example belowindicesSizes: an array indicating the individual indice array sizes. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names. See the example belowUSAGE EXAMPLE:// Exports all shapes in the scenesimInt shapeCount=0;while (simGetObjects(shapeCount++,sim_object_shape_type)!=-1);shapeCount--;simFloat** vertices=new simFloat*[shapeCount];simInt* verticesSizes=new simInt[shapeCount];simInt** indices=new simInt*[shapeCount];simInt* indicesSizes=new simInt[shapeCount];simChar** names=new simChar*[shapeCount];simInt index=0;while (true){    simInt shapeHandle=simGetObjects(index++,sim_object_shape_type);    if (shapeHandle<0)        break;    simFloat* vert;    simInt vertS;    simInt* ind;    simInt indS;    simGetShapeMesh(shapeHandle,&vert,&vertS,&ind,&indS,NULL);    vertices[index-1]=vert;    verticesSizes[index-1]=vertS;    indices[index-1]=ind;    indicesSizes[index-1]=indS;    names[index-1]=simGetObjectName(shapeHandle);    simFloat m[12];    simGetObjectMatrix(shapeHandle,-1,m);    for (simInt i=0;i<vertS/3;i++)    {        simFloat v[3]={vert[3*i+0],vert[3*i+1],vert[3*i+2]};        simTransformVector(m,v);        vert[3*i+0]=v[0];        vert[3*i+1]=v[1];        vert[3*i+2]=v[2];    }}simExportMesh(1,d:\\example.dxf,0,1,shapeCount,vertices,                 verticesSizes,indices,indicesSizes,NULL,names);for (simInt i=0;i<shapeCount;i++){    simReleaseBuffer((simChar*)vertices[i]);    simReleaseBuffer((simChar*)indices[i]);    simReleaseBuffer(names[i]);}delete[] vertices;delete[] verticesSizes;delete[] indices;delete[] indicesSizes;delete[] names;fileformat: the fileformat to export to. 0 for OBJ format, 1 for DXF format and 4 for BINARY STL formatpathAndFilename: the location of the file to create.options: keep at 0scalingFactor: the scaling factor to apply to the vertices to exportvertices: an array to vertice arrays. See the example belowverticesSizes: an array indicating the individual vertice array sizes. See the example belowindices: an array to indice arrays. See the example belowindicesSizes: an array indicating the individual indice array sizes. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names. See the example belowUSAGE EXAMPLE:// Exports all shapes in the scenesimInt shapeCount=0;while (simGetObjects(shapeCount++,sim_object_shape_type)!=-1);shapeCount--;simFloat** vertices=new simFloat*[shapeCount];simInt* verticesSizes=new simInt[shapeCount];simInt** indices=new simInt*[shapeCount];simInt* indicesSizes=new simInt[shapeCount];simChar** names=new simChar*[shapeCount];simInt index=0;while (true){    simInt shapeHandle=simGetObjects(index++,sim_object_shape_type);    if (shapeHandle<0)        break;    simFloat* vert;    simInt vertS;    simInt* ind;    simInt indS;    simGetShapeMesh(shapeHandle,&vert,&vertS,&ind,&indS,NULL);    vertices[index-1]=vert;    verticesSizes[index-1]=vertS;    indices[index-1]=ind;    indicesSizes[index-1]=indS;    names[index-1]=simGetObjectName(shapeHandle);    simFloat m[12];    simGetObjectMatrix(shapeHandle,-1,m);    for (simInt i=0;i<vertS/3;i++)    {        simFloat v[3]={vert[3*i+0],vert[3*i+1],vert[3*i+2]};        simTransformVector(m,v);        vert[3*i+0]=v[0];        vert[3*i+1]=v[1];        vert[3*i+2]=v[2];    }}simExportMesh(1,d:\\example.dxf,0,1,shapeCount,vertices,                 verticesSizes,indices,indicesSizes,NULL,names);for (simInt i=0;i<shapeCount;i++){    simReleaseBuffer((simChar*)vertices[i]);    simReleaseBuffer((simChar*)indices[i]);    simReleaseBuffer(names[i]);}delete[] vertices;delete[] verticesSizes;delete[] indices;delete[] indicesSizes;delete[] names;fileformat: the fileformat to export to. 0 for OBJ format, 1 for DXF format and 4 for BINARY STL formatpathAndFilename: the location of the file to create.options: keep at 0scalingFactor: the scaling factor to apply to the vertices to exportvertices: an array to vertice arrays. See the example belowverticesSizes: an array indicating the individual vertice array sizes. See the example belowindices: an array to indice arrays. See the example belowindicesSizes: an array indicating the individual indice array sizes. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names. See the example belowUSAGE EXAMPLE:// Exports all shapes in the scenesimInt shapeCount=0;while (simGetObjects(shapeCount++,sim_object_shape_type)!=-1);shapeCount--;simFloat** vertices=new simFloat*[shapeCount];simInt* verticesSizes=new simInt[shapeCount];simInt** indices=new simInt*[shapeCount];simInt* indicesSizes=new simInt[shapeCount];simChar** names=new simChar*[shapeCount];simInt index=0;while (true){    simInt shapeHandle=simGetObjects(index++,sim_object_shape_type);    if (shapeHandle<0)        break;    simFloat* vert;    simInt vertS;    simInt* ind;    simInt indS;    simGetShapeMesh(shapeHandle,&vert,&vertS,&ind,&indS,NULL);    vertices[index-1]=vert;    verticesSizes[index-1]=vertS;    indices[index-1]=ind;    indicesSizes[index-1]=indS;    names[index-1]=simGetObjectName(shapeHandle);    simFloat m[12];    simGetObjectMatrix(shapeHandle,-1,m);    for (simInt i=0;i<vertS/3;i++)    {        simFloat v[3]={vert[3*i+0],vert[3*i+1],vert[3*i+2]};        simTransformVector(m,v);        vert[3*i+0]=v[0];        vert[3*i+1]=v[1];        vert[3*i+2]=v[2];    }}simExportMesh(1,d:\\example.dxf,0,1,shapeCount,vertices,                 verticesSizes,indices,indicesSizes,NULL,names);for (simInt i=0;i<shapeCount;i++){    simReleaseBuffer((simChar*)vertices[i]);    simReleaseBuffer((simChar*)indices[i]);    simReleaseBuffer(names[i]);}delete[] vertices;delete[] verticesSizes;delete[] indices;delete[] indicesSizes;delete[] names;fileformat: the fileformat to export to. 0 for OBJ format, 1 for DXF format and 4 for BINARY STL formatpathAndFilename: the location of the file to create.options: keep at 0scalingFactor: the scaling factor to apply to the vertices to exportvertices: an array to vertice arrays. See the example belowverticesSizes: an array indicating the individual vertice array sizes. See the example belowindices: an array to indice arrays. See the example belowindicesSizes: an array indicating the individual indice array sizes. See the example belowreserved: reserved for future extensions. Keep at NULL.names: an array to mesh names. See the example belowUSAGE EXAMPLE:// Exports all shapes in the scenesimInt shapeCount=0;while (simGetObjects(shapeCount++,sim_object_shape_type)!=-1);shapeCount--;simFloat** vertices=new simFloat*[shapeCount];simInt* verticesSizes=new simInt[shapeCount];simInt** indices=new simInt*[shapeCount];simInt* indicesSizes=new simInt[shapeCount];simChar** names=new simChar*[shapeCount];simInt index=0;while (true){    simInt shapeHandle=simGetObjects(index++,sim_object_shape_type);    if (shapeHandle<0)        break;    simFloat* vert;    simInt vertS;    simInt* ind;    simInt indS;    simGetShapeMesh(shapeHandle,&vert,&vertS,&ind,&indS,NULL);    vertices[index-1]=vert;    verticesSizes[index-1]=vertS;    indices[index-1]=ind;    indicesSizes[index-1]=indS;    names[index-1]=simGetObjectName(shapeHandle);    simFloat m[12];    simGetObjectMatrix(shapeHandle,-1,m);    for (simInt i=0;i<vertS/3;i++)    {        simFloat v[3]={vert[3*i+0],vert[3*i+1],vert[3*i+2]};        simTransformVector(m,v);        vert[3*i+0]=v[0];        vert[3*i+1]=v[1];        vert[3*i+2]=v[2];    }}simExportMesh(1,d:\\example.dxf,0,1,shapeCount,vertices,                 verticesSizes,indices,indicesSizes,NULL,names);for (simInt i=0;i<shapeCount;i++){    simReleaseBuffer((simChar*)vertices[i]);    simReleaseBuffer((simChar*)indices[i]);    simReleaseBuffer(names[i]);}delete[] vertices;delete[] verticesSizes;delete[] indices;delete[] indicesSizes;delete[] names; -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.packUInt32Table": {
        "body": "sim.packUInt32Table(${0:uint32Numbers},${1:startUInt32Index=0},${2:uint32Count=0})", 
        "scope": "source.lua", 
        "prefix": "sim.packUInt32Table", 
        "description": "string data = sim.packUInt32Table(table uint32Numbers,number startUInt32Index=0,number uint32Count=0)Packs a table of uint32 numbers into a string. See also sim.unpackUInt32Table and the other packing/unpacking functions. - -"
    }, 
    "sim.navigation_camerashift": {
        "body": "sim.navigation_camerashift", 
        "scope": "source.lua", 
        "prefix": "sim.navigation_camerashift", 
        "description": "Constants"
    }, 
    "simUI.curve_scatter_shape.cross_square": {
        "body": "simUI.curve_scatter_shape.cross_square", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_scatter_shape.cross_square", 
        "description": "Constants"
    }, 
    "sim.shapeintparam_static": {
        "body": "sim.shapeintparam_static", 
        "scope": "source.lua", 
        "prefix": "sim.shapeintparam_static", 
        "description": "Constants"
    }, 
    "sim.getCollectionHandle": {
        "body": "sim.getCollectionHandle(${0:collectionName})", 
        "scope": "source.lua", 
        "prefix": "sim.getCollectionHandle", 
        "description": "number collectionHandle = sim.getCollectionHandle(string collectionName)Retrieves a collection handle based on its name. The operation of this function depends on the current name suffix settings (see sim.getNameSuffix, sim.setNameSuffix, and the section on accessing general-type objects). See also sim.createCollection, sim.addObjectToCollection, sim.getCollectionObjects and sim.isHandleValid. collectionName: name of the collectioncollectionName: name of the collection Handle of the collection, or -1 in case of an error"
    }, 
    "sim.setIkElementProperties": {
        "body": "sim.setIkElementProperties(${0:ikGroupHandle},${1:tipDummyHandle},${2:constraints},${3:precision=nil},${4:weight=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.setIkElementProperties", 
        "description": "number result = sim.setIkElementProperties(number ikGroupHandle,number tipDummyHandle,number constraints,table_2 precision=nil,table_2 weight=nil)Sets properties of a specific inverse kinematics element (IK element). See also sim.setIkGroupProperties and sim.getIkGroupHandle. ikGroupHandle: handle of the IK group that contains the IK element to modifytipDummyHandle: handle of the tip dummy object of the IK elementconstraints: the constraints of the ik element. sim_ik_avoidance_constraint is not allowedprecision: an array of two values where the first represents the linear precision, and the second the angular precision. Can be NULL to keep current settings.weight: an array of two values that represent the linear and angular resolution weights. Can be NULL to keep current settings.reserved: reserved for future extensions. Keep at NULLikGroupHandle: handle of the IK group that contains the IK element to modifytipDummyHandle: handle of the tip dummy object of the IK elementconstraints: the constraints of the ik element. sim_ik_avoidance_constraint is not allowedprecision: an array of two values where the first represents the linear precision, and the second the angular precision. Can be NULL to keep current settings.weight: an array of two values that represent the linear and angular resolution weights. Can be NULL to keep current settings.reserved: reserved for future extensions. Keep at NULLikGroupHandle: handle of the IK group that contains the IK element to modifytipDummyHandle: handle of the tip dummy object of the IK elementconstraints: the constraints of the ik element. sim_ik_avoidance_constraint is not allowedprecision: an array of two values where the first represents the linear precision, and the second the angular precision. Can be NULL to keep current settings.weight: an array of two values that represent the linear and angular resolution weights. Can be NULL to keep current settings.reserved: reserved for future extensions. Keep at NULLikGroupHandle: handle of the IK group that contains the IK element to modifytipDummyHandle: handle of the tip dummy object of the IK elementconstraints: the constraints of the ik element. sim_ik_avoidance_constraint is not allowedprecision: an array of two values where the first represents the linear precision, and the second the angular precision. Can be NULL to keep current settings.weight: an array of two values that represent the linear and angular resolution weights. Can be NULL to keep current settings.reserved: reserved for future extensions. Keep at NULLikGroupHandle: handle of the IK group that contains the IK element to modifytipDummyHandle: handle of the tip dummy object of the IK elementconstraints: the constraints of the ik element. sim_ik_avoidance_constraint is not allowedprecision: an array of two values where the first represents the linear precision, and the second the angular precision. Can be NULL to keep current settings.weight: an array of two values that represent the linear and angular resolution weights. Can be NULL to keep current settings.reserved: reserved for future extensions. Keep at NULLikGroupHandle: handle of the IK group that contains the IK element to modifytipDummyHandle: handle of the tip dummy object of the IK elementconstraints: the constraints of the ik element. sim_ik_avoidance_constraint is not allowedprecision: an array of two values where the first represents the linear precision, and the second the angular precision. Can be NULL to keep current settings.weight: an array of two values that represent the linear and angular resolution weights. Can be NULL to keep current settings.reserved: reserved for future extensions. Keep at NULL -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.vortex_body_primaxisvectory": {
        "body": "sim.vortex_body_primaxisvectory", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_primaxisvectory", 
        "description": "Constants"
    }, 
    "sim.filedlg_type_save": {
        "body": "sim.filedlg_type_save", 
        "scope": "source.lua", 
        "prefix": "sim.filedlg_type_save", 
        "description": "Constants"
    }, 
    "sim.getExtensionString": {
        "body": "sim.getExtensionString(${0:objectHandle},${1:index},${2:key=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.getExtensionString", 
        "description": "string theString = sim.getExtensionString(number objectHandle,number index,string key=nil)Retrieves a string that describes additional environment or object properties, mainly used by extension plugins. objectHandle: the handle of an object, or -1 if you wish to retrieve the extension string of the environment.index: keep to -1, unless the object is a shape, and you wish to retrieve the extension string of a shape component (since a shape can be a compound of several other shapes).key: an optional key indicating what value to retrieve. If none is specified, then the whole extension string will be returned. Keys should have the form of key@parentKey@...@parentKey. To retrieve the shadow enabled value of extension string povray{ shadow {true} fadeXDist {0.00}}, specify following key: shadow@povray. The key is case sensitive.objectHandle: the handle of an object, or -1 if you wish to retrieve the extension string of the environment.index: keep to -1, unless the object is a shape, and you wish to retrieve the extension string of a shape component (since a shape can be a compound of several other shapes).key: an optional key indicating what value to retrieve. If none is specified, then the whole extension string will be returned. Keys should have the form of key@parentKey@...@parentKey. To retrieve the shadow enabled value of extension string povray{ shadow {true} fadeXDist {0.00}}, specify following key: shadow@povray. The key is case sensitive.objectHandle: the handle of an object, or -1 if you wish to retrieve the extension string of the environment.index: keep to -1, unless the object is a shape, and you wish to retrieve the extension string of a shape component (since a shape can be a compound of several other shapes).key: an optional key indicating what value to retrieve. If none is specified, then the whole extension string will be returned. Keys should have the form of key@parentKey@...@parentKey. To retrieve the shadow enabled value of extension string povray{ shadow {true} fadeXDist {0.00}}, specify following key: shadow@povray. The key is case sensitive. a string if the operation was successful. The user is in charge of releasing the buffer with simReleaseBuffer."
    }, 
    "sim.getPathPosition": {
        "body": "sim.getPathPosition(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getPathPosition", 
        "description": "number position = sim.getPathPosition(number objectHandle)Retrieves the intrinsic position of a path object (a distance along the path). The position is given in meters, but the actual returned position is dependent on the selected path length calculation method for the given path object. See also sim.setPathPosition, sim.getPathLength, sim.getPositionOnPath and sim.getClosestPositionOnPath. objectHandle: handle of the path objectposition: linear position on the path given in meters (but dependent on the selected path length calculation method)objectHandle: handle of the path objectposition: linear position on the path given in meters (but dependent on the selected path length calculation method)objectHandle: handle of the path objectposition: linear position on the path given in meters (but dependent on the selected path length calculation method) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.vortex_joint_dependencyoffset": {
        "body": "sim.vortex_joint_dependencyoffset", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_dependencyoffset", 
        "description": "Constants"
    }, 
    "sim.visionfloatparam_ortho_size": {
        "body": "sim.visionfloatparam_ortho_size", 
        "scope": "source.lua", 
        "prefix": "sim.visionfloatparam_ortho_size", 
        "description": "Constants"
    }, 
    "sim.navigation_cameratilt": {
        "body": "sim.navigation_cameratilt", 
        "scope": "source.lua", 
        "prefix": "sim.navigation_cameratilt", 
        "description": "Constants"
    }, 
    "sim.msgbox_type_critical": {
        "body": "sim.msgbox_type_critical", 
        "scope": "source.lua", 
        "prefix": "sim.msgbox_type_critical", 
        "description": "Constants"
    }, 
    "sim.boolparam_scene_and_model_load_messages": {
        "body": "sim.boolparam_scene_and_model_load_messages", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_scene_and_model_load_messages", 
        "description": "Constants"
    }, 
    "sim.buffer_uint16": {
        "body": "sim.buffer_uint16", 
        "scope": "source.lua", 
        "prefix": "sim.buffer_uint16", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_error_pos": {
        "body": "sim.jointfloatparam_error_pos", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_error_pos", 
        "description": "Constants"
    }, 
    "sim.object_no_subtype": {
        "body": "sim.object_no_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.object_no_subtype", 
        "description": "Constants"
    }, 
    "simx.getObjectHandle": {
        "body": "simx.getObjectHandle(${0:clientId},${1:objectName})", 
        "scope": "source.lua", 
        "prefix": "simx.getObjectHandle", 
        "description": "number returnCode,number objectHandle= simx.getObjectHandle(number clientId,string objectName)Retrieves an object handle based on its name. If the client application is launched from a child script, then you could also let the child script figure out what handle correspond to what objects, and send the handles as additional arguments to the client application during its launch. See also simx.getObjectGroupData. clientID: the client ID. refer to simx.start.objectName: name of the object. If possibe, don't rely on the automatic name adjustment mechanism, and always specify the full object name, including the #: if the object is myJoint, specify myJoint#, if the object is myJoint#0, specify myJoint#0, etc.operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return codehandle: the object handle"
    }, 
    "sim.light_directional_subtype": {
        "body": "sim.light_directional_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.light_directional_subtype", 
        "description": "Constants"
    }, 
    "sim.addBanner": {
        "body": "sim.addBanner(${0:label},${1:size},${2:options},${3:positionAndEulerAngles=nil},${4:parentObjectHandle=nil},${5:labelColors=nil},${6:backgroundColors=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.addBanner", 
        "description": "number bannerID = sim.addBanner(string label,number size,number options,table_6 positionAndEulerAngles=nil,number parentObjectHandle=nil,table_12 labelColors=nil,table_12 backgroundColors=nil)                Adds a banner to the scene. Banners created in a                simulation script will be automatically removed at simulation end. See also                sim.removeBanner and                sim.addDrawingObject                                                 label: the label to display on the banner                                  size: the height in meters of the banner. When the option sim_banner_keepsamesize is used, this                  argument represents the banner height in pixels instead                                                                    options: a combination of                  banner options                                                  positionAndEulerAngles: 6 values representing the banner's position and orientation in space.                  Those values are absolute if the argument parentObjectHandle is -1, otherwise they are relative to the                  parent object's position and orientation. This argument can be NULL, in which case the identity transformation                  is assumed                                                                    parentObjectHandle: the handle of a scene object you wish to attach the banner to, or -1 if the                  banner should be independent.                                                                    labelColors: 12 values representing the RGB values (0-1) for the 3 color components of the text                  (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL, in                  which case a black color will be used                                                                    backgroundColors: 12 values representing the RGB values (0-1) for the 3 color components of the                  text background (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB).                  Can be NULL, in which case a white color will be used                                                                                  label: the label to display on the banner                                  size: the height in meters of the banner. When the option sim_banner_keepsamesize is used, this                  argument represents the banner height in pixels instead                                                                    options: a combination of                  banner options                                                  positionAndEulerAngles: 6 values representing the banner's position and orientation in space.                  Those values are absolute if the argument parentObjectHandle is -1, otherwise they are relative to the                  parent object's position and orientation. This argument can be NULL, in which case the identity transformation                  is assumed                                                                    parentObjectHandle: the handle of a scene object you wish to attach the banner to, or -1 if the                  banner should be independent.                                                                    labelColors: 12 values representing the RGB values (0-1) for the 3 color components of the text                  (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL, in                  which case a black color will be used                                                                    backgroundColors: 12 values representing the RGB values (0-1) for the 3 color components of the                  text background (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB).                  Can be NULL, in which case a white color will be used                                                                                  label: the label to display on the banner                                  size: the height in meters of the banner. When the option sim_banner_keepsamesize is used, this                  argument represents the banner height in pixels instead                                                                    options: a combination of                  banner options                                                  positionAndEulerAngles: 6 values representing the banner's position and orientation in space.                  Those values are absolute if the argument parentObjectHandle is -1, otherwise they are relative to the                  parent object's position and orientation. This argument can be NULL, in which case the identity transformation                  is assumed                                                                    parentObjectHandle: the handle of a scene object you wish to attach the banner to, or -1 if the                  banner should be independent.                                                                    labelColors: 12 values representing the RGB values (0-1) for the 3 color components of the text                  (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL, in                  which case a black color will be used                                                                    backgroundColors: 12 values representing the RGB values (0-1) for the 3 color components of the                  text background (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB).                  Can be NULL, in which case a white color will be used                                                                                  label: the label to display on the banner                                  size: the height in meters of the banner. When the option sim_banner_keepsamesize is used, this                  argument represents the banner height in pixels instead                                                                    options: a combination of                  banner options                                                  positionAndEulerAngles: 6 values representing the banner's position and orientation in space.                  Those values are absolute if the argument parentObjectHandle is -1, otherwise they are relative to the                  parent object's position and orientation. This argument can be NULL, in which case the identity transformation                  is assumed                                                                    parentObjectHandle: the handle of a scene object you wish to attach the banner to, or -1 if the                  banner should be independent.                                                                    labelColors: 12 values representing the RGB values (0-1) for the 3 color components of the text                  (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL, in                  which case a black color will be used                                                                    backgroundColors: 12 values representing the RGB values (0-1) for the 3 color components of the                  text background (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB).                  Can be NULL, in which case a white color will be used                                                                                  label: the label to display on the banner                                  size: the height in meters of the banner. When the option sim_banner_keepsamesize is used, this                  argument represents the banner height in pixels instead                                                                    options: a combination of                  banner options                                                  positionAndEulerAngles: 6 values representing the banner's position and orientation in space.                  Those values are absolute if the argument parentObjectHandle is -1, otherwise they are relative to the                  parent object's position and orientation. This argument can be NULL, in which case the identity transformation                  is assumed                                                                    parentObjectHandle: the handle of a scene object you wish to attach the banner to, or -1 if the                  banner should be independent.                                                                    labelColors: 12 values representing the RGB values (0-1) for the 3 color components of the text                  (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL, in                  which case a black color will be used                                                                    backgroundColors: 12 values representing the RGB values (0-1) for the 3 color components of the                  text background (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB).                  Can be NULL, in which case a white color will be used                                                                                  label: the label to display on the banner                                  size: the height in meters of the banner. When the option sim_banner_keepsamesize is used, this                  argument represents the banner height in pixels instead                                                                    options: a combination of                  banner options                                                  positionAndEulerAngles: 6 values representing the banner's position and orientation in space.                  Those values are absolute if the argument parentObjectHandle is -1, otherwise they are relative to the                  parent object's position and orientation. This argument can be NULL, in which case the identity transformation                  is assumed                                                                    parentObjectHandle: the handle of a scene object you wish to attach the banner to, or -1 if the                  banner should be independent.                                                                    labelColors: 12 values representing the RGB values (0-1) for the 3 color components of the text                  (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL, in                  which case a black color will be used                                                                    backgroundColors: 12 values representing the RGB values (0-1) for the 3 color components of the                  text background (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB).                  Can be NULL, in which case a white color will be used                                                                                  label: the label to display on the banner                                  size: the height in meters of the banner. When the option sim_banner_keepsamesize is used, this                  argument represents the banner height in pixels instead                                                                    options: a combination of                  banner options                                                  positionAndEulerAngles: 6 values representing the banner's position and orientation in space.                  Those values are absolute if the argument parentObjectHandle is -1, otherwise they are relative to the                  parent object's position and orientation. This argument can be NULL, in which case the identity transformation                  is assumed                                                                    parentObjectHandle: the handle of a scene object you wish to attach the banner to, or -1 if the                  banner should be independent.                                                                    labelColors: 12 values representing the RGB values (0-1) for the 3 color components of the text                  (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL, in                  which case a black color will be used                                                                    backgroundColors: 12 values representing the RGB values (0-1) for the 3 color components of the                  text background (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB).                  Can be NULL, in which case a white color will be used                                                                 handle of the banner if successful, -1 otherwise"
    }, 
    "sim.customizationscriptcall_simulationactuation": {
        "body": "sim.customizationscriptcall_simulationactuation", 
        "scope": "source.lua", 
        "prefix": "sim.customizationscriptcall_simulationactuation", 
        "description": "Constants"
    }, 
    "sim.pure_primitive_none": {
        "body": "sim.pure_primitive_none", 
        "scope": "source.lua", 
        "prefix": "sim.pure_primitive_none", 
        "description": "Constants"
    }, 
    "simOMPL.setAlgorithm": {
        "body": "simOMPL.setAlgorithm(${0:taskHandle},${1:algorithm})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.setAlgorithm", 
        "description": "number result = simOMPL.setAlgorithm(number taskHandle,number algorithm)"
    }, 
    "sim.vortex_body_secangularaxisstaticfrictionscale": {
        "body": "sim.vortex_body_secangularaxisstaticfrictionscale", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_secangularaxisstaticfrictionscale", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_frictionenabledbc": {
        "body": "sim.vortex_joint_frictionenabledbc", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_frictionenabledbc", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_addbuffer1": {
        "body": "sim.filtercomponent_addbuffer1", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_addbuffer1", 
        "description": "Constants"
    }, 
    "sim.removeIkGroup": {
        "body": "sim.removeIkGroup(${0:ikGroupHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.removeIkGroup", 
        "description": "number result = sim.removeIkGroup(number ikGroupHandle)Removes an IK group. See also sim.getIkGroupHandle and sim.createIkGroup. ikGroupHandle: handle of an IK group. -1 if operation was not successful."
    }, 
    "sim.dynmat_default": {
        "body": "sim.dynmat_default", 
        "scope": "source.lua", 
        "prefix": "sim.dynmat_default", 
        "description": "Constants"
    }, 
    "sim.getScriptName": {
        "body": "sim.getScriptName(${0:scriptHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getScriptName", 
        "description": "string scriptName = sim.getScriptName(number scriptHandle)Retrieves a script's name based on its handle. A script doesn't have a name assigned, however if the script is a child script and associated with a scene object, then this function will retrieve the name of the associated scene object. If the script is not a child script or is not associated with a scene object, then the returned value is NULL  scriptHandle: handle of the scriptscriptHandle: handle of the script buffer to the script's name if function was successful and the name is valid, NULL otherwise. The user is in charge of releasing the returned buffer with simReleaseBuffer"
    }, 
    "sim.setThreadResumeLocation": {
        "body": "sim.setThreadResumeLocation(${0:location},${1:order})", 
        "scope": "source.lua", 
        "prefix": "sim.setThreadResumeLocation", 
        "description": "number result = sim.setThreadResumeLocation(number location,number order)Allows specifying when and in which order child script threads are resumed. If the current script doesn't run in a thread (i.e. if it runs in the application main thread), this function has no effect. By default, V-REP doesn't use regular threads, but something similar to hybrid threads (which behave like coroutines, but can also behave like regular threads). This allows much more flexibility and execution control of the threads. Once a thread switched to another thread, it will resume execution when the main script calls sim.resumeThreads with the corresponding argument, which represents a child script thread resume location. In order to also have full synchronization control between threads, you can assign a resume location and order to each thread with this function. See also sim.setThreadSwitchTiming, sim.setThreadAutomaticSwitch, sim.switchThread and sim.setThreadIsFree. - -"
    }, 
    "simOMPL.StateSpaceType.pose3d": {
        "body": "simOMPL.StateSpaceType.pose3d", 
        "scope": "source.lua", 
        "prefix": "simOMPL.StateSpaceType.pose3d", 
        "description": "Constants"
    }, 
    "sim.getJointForce": {
        "body": "sim.getJointForce(${0:jointHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getJointForce", 
        "description": "number forceOrTorque = sim.getJointForce(number jointHandle)Retrieves the force or torque applied to a joint  along/about its active axis. This function retrieves meaningful information only if the joint is prismatic or revolute, and is dynamically enabled. With the Bullet engine, this function returns the force or torque applied to the joint motor  (torques from joint limits are not taken into account). With the ODE and Vortex engine, this function returns the total force or torque applied to a joint  along/about its z-axis. See also sim.setJointForce and sim.readForceSensor. jointHandle: handle of the joint. Can be combined with sim_handleflag_rawvalue (simply add sim_handleflag_rawvalue to jointHandle), if you wish to access the raw values generated by each individual dynamic simulation step (by default, there are 10 dynamic simulation steps for each simulation step). Raw values can only be accessed from inside a callback function triggered by the physics engine.forceOrTorque: the force or the torque applied to the joint  along/about its z-axis.jointHandle: handle of the joint. Can be combined with sim_handleflag_rawvalue (simply add sim_handleflag_rawvalue to jointHandle), if you wish to access the raw values generated by each individual dynamic simulation step (by default, there are 10 dynamic simulation steps for each simulation step). Raw values can only be accessed from inside a callback function triggered by the physics engine.forceOrTorque: the force or the torque applied to the joint  along/about its z-axis.jointHandle: handle of the joint. Can be combined with sim_handleflag_rawvalue (simply add sim_handleflag_rawvalue to jointHandle), if you wish to access the raw values generated by each individual dynamic simulation step (by default, there are 10 dynamic simulation steps for each simulation step). Raw values can only be accessed from inside a callback function triggered by the physics engine.forceOrTorque: the force or the torque applied to the joint  along/about its z-axis. -1 if operation was not successful. 0 if no value is available yet (e.g. when simHandleDynamics hasn't yet handled that joint), otherwise a value >0."
    }, 
    "sim.dummyintparam_follow_path": {
        "body": "sim.dummyintparam_follow_path", 
        "scope": "source.lua", 
        "prefix": "sim.dummyintparam_follow_path", 
        "description": "Constants"
    }, 
    "sim.drawing_trianglepoints": {
        "body": "sim.drawing_trianglepoints", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_trianglepoints", 
        "description": "Constants"
    }, 
    "sim.bullet_body_lineardamping": {
        "body": "sim.bullet_body_lineardamping", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_body_lineardamping", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_velocity": {
        "body": "sim.jointfloatparam_velocity", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_velocity", 
        "description": "Constants"
    }, 
    "sim.loadModel": {
        "body": "sim.loadModel(${0:filename})", 
        "scope": "source.lua", 
        "prefix": "sim.loadModel", 
        "description": "number objectHandle = sim.loadModel(string filename)Loads a previously saved model, and selects it. See also sim.saveModel, sim.loadScene, and sim.setBoolParameter with sim.boolparam_scene_and_model_load_messages. filename: model filename. The filename extension is required (ttm) -1 if operation was not successful. Otherwise the handle of the model base object."
    }, 
    "simUI.setNodeInletCount": {
        "body": "simUI.setNodeInletCount(${0:handle},${1:id},${2:nodeId},${3:count})", 
        "scope": "source.lua", 
        "prefix": "simUI.setNodeInletCount", 
        "description": "simUI.setNodeInletCount(number handle,number id,number nodeId,number count)"
    }, 
    "simUI.setMouseOptions": {
        "body": "simUI.setMouseOptions(${0:handle},${1:id},${2:panX},${3:panY},${4:zoomX},${5:zoomY})", 
        "scope": "source.lua", 
        "prefix": "simUI.setMouseOptions", 
        "description": "simUI.setMouseOptions(number handle,number id,bool panX,bool panY,bool zoomX,bool zoomY)"
    }, 
    "sim.importShape": {
        "body": "sim.importShape(${0:fileformat},${1:pathAndFilename},${2:options},${3:identicalVerticeTolerance},${4:scalingFactor})", 
        "scope": "source.lua", 
        "prefix": "sim.importShape", 
        "description": "number shapeHandle = sim.importShape(number fileformat,string pathAndFilename,number options,number identicalVerticeTolerance,number scalingFactor)Imports a shape from a file (first imports meshes, then groups/merges them into a shape). See also sim.importMesh. fileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format,  4 for BINARY STL format and 5 for COLLADA format (in that case, make sure the collada plugin is available and correctly loaded).pathAndFilename: the location of the file to import.options: bit-coded:bit0 set (1): keep identical verticesbit1 set (2): keep identical trianglesbit2 set (4): reserved. keep at 0.bit3 set (8): do not preserve colors (only for COLLADA format for now)bit4 set (16): tries to preserve textures (OBJ format only). When this bit is set and several shapes are imported, they will be grouped. If the bit is not set and several shapes are imported, they will be merged.identicalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesfileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format,  4 for BINARY STL format and 5 for COLLADA format (in that case, make sure the collada plugin is available and correctly loaded).pathAndFilename: the location of the file to import.options: bit-coded:bit0 set (1): keep identical verticesbit1 set (2): keep identical trianglesbit2 set (4): reserved. keep at 0.bit3 set (8): do not preserve colors (only for COLLADA format for now)bit4 set (16): tries to preserve textures (OBJ format only). When this bit is set and several shapes are imported, they will be grouped. If the bit is not set and several shapes are imported, they will be merged.identicalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesfileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format,  4 for BINARY STL format and 5 for COLLADA format (in that case, make sure the collada plugin is available and correctly loaded).pathAndFilename: the location of the file to import.options: bit-coded:bit0 set (1): keep identical verticesbit1 set (2): keep identical trianglesbit2 set (4): reserved. keep at 0.bit3 set (8): do not preserve colors (only for COLLADA format for now)bit4 set (16): tries to preserve textures (OBJ format only). When this bit is set and several shapes are imported, they will be grouped. If the bit is not set and several shapes are imported, they will be merged.identicalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesfileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format,  4 for BINARY STL format and 5 for COLLADA format (in that case, make sure the collada plugin is available and correctly loaded).pathAndFilename: the location of the file to import.options: bit-coded:bit0 set (1): keep identical verticesbit1 set (2): keep identical trianglesbit2 set (4): reserved. keep at 0.bit3 set (8): do not preserve colors (only for COLLADA format for now)bit4 set (16): tries to preserve textures (OBJ format only). When this bit is set and several shapes are imported, they will be grouped. If the bit is not set and several shapes are imported, they will be merged.identicalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesfileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format,  4 for BINARY STL format and 5 for COLLADA format (in that case, make sure the collada plugin is available and correctly loaded).pathAndFilename: the location of the file to import.options: bit-coded:bit0 set (1): keep identical verticesbit1 set (2): keep identical trianglesbit2 set (4): reserved. keep at 0.bit3 set (8): do not preserve colors (only for COLLADA format for now)bit4 set (16): tries to preserve textures (OBJ format only). When this bit is set and several shapes are imported, they will be grouped. If the bit is not set and several shapes are imported, they will be merged.identicalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesfileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format,  4 for BINARY STL format and 5 for COLLADA format (in that case, make sure the collada plugin is available and correctly loaded).pathAndFilename: the location of the file to import.options: bit-coded:bit0 set (1): keep identical verticesbit1 set (2): keep identical trianglesbit2 set (4): reserved. keep at 0.bit3 set (8): do not preserve colors (only for COLLADA format for now)bit4 set (16): tries to preserve textures (OBJ format only). When this bit is set and several shapes are imported, they will be grouped. If the bit is not set and several shapes are imported, they will be merged.identicalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesfileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format,  4 for BINARY STL format and 5 for COLLADA format (in that case, make sure the collada plugin is available and correctly loaded).pathAndFilename: the location of the file to import.options: bit-coded:bit0 set (1): keep identical verticesbit1 set (2): keep identical trianglesbit2 set (4): reserved. keep at 0.bit3 set (8): do not preserve colors (only for COLLADA format for now)bit4 set (16): tries to preserve textures (OBJ format only). When this bit is set and several shapes are imported, they will be grouped. If the bit is not set and several shapes are imported, they will be merged.identicalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesfileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format,  4 for BINARY STL format and 5 for COLLADA format (in that case, make sure the collada plugin is available and correctly loaded).pathAndFilename: the location of the file to import.options: bit-coded:bit0 set (1): keep identical verticesbit1 set (2): keep identical trianglesbit2 set (4): reserved. keep at 0.bit3 set (8): do not preserve colors (only for COLLADA format for now)bit4 set (16): tries to preserve textures (OBJ format only). When this bit is set and several shapes are imported, they will be grouped. If the bit is not set and several shapes are imported, they will be merged.identicalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesfileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format,  4 for BINARY STL format and 5 for COLLADA format (in that case, make sure the collada plugin is available and correctly loaded).pathAndFilename: the location of the file to import.options: bit-coded:bit0 set (1): keep identical verticesbit1 set (2): keep identical trianglesbit2 set (4): reserved. keep at 0.bit3 set (8): do not preserve colors (only for COLLADA format for now)bit4 set (16): tries to preserve textures (OBJ format only). When this bit is set and several shapes are imported, they will be grouped. If the bit is not set and several shapes are imported, they will be merged.identicalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported verticesfileformat: the fileformat to import from. 0 for OBJ format, 1 for DXF format, 2 for 3DS format, 3 for ASCII STL format,  4 for BINARY STL format and 5 for COLLADA format (in that case, make sure the collada plugin is available and correctly loaded).pathAndFilename: the location of the file to import.options: bit-coded:bit0 set (1): keep identical verticesbit1 set (2): keep identical trianglesbit2 set (4): reserved. keep at 0.bit3 set (8): do not preserve colors (only for COLLADA format for now)bit4 set (16): tries to preserve textures (OBJ format only). When this bit is set and several shapes are imported, they will be grouped. If the bit is not set and several shapes are imported, they will be merged.identicalVerticeTolerance: the distance from which two distinct vertices will be merged. Bit0 of options should be cleared for this to have an effectscalingFactor: the scaling factor to apply to the imported vertices The handle of the imported shape, or -1 if the operation was not successful"
    }, 
    "sim.displayattribute_forvisionsensor": {
        "body": "sim.displayattribute_forvisionsensor", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_forvisionsensor", 
        "description": "Constants"
    }, 
    "sim.navigation_camerafly": {
        "body": "sim.navigation_camerafly", 
        "scope": "source.lua", 
        "prefix": "sim.navigation_camerafly", 
        "description": "Constants"
    }, 
    "sim.vortex_body_seclinaxissameasprimlinaxis": {
        "body": "sim.vortex_body_seclinaxissameasprimlinaxis", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_seclinaxissameasprimlinaxis", 
        "description": "Constants"
    }, 
    "sim.handleCustomizationScripts": {
        "body": "sim.handleCustomizationScripts(${0:callType})", 
        "scope": "source.lua", 
        "prefix": "sim.handleCustomizationScripts", 
        "description": "number count = sim.handleCustomizationScripts(number callType)"
    }, 
    "simUI.setRadiobuttonValue": {
        "body": "simUI.setRadiobuttonValue(${0:handle},${1:id},${2:value},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setRadiobuttonValue", 
        "description": "simUI.setRadiobuttonValue(number handle,number id,number value,bool suppressEvents=true)"
    }, 
    "sim.appobj_script_type": {
        "body": "sim.appobj_script_type", 
        "scope": "source.lua", 
        "prefix": "sim.appobj_script_type", 
        "description": "Constants"
    }, 
    "simx.getIntegerSignal": {
        "body": "simx.getIntegerSignal(${0:clientId},${1:signalName})", 
        "scope": "source.lua", 
        "prefix": "simx.getIntegerSignal", 
        "description": "number returnCode,number signalValue= simx.getIntegerSignal(number clientId,string signalName)Gets the value of an integer signal. Signals are cleared at simulation start. See also simx.setIntegerSignal, simx.clearIntegerSignal, simx.getFloatSignal and simx.getStringSignal. clientID: the client ID. refer to simx.start.signalName: name of the signaloperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls) returnCode: a remote API function return codesignalValue: the value of the signal"
    }, 
    "sim.filtercomponent_addtobuffer1": {
        "body": "sim.filtercomponent_addtobuffer1", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_addtobuffer1", 
        "description": "Constants"
    }, 
    "req": {
        "body": "require(\"${1:module}\")", 
        "scope": "source.lua", 
        "prefix": "req", 
        "description": "require()"
    }, 
    "sim.customizationscriptcall_firstafterinstanceswitch": {
        "body": "sim.customizationscriptcall_firstafterinstanceswitch", 
        "scope": "source.lua", 
        "prefix": "sim.customizationscriptcall_firstafterinstanceswitch", 
        "description": "Constants"
    }, 
    "ret": {
        "body": "return ${1:...}", 
        "scope": "source.lua", 
        "prefix": "ret", 
        "description": "return ..."
    }, 
    "sim.openModule": {
        "body": "sim.openModule(${0:sim_handle_all})", 
        "scope": "source.lua", 
        "prefix": "sim.openModule", 
        "description": "number result = sim.openModule(sim_handle_all)Opens a plugin (allowing it to reserve resources at the start of a simulation). This command can only be called from the main script. Call it from the main script in the first simulation pass (usually with sim.handle_all argument). sim.openModule is not available in the C-API. Look at the default main script to get an idea about how to use sim.openModule, sim.handleModule and sim.closeModule. - -"
    }, 
    "sim.buildIdentityMatrix": {
        "body": "sim.buildIdentityMatrix()", 
        "scope": "source.lua", 
        "prefix": "sim.buildIdentityMatrix", 
        "description": "table_12 matrix = sim.buildIdentityMatrix()Builds an identity transformation matrix. See also the other matrix/transformation functions matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11]) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simSurfRec.Algorithm.poisson": {
        "body": "simSurfRec.Algorithm.poisson", 
        "scope": "source.lua", 
        "prefix": "simSurfRec.Algorithm.poisson", 
        "description": "Constants"
    }, 
    "simUI.setItemEditable": {
        "body": "simUI.setItemEditable(${0:handle},${1:id},${2:row},${3:column},${4:editable})", 
        "scope": "source.lua", 
        "prefix": "simUI.setItemEditable", 
        "description": "simUI.setItemEditable(number handle,number id,number row,number column,bool editable)"
    }, 
    "sim.boolparam_proximity_sensor_handling_enabled": {
        "body": "sim.boolparam_proximity_sensor_handling_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_proximity_sensor_handling_enabled", 
        "description": "Constants"
    }, 
    "simRRS1.SELECT_MOTION_TYPE": {
        "body": "simRRS1.SELECT_MOTION_TYPE(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SELECT_MOTION_TYPE", 
        "description": "int status= simRRS1.SELECT_MOTION_TYPE(bitstring2 rcsHandle)"
    }, 
    "sim.vortex_joint_p1stiffness": {
        "body": "sim.vortex_joint_p1stiffness", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p1stiffness", 
        "description": "Constants"
    }, 
    "sim.boolparam_full_model_copy_from_api": {
        "body": "sim.boolparam_full_model_copy_from_api", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_full_model_copy_from_api", 
        "description": "Constants"
    }, 
    "sim.unloadModule": {
        "body": "sim.unloadModule(${0:pluginHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.unloadModule", 
        "description": "number result = sim.unloadModule(number pluginHandle)Unloads a V-REP plugin. This should usually be done just before ending the simulator. Alternatively, you can also unload a plugin that was dynamically loaded at any time. This can however lead to a crash if the plugin registered custom Lua functions via simRegisterCustomLuaFunction (deprecated) without specifying a function name as functionName@pluginName. See also simSendModuleMessage and sim.loadModule. pluginhandle: handle of the plugin 0 if plugin was not unloaded (e.g. because it was not loaded, or because it was loaded more than once). Different from 0 if the plugin was successfully unloaded"
    }, 
    "sim.boolparam_statustext_open": {
        "body": "sim.boolparam_statustext_open", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_statustext_open", 
        "description": "Constants"
    }, 
    "sim.checkProximitySensor": {
        "body": "sim.checkProximitySensor(${0:sensorHandle},${1:entityHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.checkProximitySensor", 
        "description": "number result,number distance,table_3 detectedPoint = sim.checkProximitySensor(number sensorHandle,number entityHandle)Checks whether the proximity sensor detects the indicated entity. Detection is silent (no visual feedback) compared to sim.handleProximitySensor. Also, the detectable flags of the entity are overridden if the entity is an object. See also sim.readProximitySensor and sim.checkProximitySensorEx. sensorHandle: handle of the proximity sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsdetectedPoint: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be NULLsensorHandle: handle of the proximity sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsdetectedPoint: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be NULLsensorHandle: handle of the proximity sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsdetectedPoint: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be NULLsensorHandle: handle of the proximity sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsdetectedPoint: coordinates of detected point relative to the sensor origin (detectedPoint[0]-detectedPoint[2]), and distance of detected point to the sensor origin (detectedPoint[3]). Can be NULL -1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)"
    }, 
    "sim.startSimulation": {
        "body": "sim.startSimulation()", 
        "scope": "source.lua", 
        "prefix": "sim.startSimulation", 
        "description": "number result = sim.startSimulation()Requests a start of a simulation (or a resume of a paused simulation). See also sim.pauseSimulation, sim.stopSimulation and sim.getSimulationState. See also the simulation state diagram. None -1 in case of an error, 0 if the operation could not be performed. >0 in case of success."
    }, 
    "sysCall_afterSimulation": {
        "body": "sysCall_afterSimulation(${0:ended.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_afterSimulation", 
        "description": "sysCall_afterSimulation(Called just after simulation ended.)"
    }, 
    "simx.headeroffset_message_id": {
        "body": "simx.headeroffset_message_id", 
        "scope": "source.lua", 
        "prefix": "simx.headeroffset_message_id", 
        "description": "Constants"
    }, 
    "simx.transferFile": {
        "body": "simx.transferFile(${0:clientId},${1:filePathAndName},${2:filename_serverSide},${3:timeOut})", 
        "scope": "source.lua", 
        "prefix": "simx.transferFile", 
        "description": "number returnCode= simx.transferFile(number clientId,string filePathAndName,string filename_serverSide,number timeOut)Allows transferring a file from the client to the server. This function is used by several other functions internally (e.g. simx.loadModel). See also simx.eraseFile. This is a remote API helper function. clientID: the client ID. refer to simx.start.filePathAndName: the local file name and path (i.e. on the client side)fileName_serverSide: a file name under which the transferred file will be saved on the server side. For now, do not specify a path (the file will be saved in the remote API plugin directory)timeOut: a timeout value in millisecondsoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return code"
    }, 
    "sim.loadModule": {
        "body": "sim.loadModule(${0:filenameAndPath},${1:pluginName})", 
        "scope": "source.lua", 
        "prefix": "sim.loadModule", 
        "description": "number pluginHandle = sim.loadModule(string filenameAndPath,string pluginName)Loads a V-REP plugin. This should usually be done in the main client application, just after simRunSimulator was called. Alternatively, you can also dynamically load/unload a plugin, but depending on the plugin function, this might not work/lead to a crash. In case the dynamically loaded plugin registers custom Lua functions, those functions cannot be used in scripts that were already initialized (except for the script that called sim.loadModule). Normally, all plugins of type v_repExtXXX.dll (or libv_repExtXXX.so or libv_repExtXXX.dylib) in the V-REP directory are loaded at application start. Plugins that are meant to be dynamically loaded should use a different name, or a different directory. See also simSendModuleMessage and sim.unloadModule. filenameAndPath: file name and path of the pluginpluginName: name of the plugin. If the file name is v_repExtXXX.dll, then the name should be XXXfilenameAndPath: file name and path of the pluginpluginName: name of the plugin. If the file name is v_repExtXXX.dll, then the name should be XXX handle of the plugin if value is 0 or positive. otherwise:-3: plugin could not be loaded-2: plugin is missing entry points-1: plugin could not initializehandle of the plugin if value is 0 or positive. otherwise:-3: plugin could not be loaded-2: plugin is missing entry points-1: plugin could not initializehandle of the plugin if value is 0 or positive. otherwise:-3: plugin could not be loaded-2: plugin is missing entry points-1: plugin could not initializehandle of the plugin if value is 0 or positive. otherwise:-3: plugin could not be loaded-2: plugin is missing entry points-1: plugin could not initialize"
    }, 
    "sim.filtercomponent_originalimage": {
        "body": "sim.filtercomponent_originalimage", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_originalimage", 
        "description": "Constants"
    }, 
    "sim.ikresult_success": {
        "body": "sim.ikresult_success", 
        "scope": "source.lua", 
        "prefix": "sim.ikresult_success", 
        "description": "Constants"
    }, 
    "simROS.sendTransforms": {
        "body": "simROS.sendTransforms(${0:transforms})", 
        "scope": "source.lua", 
        "prefix": "simROS.sendTransforms", 
        "description": "simROS.sendTransforms(table transforms)"
    }, 
    "simx.getDistanceHandle": {
        "body": "simx.getDistanceHandle(${0:clientId},${1:distanceObjectName})", 
        "scope": "source.lua", 
        "prefix": "simx.getDistanceHandle", 
        "description": "number returnCode,number distanceHandle= simx.getDistanceHandle(number clientId,string distanceObjectName)Retrieves a distance  object handle based on its name. If the client application is launched from a child script, then you could also let the child script figure out what handle correspond to what distance object, and send the handles as additional arguments to the client application during its launch.  See also simx.getObjectGroupData. clientID: the client ID. refer to simx.start.distanceObjectName: name of the distance object. If possibe, don't rely on the automatic name adjustment mechanism, and always specify the full distance object name, including the #: if the distance object is myDistance, specify myDistance#, if the distance object is myDistance#0, specify myDistance#0, etc.operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return codehandle: the handle"
    }, 
    "sim.displayattribute_forbidedges": {
        "body": "sim.displayattribute_forbidedges", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_forbidedges", 
        "description": "Constants"
    }, 
    "sim.filedlg_type_folder": {
        "body": "sim.filedlg_type_folder", 
        "scope": "source.lua", 
        "prefix": "sim.filedlg_type_folder", 
        "description": "Constants"
    }, 
    "sim.bullet_body_nondefaultcollisionmargingfactorconvex": {
        "body": "sim.bullet_body_nondefaultcollisionmargingfactorconvex", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_body_nondefaultcollisionmargingfactorconvex", 
        "description": "Constants"
    }, 
    "sim.intparam_idle_fps": {
        "body": "sim.intparam_idle_fps", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_idle_fps", 
        "description": "Constants"
    }, 
    "sim.boolparam_mill_handling_enabled": {
        "body": "sim.boolparam_mill_handling_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_mill_handling_enabled", 
        "description": "Constants"
    }, 
    "sim.ik_alpha_beta_constraint": {
        "body": "sim.ik_alpha_beta_constraint", 
        "scope": "source.lua", 
        "prefix": "sim.ik_alpha_beta_constraint", 
        "description": "Constants"
    }, 
    "sim.ik_damped_least_squares_method": {
        "body": "sim.ik_damped_least_squares_method", 
        "scope": "source.lua", 
        "prefix": "sim.ik_damped_least_squares_method", 
        "description": "Constants"
    }, 
    "utf8.codepoint": {
        "body": "utf8.codepoint(${0:...})", 
        "scope": "source.lua", 
        "prefix": "utf8.codepoint", 
        "description": "5.3\n\nutf8.codepoint (s [, i [, j]])"
    }, 
    "sim.auxiliaryConsoleClose": {
        "body": "sim.auxiliaryConsoleClose(${0:consoleHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.auxiliaryConsoleClose", 
        "description": "number result = sim.auxiliaryConsoleClose(number consoleHandle)Closes an auxiliary console window. See also sim.auxiliaryConsoleOpen. consoleHandle: the handle of the console window, previously returned by the simAuxiliaryConsoleOpen commandconsoleHandle: the handle of the console window, previously returned by the simAuxiliaryConsoleOpen command -1 if operation was not successful. 0 if the console doesn't exist (anymore), in which case no error is generated. 1 if the console window was closed."
    }, 
    "sim.modelproperty_not_showasinsidemodel": {
        "body": "sim.modelproperty_not_showasinsidemodel", 
        "scope": "source.lua", 
        "prefix": "sim.modelproperty_not_showasinsidemodel", 
        "description": "Constants"
    }, 
    "sim.createTexture": {
        "body": "sim.createTexture()", 
        "scope": "source.lua", 
        "prefix": "sim.createTexture", 
        "description": "number shapeHandle,number textureId,table_2 resolution = sim.createTexture()Creates a planar shape, that will be textured with a new, or imported texture. See also sim.getTextureId, sim.readTexture,  sim.writeTexture and sim.setShapeTexture. fileName: the filename of the texure to import, or an empty string if you wish to create a new texture.options: bit-coded:bit0 set (1) =do not interpolate adjacent color patches.bit1 set (2) =apply the texture in decal-mode.bit2 set (4) =repeat the texture along the U direction.bit3 set (8) =repeat the texture along the V direction.planeSizes: a pointer to 2 values: the dimensions of the planar shape that will be generated. Can be NULL for default dimensions.scalingUV: a pointer to 2 values: the desired scaling of the texture, along the U and V directions. Can be NULL for default scalings.xy_g: a pointer to 3 values: the texture x/y shift, and the texture gamma-rotation. Can be NULL for default shift/rotation values.fixedResolution: 0 to import the shape with its original resolution. Otherwise, specify a power of 2 value which will be the maximum texture resolution (the texture will also be applied a power of 2 resolution).resolution: a pointer to 2 values representing the desired texture resolution when creating a new texture. The same pointer is used to return the effective resolution of the created/imported texture.textureId: a pointer to an integer that will be used to return the new texture ID. If a same texture is already present, the old texture ID will be returned. Can be NULL.reserved: reserved. Set to NULL.fileName: the filename of the texure to import, or an empty string if you wish to create a new texture.options: bit-coded:bit0 set (1) =do not interpolate adjacent color patches.bit1 set (2) =apply the texture in decal-mode.bit2 set (4) =repeat the texture along the U direction.bit3 set (8) =repeat the texture along the V direction.planeSizes: a pointer to 2 values: the dimensions of the planar shape that will be generated. Can be NULL for default dimensions.scalingUV: a pointer to 2 values: the desired scaling of the texture, along the U and V directions. Can be NULL for default scalings.xy_g: a pointer to 3 values: the texture x/y shift, and the texture gamma-rotation. Can be NULL for default shift/rotation values.fixedResolution: 0 to import the shape with its original resolution. Otherwise, specify a power of 2 value which will be the maximum texture resolution (the texture will also be applied a power of 2 resolution).resolution: a pointer to 2 values representing the desired texture resolution when creating a new texture. The same pointer is used to return the effective resolution of the created/imported texture.textureId: a pointer to an integer that will be used to return the new texture ID. If a same texture is already present, the old texture ID will be returned. Can be NULL.reserved: reserved. Set to NULL.fileName: the filename of the texure to import, or an empty string if you wish to create a new texture.options: bit-coded:bit0 set (1) =do not interpolate adjacent color patches.bit1 set (2) =apply the texture in decal-mode.bit2 set (4) =repeat the texture along the U direction.bit3 set (8) =repeat the texture along the V direction.planeSizes: a pointer to 2 values: the dimensions of the planar shape that will be generated. Can be NULL for default dimensions.scalingUV: a pointer to 2 values: the desired scaling of the texture, along the U and V directions. Can be NULL for default scalings.xy_g: a pointer to 3 values: the texture x/y shift, and the texture gamma-rotation. Can be NULL for default shift/rotation values.fixedResolution: 0 to import the shape with its original resolution. Otherwise, specify a power of 2 value which will be the maximum texture resolution (the texture will also be applied a power of 2 resolution).resolution: a pointer to 2 values representing the desired texture resolution when creating a new texture. The same pointer is used to return the effective resolution of the created/imported texture.textureId: a pointer to an integer that will be used to return the new texture ID. If a same texture is already present, the old texture ID will be returned. Can be NULL.reserved: reserved. Set to NULL.fileName: the filename of the texure to import, or an empty string if you wish to create a new texture.options: bit-coded:bit0 set (1) =do not interpolate adjacent color patches.bit1 set (2) =apply the texture in decal-mode.bit2 set (4) =repeat the texture along the U direction.bit3 set (8) =repeat the texture along the V direction.planeSizes: a pointer to 2 values: the dimensions of the planar shape that will be generated. Can be NULL for default dimensions.scalingUV: a pointer to 2 values: the desired scaling of the texture, along the U and V directions. Can be NULL for default scalings.xy_g: a pointer to 3 values: the texture x/y shift, and the texture gamma-rotation. Can be NULL for default shift/rotation values.fixedResolution: 0 to import the shape with its original resolution. Otherwise, specify a power of 2 value which will be the maximum texture resolution (the texture will also be applied a power of 2 resolution).resolution: a pointer to 2 values representing the desired texture resolution when creating a new texture. The same pointer is used to return the effective resolution of the created/imported texture.textureId: a pointer to an integer that will be used to return the new texture ID. If a same texture is already present, the old texture ID will be returned. Can be NULL.reserved: reserved. Set to NULL.fileName: the filename of the texure to import, or an empty string if you wish to create a new texture.options: bit-coded:bit0 set (1) =do not interpolate adjacent color patches.bit1 set (2) =apply the texture in decal-mode.bit2 set (4) =repeat the texture along the U direction.bit3 set (8) =repeat the texture along the V direction.planeSizes: a pointer to 2 values: the dimensions of the planar shape that will be generated. Can be NULL for default dimensions.scalingUV: a pointer to 2 values: the desired scaling of the texture, along the U and V directions. Can be NULL for default scalings.xy_g: a pointer to 3 values: the texture x/y shift, and the texture gamma-rotation. Can be NULL for default shift/rotation values.fixedResolution: 0 to import the shape with its original resolution. Otherwise, specify a power of 2 value which will be the maximum texture resolution (the texture will also be applied a power of 2 resolution).resolution: a pointer to 2 values representing the desired texture resolution when creating a new texture. The same pointer is used to return the effective resolution of the created/imported texture.textureId: a pointer to an integer that will be used to return the new texture ID. If a same texture is already present, the old texture ID will be returned. Can be NULL.reserved: reserved. Set to NULL.fileName: the filename of the texure to import, or an empty string if you wish to create a new texture.options: bit-coded:bit0 set (1) =do not interpolate adjacent color patches.bit1 set (2) =apply the texture in decal-mode.bit2 set (4) =repeat the texture along the U direction.bit3 set (8) =repeat the texture along the V direction.planeSizes: a pointer to 2 values: the dimensions of the planar shape that will be generated. Can be NULL for default dimensions.scalingUV: a pointer to 2 values: the desired scaling of the texture, along the U and V directions. Can be NULL for default scalings.xy_g: a pointer to 3 values: the texture x/y shift, and the texture gamma-rotation. Can be NULL for default shift/rotation values.fixedResolution: 0 to import the shape with its original resolution. Otherwise, specify a power of 2 value which will be the maximum texture resolution (the texture will also be applied a power of 2 resolution).resolution: a pointer to 2 values representing the desired texture resolution when creating a new texture. The same pointer is used to return the effective resolution of the created/imported texture.textureId: a pointer to an integer that will be used to return the new texture ID. If a same texture is already present, the old texture ID will be returned. Can be NULL.reserved: reserved. Set to NULL.fileName: the filename of the texure to import, or an empty string if you wish to create a new texture.options: bit-coded:bit0 set (1) =do not interpolate adjacent color patches.bit1 set (2) =apply the texture in decal-mode.bit2 set (4) =repeat the texture along the U direction.bit3 set (8) =repeat the texture along the V direction.planeSizes: a pointer to 2 values: the dimensions of the planar shape that will be generated. Can be NULL for default dimensions.scalingUV: a pointer to 2 values: the desired scaling of the texture, along the U and V directions. Can be NULL for default scalings.xy_g: a pointer to 3 values: the texture x/y shift, and the texture gamma-rotation. Can be NULL for default shift/rotation values.fixedResolution: 0 to import the shape with its original resolution. Otherwise, specify a power of 2 value which will be the maximum texture resolution (the texture will also be applied a power of 2 resolution).resolution: a pointer to 2 values representing the desired texture resolution when creating a new texture. The same pointer is used to return the effective resolution of the created/imported texture.textureId: a pointer to an integer that will be used to return the new texture ID. If a same texture is already present, the old texture ID will be returned. Can be NULL.reserved: reserved. Set to NULL.fileName: the filename of the texure to import, or an empty string if you wish to create a new texture.options: bit-coded:bit0 set (1) =do not interpolate adjacent color patches.bit1 set (2) =apply the texture in decal-mode.bit2 set (4) =repeat the texture along the U direction.bit3 set (8) =repeat the texture along the V direction.planeSizes: a pointer to 2 values: the dimensions of the planar shape that will be generated. Can be NULL for default dimensions.scalingUV: a pointer to 2 values: the desired scaling of the texture, along the U and V directions. Can be NULL for default scalings.xy_g: a pointer to 3 values: the texture x/y shift, and the texture gamma-rotation. Can be NULL for default shift/rotation values.fixedResolution: 0 to import the shape with its original resolution. Otherwise, specify a power of 2 value which will be the maximum texture resolution (the texture will also be applied a power of 2 resolution).resolution: a pointer to 2 values representing the desired texture resolution when creating a new texture. The same pointer is used to return the effective resolution of the created/imported texture.textureId: a pointer to an integer that will be used to return the new texture ID. If a same texture is already present, the old texture ID will be returned. Can be NULL.reserved: reserved. Set to NULL.fileName: the filename of the texure to import, or an empty string if you wish to create a new texture.options: bit-coded:bit0 set (1) =do not interpolate adjacent color patches.bit1 set (2) =apply the texture in decal-mode.bit2 set (4) =repeat the texture along the U direction.bit3 set (8) =repeat the texture along the V direction.planeSizes: a pointer to 2 values: the dimensions of the planar shape that will be generated. Can be NULL for default dimensions.scalingUV: a pointer to 2 values: the desired scaling of the texture, along the U and V directions. Can be NULL for default scalings.xy_g: a pointer to 3 values: the texture x/y shift, and the texture gamma-rotation. Can be NULL for default shift/rotation values.fixedResolution: 0 to import the shape with its original resolution. Otherwise, specify a power of 2 value which will be the maximum texture resolution (the texture will also be applied a power of 2 resolution).resolution: a pointer to 2 values representing the desired texture resolution when creating a new texture. The same pointer is used to return the effective resolution of the created/imported texture.textureId: a pointer to an integer that will be used to return the new texture ID. If a same texture is already present, the old texture ID will be returned. Can be NULL.reserved: reserved. Set to NULL.fileName: the filename of the texure to import, or an empty string if you wish to create a new texture.options: bit-coded:bit0 set (1) =do not interpolate adjacent color patches.bit1 set (2) =apply the texture in decal-mode.bit2 set (4) =repeat the texture along the U direction.bit3 set (8) =repeat the texture along the V direction.planeSizes: a pointer to 2 values: the dimensions of the planar shape that will be generated. Can be NULL for default dimensions.scalingUV: a pointer to 2 values: the desired scaling of the texture, along the U and V directions. Can be NULL for default scalings.xy_g: a pointer to 3 values: the texture x/y shift, and the texture gamma-rotation. Can be NULL for default shift/rotation values.fixedResolution: 0 to import the shape with its original resolution. Otherwise, specify a power of 2 value which will be the maximum texture resolution (the texture will also be applied a power of 2 resolution).resolution: a pointer to 2 values representing the desired texture resolution when creating a new texture. The same pointer is used to return the effective resolution of the created/imported texture.textureId: a pointer to an integer that will be used to return the new texture ID. If a same texture is already present, the old texture ID will be returned. Can be NULL.reserved: reserved. Set to NULL.fileName: the filename of the texure to import, or an empty string if you wish to create a new texture.options: bit-coded:bit0 set (1) =do not interpolate adjacent color patches.bit1 set (2) =apply the texture in decal-mode.bit2 set (4) =repeat the texture along the U direction.bit3 set (8) =repeat the texture along the V direction.planeSizes: a pointer to 2 values: the dimensions of the planar shape that will be generated. Can be NULL for default dimensions.scalingUV: a pointer to 2 values: the desired scaling of the texture, along the U and V directions. Can be NULL for default scalings.xy_g: a pointer to 3 values: the texture x/y shift, and the texture gamma-rotation. Can be NULL for default shift/rotation values.fixedResolution: 0 to import the shape with its original resolution. Otherwise, specify a power of 2 value which will be the maximum texture resolution (the texture will also be applied a power of 2 resolution).resolution: a pointer to 2 values representing the desired texture resolution when creating a new texture. The same pointer is used to return the effective resolution of the created/imported texture.textureId: a pointer to an integer that will be used to return the new texture ID. If a same texture is already present, the old texture ID will be returned. Can be NULL.reserved: reserved. Set to NULL.fileName: the filename of the texure to import, or an empty string if you wish to create a new texture.options: bit-coded:bit0 set (1) =do not interpolate adjacent color patches.bit1 set (2) =apply the texture in decal-mode.bit2 set (4) =repeat the texture along the U direction.bit3 set (8) =repeat the texture along the V direction.planeSizes: a pointer to 2 values: the dimensions of the planar shape that will be generated. Can be NULL for default dimensions.scalingUV: a pointer to 2 values: the desired scaling of the texture, along the U and V directions. Can be NULL for default scalings.xy_g: a pointer to 3 values: the texture x/y shift, and the texture gamma-rotation. Can be NULL for default shift/rotation values.fixedResolution: 0 to import the shape with its original resolution. Otherwise, specify a power of 2 value which will be the maximum texture resolution (the texture will also be applied a power of 2 resolution).resolution: a pointer to 2 values representing the desired texture resolution when creating a new texture. The same pointer is used to return the effective resolution of the created/imported texture.textureId: a pointer to an integer that will be used to return the new texture ID. If a same texture is already present, the old texture ID will be returned. Can be NULL.reserved: reserved. Set to NULL.fileName: the filename of the texure to import, or an empty string if you wish to create a new texture.options: bit-coded:bit0 set (1) =do not interpolate adjacent color patches.bit1 set (2) =apply the texture in decal-mode.bit2 set (4) =repeat the texture along the U direction.bit3 set (8) =repeat the texture along the V direction.planeSizes: a pointer to 2 values: the dimensions of the planar shape that will be generated. Can be NULL for default dimensions.scalingUV: a pointer to 2 values: the desired scaling of the texture, along the U and V directions. Can be NULL for default scalings.xy_g: a pointer to 3 values: the texture x/y shift, and the texture gamma-rotation. Can be NULL for default shift/rotation values.fixedResolution: 0 to import the shape with its original resolution. Otherwise, specify a power of 2 value which will be the maximum texture resolution (the texture will also be applied a power of 2 resolution).resolution: a pointer to 2 values representing the desired texture resolution when creating a new texture. The same pointer is used to return the effective resolution of the created/imported texture.textureId: a pointer to an integer that will be used to return the new texture ID. If a same texture is already present, the old texture ID will be returned. Can be NULL.reserved: reserved. Set to NULL. -1 in case of an error, otherwise the object handle of the created planar shape."
    }, 
    "simOMPL.setVerboseLevel": {
        "body": "simOMPL.setVerboseLevel(${0:taskHandle},${1:verboseLevel})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.setVerboseLevel", 
        "description": "number result = simOMPL.setVerboseLevel(number taskHandle,number verboseLevel)"
    }, 
    "sim.joint_revolute_subtype": {
        "body": "sim.joint_revolute_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.joint_revolute_subtype", 
        "description": "Constants"
    }, 
    "simROS.call": {
        "body": "simROS.call(${0:serviceClientHandle},${1:request})", 
        "scope": "source.lua", 
        "prefix": "simROS.call", 
        "description": "table result = simROS.call(number serviceClientHandle,table request)"
    }, 
    "sim.getIkGroupHandle": {
        "body": "sim.getIkGroupHandle(${0:ikGroupName})", 
        "scope": "source.lua", 
        "prefix": "sim.getIkGroupHandle", 
        "description": "number ikGroupHandle = sim.getIkGroupHandle(string ikGroupName)Retrieves the handle of an IK group. The operation of this function depends on the current name suffix settings (see sim.getNameSuffix, sim.setNameSuffix, and the section on accessing general-type objects). See also sim.isHandleValid. ikGroupName: name of an IK groupikGroupName: name of an IK group Handle of the IK group or -1 if operation was not successful"
    }, 
    "sim.checkCollision": {
        "body": "sim.checkCollision(${0:entity1Handle},${1:entity2Handle})", 
        "scope": "source.lua", 
        "prefix": "sim.checkCollision", 
        "description": "number result = sim.checkCollision(number entity1Handle,number entity2Handle)Checks whether two entities are colliding. Detection is silent (no visual feedback) compared to sim.handleCollision. Also, the collidable flags of the entities are overridden if the entities are objects. See also sim.readCollision and sim.checkCollisionEx. entity1Handle: handle of entity 1 (can be an object handle or a collection handle)entity2Handle: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other collidable objectsentity1Handle: handle of entity 1 (can be an object handle or a collection handle)entity2Handle: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other collidable objectsentity1Handle: handle of entity 1 (can be an object handle or a collection handle)entity2Handle: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other collidable objects -1 in case of an error, 0 or 1 to indicate a collision state"
    }, 
    "sim.rmlMoveToPosition": {
        "body": "sim.rmlMoveToPosition(${0:objectHandle},${1:relativeToObjectHandle},${2:flags},${3:currentVel},${4:currentAccel},${5:maxVel},${6:maxAccel},${7:maxJerk},${8:targetPosition},${9:targetQuaternion},${10:targetVel})", 
        "scope": "source.lua", 
        "prefix": "sim.rmlMoveToPosition", 
        "description": "number result,table_3 newPos,table_4 newQuaternion,table_4 newVel,table_4 newAccel,number timeLeft = sim.rmlMoveToPosition(number objectHandle,number relativeToObjectHandle,number flags,table_4 currentVel,table_4 currentAccel,table_4 maxVel,table_4 maxAccel,table_4 maxJerk,table_3 targetPosition,table_4 targetQuaternion,table_4 targetVel)"
    }, 
    "sim.vortex_joint_upperlimitmaxforce": {
        "body": "sim.vortex_joint_upperlimitmaxforce", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_upperlimitmaxforce", 
        "description": "Constants"
    }, 
    "bit32.band": {
        "body": "bit32.band(${0:...})", 
        "scope": "source.lua", 
        "prefix": "bit32.band", 
        "description": "5.2\n\nbit32.band (...)"
    }, 
    "simROS.imageTransportShutdownSubscriber": {
        "body": "simROS.imageTransportShutdownSubscriber(${0:subscriberHandle})", 
        "scope": "source.lua", 
        "prefix": "simROS.imageTransportShutdownSubscriber", 
        "description": "simROS.imageTransportShutdownSubscriber(number subscriberHandle)"
    }, 
    "sim.vortex_body_secangularaxisfriction": {
        "body": "sim.vortex_body_secangularaxisfriction", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_secangularaxisfriction", 
        "description": "Constants"
    }, 
    "sim.serialCheck": {
        "body": "sim.serialCheck(${0:portHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.serialCheck", 
        "description": "number byteCount = sim.serialCheck(number portHandle)Reads how many bytes are waiting to be read on a serial port (RS-232). See also sim.serialRead.  portHandle: the handle returned by the simSerialOpen functionportHandle: the handle returned by the simSerialOpen function -1 if operation was not successful, otherwise the number of bytes that are waiting to be read"
    }, 
    "simx.pauseCommunication": {
        "body": "simx.pauseCommunication(${0:clientId})", 
        "scope": "source.lua", 
        "prefix": "simx.pauseCommunication", 
        "description": "number result= simx.pauseCommunication(number clientId)Allows to temporarily halt the communication thread from sending data. This can be useful if you need to send several values to V-REP that should be received and evaluated at the same time. This is a remote API helper function. clientID: the client ID. refer to simx.start.pause: whether the communication thread should pause or run normally. result: 0 in case of operation success."
    }, 
    "simRRS1.SET_OVERRIDE_ACCELERATION": {
        "body": "simRRS1.SET_OVERRIDE_ACCELERATION(${0:rcsHandle},${1:correctionValue},${2:accelType})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_OVERRIDE_ACCELERATION", 
        "description": "int status= simRRS1.SET_OVERRIDE_ACCELERATION(bitstring2 rcsHandle,real correctionValue,int accelType)"
    }, 
    "simUI.curve_scatter_shape.plus_circle": {
        "body": "simUI.curve_scatter_shape.plus_circle", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_scatter_shape.plus_circle", 
        "description": "Constants"
    }, 
    "sim.dummy_linktype_dynamics_force_constraint": {
        "body": "sim.dummy_linktype_dynamics_force_constraint", 
        "scope": "source.lua", 
        "prefix": "sim.dummy_linktype_dynamics_force_constraint", 
        "description": "Constants"
    }, 
    "sim.vortex_body_autosleeplinearaccelthreshold": {
        "body": "sim.vortex_body_autosleeplinearaccelthreshold", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_autosleeplinearaccelthreshold", 
        "description": "Constants"
    }, 
    "simx.opmode_oneshot_split": {
        "body": "simx.opmode_oneshot_split", 
        "scope": "source.lua", 
        "prefix": "simx.opmode_oneshot_split", 
        "description": "Constants"
    }, 
    "sim.objfloatparam_modelbbox_max_y": {
        "body": "sim.objfloatparam_modelbbox_max_y", 
        "scope": "source.lua", 
        "prefix": "sim.objfloatparam_modelbbox_max_y", 
        "description": "Constants"
    }, 
    "string.byte": {
        "body": "string.byte( ${1:s}${2:[, i]}${3:[, j]} )", 
        "scope": "source.lua", 
        "prefix": "string.byte", 
        "description": "5.1,5.2,5.3\n\nstring.byte"
    }, 
    "debug.getlocal": {
        "body": "debug.getlocal( ${1:[thread],}${2:f}${3:[, local]} )", 
        "scope": "source.lua", 
        "prefix": "debug.getlocal", 
        "description": "5.1,5.2,5.3\n\ndebug.getlocal ([thread,] f, local)"
    }, 
    "sim.objfloatparam_modelbbox_max_z": {
        "body": "sim.objfloatparam_modelbbox_max_z", 
        "scope": "source.lua", 
        "prefix": "sim.objfloatparam_modelbbox_max_z", 
        "description": "Constants"
    }, 
    "sim.resetDistance": {
        "body": "sim.resetDistance(${0:distanceObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.resetDistance", 
        "description": "number result = sim.resetDistance(number distanceObjectHandle)Clears the distance state, the distance segment, etc. for a registered distance object. See also sim.handleDistance.  distanceObjectHandle: handle of the distance object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all registered distance objects, while sim_handle_all_except_explicit will only reset those that are not marked as explicit handling)distanceObjectHandle: handle of the distance object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all registered distance objects, while sim_handle_all_except_explicit will only reset those that are not marked as explicit handling) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "os.remove": {
        "body": "os.remove(${0:...})", 
        "scope": "source.lua", 
        "prefix": "os.remove", 
        "description": "5.1,5.2,5.3\n\nos.remove (filename)"
    }, 
    "simOMPL.isStateValid": {
        "body": "simOMPL.isStateValid(${0:taskHandle},${1:state})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.isStateValid", 
        "description": "number valid = simOMPL.isStateValid(number taskHandle,table state)"
    }, 
    "sim.bullet_body_angulardamping": {
        "body": "sim.bullet_body_angulardamping", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_body_angulardamping", 
        "description": "Constants"
    }, 
    "sim.getObjectInt32Parameter": {
        "body": "sim.getObjectInt32Parameter(${0:objectHandle},${1:parameterID})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectInt32Parameter", 
        "description": "number result,number parameter = sim.getObjectInt32Parameter(number objectHandle,number parameterID)Retrieves an int32 parameter of a scene object or calculation object. See also sim.setObjectInt32Parameter, sim.getObjectFloatParameter and sim.getObjectStringParameter objectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: retrieved parameterobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: retrieved parameterobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: retrieved parameterobjectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersparameter: retrieved parameter -1 in case of an error, 0 if the parameter could not be retrieved (e.g. because the parameterID doesn't exist, or because the specified object doesn't correspond to the correct type), or 1 if the operation was successful"
    }, 
    "sim.getObjectSelection": {
        "body": "sim.getObjectSelection()", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectSelection", 
        "description": "table selectedObjectHandles = sim.getObjectSelection()Retrieves all selected object's handles. See also simGetObjectSelectionSize, sim.addObjectToSelection and sim.removeObjectFromSelection. objectHandles: pointer to object handles. Make sure to have at least simGetObjectSelectionSize simInts availableobjectHandles: pointer to object handles. Make sure to have at least simGetObjectSelectionSize simInts available size of the selection (>=0) if operation was successful, -1 otherwise"
    }, 
    "math.sinh": {
        "body": "math.sinh(${0:...})", 
        "scope": "source.lua", 
        "prefix": "math.sinh", 
        "description": "5.1,5.2\n\nmath.sinh (x)"
    }, 
    "sim.getScriptAttribute": {
        "body": "sim.getScriptAttribute(${0:scriptHandle},${1:attributeID})", 
        "scope": "source.lua", 
        "prefix": "sim.getScriptAttribute", 
        "description": "number/boolean attribute = sim.getScriptAttribute(number scriptHandle,number attributeID)Reads various script attributes or properties. See also sim.setScriptAttribute. scriptHandle: handle of a scriptattributeID: the script attributeIDfloatVal: pointer to a floating point value, receiving the floating point attribute (if applicable)intOrBoolVal: pointer to an integer value, receiving the integer or Boolean attribute (if applicable)scriptHandle: handle of a scriptattributeID: the script attributeIDfloatVal: pointer to a floating point value, receiving the floating point attribute (if applicable)intOrBoolVal: pointer to an integer value, receiving the integer or Boolean attribute (if applicable)scriptHandle: handle of a scriptattributeID: the script attributeIDfloatVal: pointer to a floating point value, receiving the floating point attribute (if applicable)intOrBoolVal: pointer to an integer value, receiving the integer or Boolean attribute (if applicable)scriptHandle: handle of a scriptattributeID: the script attributeIDfloatVal: pointer to a floating point value, receiving the floating point attribute (if applicable)intOrBoolVal: pointer to an integer value, receiving the integer or Boolean attribute (if applicable) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.api_error_report": {
        "body": "sim.api_error_report", 
        "scope": "source.lua", 
        "prefix": "sim.api_error_report", 
        "description": "Constants"
    }, 
    "sim.vortex_body_linearvelocitydamping": {
        "body": "sim.vortex_body_linearvelocitydamping", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_linearvelocitydamping", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_ik_weight": {
        "body": "sim.jointfloatparam_ik_weight", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_ik_weight", 
        "description": "Constants"
    }, 
    "sim.drawing_painttag": {
        "body": "sim.drawing_painttag", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_painttag", 
        "description": "Constants"
    }, 
    "sim.getJointPosition": {
        "body": "sim.getJointPosition(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getJointPosition", 
        "description": "number position = sim.getJointPosition(number objectHandle)Retrieves the intrinsic position of a joint. This function cannot be used with spherical joints (use sim.getJointMatrix instead). See also sim.setJointPosition. objectHandle: handle of the jointposition: intrinsic position of the joint. This is a one-dimensional value: if the joint is revolute, the rotation angle is returned, if the joint is prismatic, the translation amount is returned, etc.objectHandle: handle of the jointposition: intrinsic position of the joint. This is a one-dimensional value: if the joint is revolute, the rotation angle is returned, if the joint is prismatic, the translation amount is returned, etc.objectHandle: handle of the jointposition: intrinsic position of the joint. This is a one-dimensional value: if the joint is revolute, the rotation angle is returned, if the joint is prismatic, the translation amount is returned, etc. -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.setPathTargetNominalVelocity": {
        "body": "sim.setPathTargetNominalVelocity(${0:objectHandle},${1:targetVelocity})", 
        "scope": "source.lua", 
        "prefix": "sim.setPathTargetNominalVelocity", 
        "description": "number result = sim.setPathTargetNominalVelocity(number objectHandle,number targetVelocity)"
    }, 
    "simROS.imageTransportSubscribe": {
        "body": "simROS.imageTransportSubscribe(${0:topicName},${1:topicCallback},${2:queueSize=1})", 
        "scope": "source.lua", 
        "prefix": "simROS.imageTransportSubscribe", 
        "description": "number subscriberHandle = simROS.imageTransportSubscribe(string topicName,string topicCallback,number queueSize=1)"
    }, 
    "sim.objfloatparam_modelbbox_min_z": {
        "body": "sim.objfloatparam_modelbbox_min_z", 
        "scope": "source.lua", 
        "prefix": "sim.objfloatparam_modelbbox_min_z", 
        "description": "Constants"
    }, 
    "sim.objfloatparam_modelbbox_min_y": {
        "body": "sim.objfloatparam_modelbbox_min_y", 
        "scope": "source.lua", 
        "prefix": "sim.objfloatparam_modelbbox_min_y", 
        "description": "Constants"
    }, 
    "sim.objfloatparam_modelbbox_min_x": {
        "body": "sim.objfloatparam_modelbbox_min_x", 
        "scope": "source.lua", 
        "prefix": "sim.objfloatparam_modelbbox_min_x", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_lowerlimitdamping": {
        "body": "sim.vortex_joint_lowerlimitdamping", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_lowerlimitdamping", 
        "description": "Constants"
    }, 
    "simURDF.importFile": {
        "body": "simURDF.importFile(${0:fileAndPath},${1:hideCollisionLinks},${2:hideJoints},${3:convexDecomposeNonConvexCollidables},${4:createVisualIfNone},${5:showConvexDecompositionDlg},${6:centerAboveGround},${7:makeModel},${8:noSelfCollision},${9:positionCtrl})", 
        "scope": "source.lua", 
        "prefix": "simURDF.importFile", 
        "description": "string robot_name= simURDF.importFile(string fileAndPath,bool hideCollisionLinks,bool hideJoints,bool convexDecomposeNonConvexCollidables,bool createVisualIfNone,bool showConvexDecompositionDlg,bool centerAboveGround,bool makeModel,bool noSelfCollision,bool positionCtrl)"
    }, 
    "simUI.getCurveData": {
        "body": "simUI.getCurveData(${0:handle},${1:id},${2:name})", 
        "scope": "source.lua", 
        "prefix": "simUI.getCurveData", 
        "description": "table t,table x,table y = simUI.getCurveData(number handle,number id,string name)"
    }, 
    "simx.readCollision": {
        "body": "simx.readCollision(${0:clientId},${1:collisionObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.readCollision", 
        "description": "number returnCode,boolean collisionState= simx.readCollision(number clientId,number collisionObjectHandle)Reads the collision state of a registered collision object. This function doesn't perform collision detection, it merely reads the result from a previous call to sim.handleCollision (sim.handleCollision is called in the default main script). See also simx.getObjectGroupData. clientID: the client ID. refer to simx.start.collisionObjectHandle: handle of the collision objectoperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls) returnCode: a remote API function return codecollisionState: the collision state"
    }, 
    "simUI.setTreeSelection": {
        "body": "simUI.setTreeSelection(${0:handle},${1:id},${2:item_id},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setTreeSelection", 
        "description": "simUI.setTreeSelection(number handle,number id,number item_id,bool suppressEvents=true)"
    }, 
    "simUI.growPlotXRange": {
        "body": "simUI.growPlotXRange(${0:handle},${1:id},${2:xmin},${3:xmax})", 
        "scope": "source.lua", 
        "prefix": "simUI.growPlotXRange", 
        "description": "simUI.growPlotXRange(number handle,number id,number xmin,number xmax)"
    }, 
    "sim.ode_global_erp": {
        "body": "sim.ode_global_erp", 
        "scope": "source.lua", 
        "prefix": "sim.ode_global_erp", 
        "description": "Constants"
    }, 
    "simx.closeScene": {
        "body": "simx.closeScene(${0:clientId})", 
        "scope": "source.lua", 
        "prefix": "simx.closeScene", 
        "description": "number returnCode= simx.closeScene(number clientId)Closes current scene, and switches to another open scene. If there is no other open scene, a new scene is then created. Should only be called when simulation is not running and is only executed by continuous remote API server services. See also simx.loadScene. clientID: the client ID. refer to simx.start.operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return code"
    }, 
    "sim.volume_pyramid": {
        "body": "sim.volume_pyramid", 
        "scope": "source.lua", 
        "prefix": "sim.volume_pyramid", 
        "description": "Constants"
    }, 
    "simUI.removeComboboxItem": {
        "body": "simUI.removeComboboxItem(${0:handle},${1:id},${2:index},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.removeComboboxItem", 
        "description": "simUI.removeComboboxItem(number handle,number id,number index,bool suppressEvents=true)"
    }, 
    "sim.filedlg_type_load_multiple": {
        "body": "sim.filedlg_type_load_multiple", 
        "scope": "source.lua", 
        "prefix": "sim.filedlg_type_load_multiple", 
        "description": "Constants"
    }, 
    "file:lines": {
        "body": "file:lines(${0:...})", 
        "scope": "source.lua", 
        "prefix": "file:lines", 
        "description": "5.1,5.2,5.3\n\nfile:lines ()"
    }, 
    "simMTB.setInput": {
        "body": "simMTB.setInput(${0:mtbServerHandle})", 
        "scope": "source.lua", 
        "prefix": "simMTB.setInput", 
        "description": "boolean result= simMTB.setInput(number mtbServerHandle)"
    }, 
    "sim.getSystemTimeInMs": {
        "body": "sim.getSystemTimeInMs(${0:previousTime})", 
        "scope": "source.lua", 
        "prefix": "sim.getSystemTimeInMs", 
        "description": "number systemTimeOrTimeDiff = sim.getSystemTimeInMs(number previousTime)Retrieves a time in milliseconds. previousTime: value that indicates how the command should operate:>=0: the function returns a time difference with previousTime. PreviousTime must have been previously retrieved with the -1 argument below.-1: the function returns a time relative to an arbitrary time. Use this to measure time differences within V-REP-2: the function returns a time as follows:// On Windows:returnedValue=TimeGetTime();// On MacOS / Linux:struct timeval now;gettimeofday(&now,NULL);returnValue=now.tv_sec*1000+now.tv_usec/1000;previousTime: value that indicates how the command should operate:>=0: the function returns a time difference with previousTime. PreviousTime must have been previously retrieved with the -1 argument below.-1: the function returns a time relative to an arbitrary time. Use this to measure time differences within V-REP-2: the function returns a time as follows:// On Windows:returnedValue=TimeGetTime();// On MacOS / Linux:struct timeval now;gettimeofday(&now,NULL);returnValue=now.tv_sec*1000+now.tv_usec/1000;previousTime: value that indicates how the command should operate:>=0: the function returns a time difference with previousTime. PreviousTime must have been previously retrieved with the -1 argument below.-1: the function returns a time relative to an arbitrary time. Use this to measure time differences within V-REP-2: the function returns a time as follows:// On Windows:returnedValue=TimeGetTime();// On MacOS / Linux:struct timeval now;gettimeofday(&now,NULL);returnValue=now.tv_sec*1000+now.tv_usec/1000;previousTime: value that indicates how the command should operate:>=0: the function returns a time difference with previousTime. PreviousTime must have been previously retrieved with the -1 argument below.-1: the function returns a time relative to an arbitrary time. Use this to measure time differences within V-REP-2: the function returns a time as follows:// On Windows:returnedValue=TimeGetTime();// On MacOS / Linux:struct timeval now;gettimeofday(&now,NULL);returnValue=now.tv_sec*1000+now.tv_usec/1000; a  time in milliseconds as described here above."
    }, 
    "sim.insertObjectIntoOctree": {
        "body": "sim.insertObjectIntoOctree(${0:octreeHandle},${1:objectHandle},${2:options},${3:color=nil},${4:tag=0})", 
        "scope": "source.lua", 
        "prefix": "sim.insertObjectIntoOctree", 
        "description": "number totalVoxelCnt = sim.insertObjectIntoOctree(number octreeHandle,number objectHandle,number options,table color=nil,number tag=0)Inserts an object into an octree, as voxels. Each voxel will store a color and a tag value. See also sim.subtractObjectFromOctree, sim.insertVoxelsIntoOctree and the other octree related functions. octreeHandle: the handle of the octree. See also simGetObjectHandleobjectHandle: the handle of the object to insert. Only potentially collidable objects are supportedoptions: reserved. Set to 0color: a pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be NULL.tag: a uint32 value, which is user-defined.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleobjectHandle: the handle of the object to insert. Only potentially collidable objects are supportedoptions: reserved. Set to 0color: a pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be NULL.tag: a uint32 value, which is user-defined.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleobjectHandle: the handle of the object to insert. Only potentially collidable objects are supportedoptions: reserved. Set to 0color: a pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be NULL.tag: a uint32 value, which is user-defined.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleobjectHandle: the handle of the object to insert. Only potentially collidable objects are supportedoptions: reserved. Set to 0color: a pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be NULL.tag: a uint32 value, which is user-defined.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleobjectHandle: the handle of the object to insert. Only potentially collidable objects are supportedoptions: reserved. Set to 0color: a pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be NULL.tag: a uint32 value, which is user-defined.reserved: reserved for future extensions. Set to NULLoctreeHandle: the handle of the octree. See also simGetObjectHandleobjectHandle: the handle of the object to insert. Only potentially collidable objects are supportedoptions: reserved. Set to 0color: a pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be NULL.tag: a uint32 value, which is user-defined.reserved: reserved for future extensions. Set to NULL -1 if operation was not successful, otherwise the total number of voxels in the octree"
    }, 
    "simUI.curve_style.step_center": {
        "body": "simUI.curve_style.step_center", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_style.step_center", 
        "description": "Constants"
    }, 
    "sim.dynmat_reststackgrasp": {
        "body": "sim.dynmat_reststackgrasp", 
        "scope": "source.lua", 
        "prefix": "sim.dynmat_reststackgrasp", 
        "description": "Constants"
    }, 
    "sim.scriptthreadresume_sensing_last": {
        "body": "sim.scriptthreadresume_sensing_last", 
        "scope": "source.lua", 
        "prefix": "sim.scriptthreadresume_sensing_last", 
        "description": "Constants"
    }, 
    "debug.upvaluejoin": {
        "body": "debug.upvaluejoin( ${1:f1}, ${2:n1}, ${3:f2}, ${4:n2} )", 
        "scope": "source.lua", 
        "prefix": "debug.upvaluejoin", 
        "description": "5.2,5.3\n\ndebug.upvaluejoin (f1, n1, f2, n2)"
    }, 
    "sim.mirrorfloatparam_height": {
        "body": "sim.mirrorfloatparam_height", 
        "scope": "source.lua", 
        "prefix": "sim.mirrorfloatparam_height", 
        "description": "Constants"
    }, 
    "sim.getSimulationTimeStep": {
        "body": "sim.getSimulationTimeStep()", 
        "scope": "source.lua", 
        "prefix": "sim.getSimulationTimeStep", 
        "description": "number timeStep = sim.getSimulationTimeStep()Retrieves the simulation time step (the simulation time (i.e. not real-time) that passes at each main script simulation pass). This value might not be constant for a given simulation. None negative value (-1.0) if operation not successful, otherwise the simulation time step"
    }, 
    "sim.shapefloatparam_texture_a": {
        "body": "sim.shapefloatparam_texture_a", 
        "scope": "source.lua", 
        "prefix": "sim.shapefloatparam_texture_a", 
        "description": "Constants"
    }, 
    "string.reverse": {
        "body": "string.reverse( ${1:s} )", 
        "scope": "source.lua", 
        "prefix": "string.reverse", 
        "description": "5.1,5.2,5.3\n\nstring.reverse"
    }, 
    "require": {
        "body": "require(\"${1:module}\")", 
        "scope": "source.lua", 
        "prefix": "require", 
        "description": "5.1,5.2,5.3\n\nrequire()"
    }, 
    "sim.createIkGroup": {
        "body": "sim.createIkGroup(${0:options},${1:intParams=nil},${2:floatParams=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.createIkGroup", 
        "description": "number ikGroupHandle = sim.createIkGroup(number options,table intParams=nil,table floatParams=nil)Creates an IK group. See also sim.removeIkGroup and sim.createIkElement. options: bit-coded options:bit 0 set (1): the group is inactive.bit 1 set (2): joint limits are taken into account during calculation (i.e. only for redundant kinematics).bit 2 set (4): restore if position not reached.bit 3 set (8): restore if orientation not reached.bit 4 set (16): do not ignore the joint's max. step sizes.bit 5 set (32): the group is explicitely handled.intParams: an optional array of 2 integer parameters (i.e. array can be NULL):intParams[0]: the IK calculation method.intParams[1]: the maximum number of iterations.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the DLS factor.floatParams[1]: the joint limit weight.floatParams[2]: the prismatic joint limit threshold.floatParams[3]: the revolute joint limit threshold.reserved: reserved. Set to NULL.options: bit-coded options:bit 0 set (1): the group is inactive.bit 1 set (2): joint limits are taken into account during calculation (i.e. only for redundant kinematics).bit 2 set (4): restore if position not reached.bit 3 set (8): restore if orientation not reached.bit 4 set (16): do not ignore the joint's max. step sizes.bit 5 set (32): the group is explicitely handled.intParams: an optional array of 2 integer parameters (i.e. array can be NULL):intParams[0]: the IK calculation method.intParams[1]: the maximum number of iterations.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the DLS factor.floatParams[1]: the joint limit weight.floatParams[2]: the prismatic joint limit threshold.floatParams[3]: the revolute joint limit threshold.reserved: reserved. Set to NULL.options: bit-coded options:bit 0 set (1): the group is inactive.bit 1 set (2): joint limits are taken into account during calculation (i.e. only for redundant kinematics).bit 2 set (4): restore if position not reached.bit 3 set (8): restore if orientation not reached.bit 4 set (16): do not ignore the joint's max. step sizes.bit 5 set (32): the group is explicitely handled.intParams: an optional array of 2 integer parameters (i.e. array can be NULL):intParams[0]: the IK calculation method.intParams[1]: the maximum number of iterations.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the DLS factor.floatParams[1]: the joint limit weight.floatParams[2]: the prismatic joint limit threshold.floatParams[3]: the revolute joint limit threshold.reserved: reserved. Set to NULL.options: bit-coded options:bit 0 set (1): the group is inactive.bit 1 set (2): joint limits are taken into account during calculation (i.e. only for redundant kinematics).bit 2 set (4): restore if position not reached.bit 3 set (8): restore if orientation not reached.bit 4 set (16): do not ignore the joint's max. step sizes.bit 5 set (32): the group is explicitely handled.intParams: an optional array of 2 integer parameters (i.e. array can be NULL):intParams[0]: the IK calculation method.intParams[1]: the maximum number of iterations.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the DLS factor.floatParams[1]: the joint limit weight.floatParams[2]: the prismatic joint limit threshold.floatParams[3]: the revolute joint limit threshold.reserved: reserved. Set to NULL.options: bit-coded options:bit 0 set (1): the group is inactive.bit 1 set (2): joint limits are taken into account during calculation (i.e. only for redundant kinematics).bit 2 set (4): restore if position not reached.bit 3 set (8): restore if orientation not reached.bit 4 set (16): do not ignore the joint's max. step sizes.bit 5 set (32): the group is explicitely handled.intParams: an optional array of 2 integer parameters (i.e. array can be NULL):intParams[0]: the IK calculation method.intParams[1]: the maximum number of iterations.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the DLS factor.floatParams[1]: the joint limit weight.floatParams[2]: the prismatic joint limit threshold.floatParams[3]: the revolute joint limit threshold.reserved: reserved. Set to NULL.options: bit-coded options:bit 0 set (1): the group is inactive.bit 1 set (2): joint limits are taken into account during calculation (i.e. only for redundant kinematics).bit 2 set (4): restore if position not reached.bit 3 set (8): restore if orientation not reached.bit 4 set (16): do not ignore the joint's max. step sizes.bit 5 set (32): the group is explicitely handled.intParams: an optional array of 2 integer parameters (i.e. array can be NULL):intParams[0]: the IK calculation method.intParams[1]: the maximum number of iterations.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the DLS factor.floatParams[1]: the joint limit weight.floatParams[2]: the prismatic joint limit threshold.floatParams[3]: the revolute joint limit threshold.reserved: reserved. Set to NULL.options: bit-coded options:bit 0 set (1): the group is inactive.bit 1 set (2): joint limits are taken into account during calculation (i.e. only for redundant kinematics).bit 2 set (4): restore if position not reached.bit 3 set (8): restore if orientation not reached.bit 4 set (16): do not ignore the joint's max. step sizes.bit 5 set (32): the group is explicitely handled.intParams: an optional array of 2 integer parameters (i.e. array can be NULL):intParams[0]: the IK calculation method.intParams[1]: the maximum number of iterations.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the DLS factor.floatParams[1]: the joint limit weight.floatParams[2]: the prismatic joint limit threshold.floatParams[3]: the revolute joint limit threshold.reserved: reserved. Set to NULL.options: bit-coded options:bit 0 set (1): the group is inactive.bit 1 set (2): joint limits are taken into account during calculation (i.e. only for redundant kinematics).bit 2 set (4): restore if position not reached.bit 3 set (8): restore if orientation not reached.bit 4 set (16): do not ignore the joint's max. step sizes.bit 5 set (32): the group is explicitely handled.intParams: an optional array of 2 integer parameters (i.e. array can be NULL):intParams[0]: the IK calculation method.intParams[1]: the maximum number of iterations.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the DLS factor.floatParams[1]: the joint limit weight.floatParams[2]: the prismatic joint limit threshold.floatParams[3]: the revolute joint limit threshold.reserved: reserved. Set to NULL.options: bit-coded options:bit 0 set (1): the group is inactive.bit 1 set (2): joint limits are taken into account during calculation (i.e. only for redundant kinematics).bit 2 set (4): restore if position not reached.bit 3 set (8): restore if orientation not reached.bit 4 set (16): do not ignore the joint's max. step sizes.bit 5 set (32): the group is explicitely handled.intParams: an optional array of 2 integer parameters (i.e. array can be NULL):intParams[0]: the IK calculation method.intParams[1]: the maximum number of iterations.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the DLS factor.floatParams[1]: the joint limit weight.floatParams[2]: the prismatic joint limit threshold.floatParams[3]: the revolute joint limit threshold.reserved: reserved. Set to NULL.options: bit-coded options:bit 0 set (1): the group is inactive.bit 1 set (2): joint limits are taken into account during calculation (i.e. only for redundant kinematics).bit 2 set (4): restore if position not reached.bit 3 set (8): restore if orientation not reached.bit 4 set (16): do not ignore the joint's max. step sizes.bit 5 set (32): the group is explicitely handled.intParams: an optional array of 2 integer parameters (i.e. array can be NULL):intParams[0]: the IK calculation method.intParams[1]: the maximum number of iterations.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the DLS factor.floatParams[1]: the joint limit weight.floatParams[2]: the prismatic joint limit threshold.floatParams[3]: the revolute joint limit threshold.reserved: reserved. Set to NULL.options: bit-coded options:bit 0 set (1): the group is inactive.bit 1 set (2): joint limits are taken into account during calculation (i.e. only for redundant kinematics).bit 2 set (4): restore if position not reached.bit 3 set (8): restore if orientation not reached.bit 4 set (16): do not ignore the joint's max. step sizes.bit 5 set (32): the group is explicitely handled.intParams: an optional array of 2 integer parameters (i.e. array can be NULL):intParams[0]: the IK calculation method.intParams[1]: the maximum number of iterations.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the DLS factor.floatParams[1]: the joint limit weight.floatParams[2]: the prismatic joint limit threshold.floatParams[3]: the revolute joint limit threshold.reserved: reserved. Set to NULL.options: bit-coded options:bit 0 set (1): the group is inactive.bit 1 set (2): joint limits are taken into account during calculation (i.e. only for redundant kinematics).bit 2 set (4): restore if position not reached.bit 3 set (8): restore if orientation not reached.bit 4 set (16): do not ignore the joint's max. step sizes.bit 5 set (32): the group is explicitely handled.intParams: an optional array of 2 integer parameters (i.e. array can be NULL):intParams[0]: the IK calculation method.intParams[1]: the maximum number of iterations.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the DLS factor.floatParams[1]: the joint limit weight.floatParams[2]: the prismatic joint limit threshold.floatParams[3]: the revolute joint limit threshold.reserved: reserved. Set to NULL.options: bit-coded options:bit 0 set (1): the group is inactive.bit 1 set (2): joint limits are taken into account during calculation (i.e. only for redundant kinematics).bit 2 set (4): restore if position not reached.bit 3 set (8): restore if orientation not reached.bit 4 set (16): do not ignore the joint's max. step sizes.bit 5 set (32): the group is explicitely handled.intParams: an optional array of 2 integer parameters (i.e. array can be NULL):intParams[0]: the IK calculation method.intParams[1]: the maximum number of iterations.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the DLS factor.floatParams[1]: the joint limit weight.floatParams[2]: the prismatic joint limit threshold.floatParams[3]: the revolute joint limit threshold.reserved: reserved. Set to NULL.options: bit-coded options:bit 0 set (1): the group is inactive.bit 1 set (2): joint limits are taken into account during calculation (i.e. only for redundant kinematics).bit 2 set (4): restore if position not reached.bit 3 set (8): restore if orientation not reached.bit 4 set (16): do not ignore the joint's max. step sizes.bit 5 set (32): the group is explicitely handled.intParams: an optional array of 2 integer parameters (i.e. array can be NULL):intParams[0]: the IK calculation method.intParams[1]: the maximum number of iterations.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the DLS factor.floatParams[1]: the joint limit weight.floatParams[2]: the prismatic joint limit threshold.floatParams[3]: the revolute joint limit threshold.reserved: reserved. Set to NULL.options: bit-coded options:bit 0 set (1): the group is inactive.bit 1 set (2): joint limits are taken into account during calculation (i.e. only for redundant kinematics).bit 2 set (4): restore if position not reached.bit 3 set (8): restore if orientation not reached.bit 4 set (16): do not ignore the joint's max. step sizes.bit 5 set (32): the group is explicitely handled.intParams: an optional array of 2 integer parameters (i.e. array can be NULL):intParams[0]: the IK calculation method.intParams[1]: the maximum number of iterations.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the DLS factor.floatParams[1]: the joint limit weight.floatParams[2]: the prismatic joint limit threshold.floatParams[3]: the revolute joint limit threshold.reserved: reserved. Set to NULL.options: bit-coded options:bit 0 set (1): the group is inactive.bit 1 set (2): joint limits are taken into account during calculation (i.e. only for redundant kinematics).bit 2 set (4): restore if position not reached.bit 3 set (8): restore if orientation not reached.bit 4 set (16): do not ignore the joint's max. step sizes.bit 5 set (32): the group is explicitely handled.intParams: an optional array of 2 integer parameters (i.e. array can be NULL):intParams[0]: the IK calculation method.intParams[1]: the maximum number of iterations.floatParams: an optional array of 4 float parameters (i.e. array can be NULL):floatParams[0]: the DLS factor.floatParams[1]: the joint limit weight.floatParams[2]: the prismatic joint limit threshold.floatParams[3]: the revolute joint limit threshold.reserved: reserved. Set to NULL. -1 if operation was not successful, otherwise the IK group handle."
    }, 
    "sim.shapefloatparam_texture_g": {
        "body": "sim.shapefloatparam_texture_g", 
        "scope": "source.lua", 
        "prefix": "sim.shapefloatparam_texture_g", 
        "description": "Constants"
    }, 
    "sim.stringparam_remoteapi_temp_file_dir": {
        "body": "sim.stringparam_remoteapi_temp_file_dir", 
        "scope": "source.lua", 
        "prefix": "sim.stringparam_remoteapi_temp_file_dir", 
        "description": "Constants"
    }, 
    "sim.shapefloatparam_texture_y": {
        "body": "sim.shapefloatparam_texture_y", 
        "scope": "source.lua", 
        "prefix": "sim.shapefloatparam_texture_y", 
        "description": "Constants"
    }, 
    "sim.shapefloatparam_texture_x": {
        "body": "sim.shapefloatparam_texture_x", 
        "scope": "source.lua", 
        "prefix": "sim.shapefloatparam_texture_x", 
        "description": "Constants"
    }, 
    "simUI.setLabelText": {
        "body": "simUI.setLabelText(${0:handle},${1:id},${2:text},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setLabelText", 
        "description": "simUI.setLabelText(number handle,number id,string text,bool suppressEvents=true)"
    }, 
    "sim.drawing_12percenttransparency": {
        "body": "sim.drawing_12percenttransparency", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_12percenttransparency", 
        "description": "Constants"
    }, 
    "sim.customizationscriptcall_simulationpausefirst": {
        "body": "sim.customizationscriptcall_simulationpausefirst", 
        "scope": "source.lua", 
        "prefix": "sim.customizationscriptcall_simulationpausefirst", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_a2frictioncoeff": {
        "body": "sim.vortex_joint_a2frictioncoeff", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a2frictioncoeff", 
        "description": "Constants"
    }, 
    "simUI.getComboboxItemText": {
        "body": "simUI.getComboboxItemText(${0:handle},${1:id},${2:index})", 
        "scope": "source.lua", 
        "prefix": "simUI.getComboboxItemText", 
        "description": "string text = simUI.getComboboxItemText(number handle,number id,number index)"
    }, 
    "sim.vortex_bodyfrictionmodel_none": {
        "body": "sim.vortex_bodyfrictionmodel_none", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_bodyfrictionmodel_none", 
        "description": "Constants"
    }, 
    "sim.pathproperty_keep_x_up": {
        "body": "sim.pathproperty_keep_x_up", 
        "scope": "source.lua", 
        "prefix": "sim.pathproperty_keep_x_up", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_a1frictionloss": {
        "body": "sim.vortex_joint_a1frictionloss", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a1frictionloss", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_uniformimage": {
        "body": "sim.filtercomponent_uniformimage", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_uniformimage", 
        "description": "Constants"
    }, 
    "sim.bullet_global_constraintsolvertype": {
        "body": "sim.bullet_global_constraintsolvertype", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_global_constraintsolvertype", 
        "description": "Constants"
    }, 
    "simMTB.connectInput": {
        "body": "simMTB.connectInput(${0:inputMtbServerHandle},${1:inputBitNumber},${2:outputMtbServerHandle},${3:outputBitNumber})", 
        "scope": "source.lua", 
        "prefix": "simMTB.connectInput", 
        "description": "boolean result= simMTB.connectInput(number inputMtbServerHandle,number inputBitNumber,number outputMtbServerHandle,number outputBitNumber)"
    }, 
    "sim.rotateAroundAxis": {
        "body": "sim.rotateAroundAxis(${0:matrixIn},${1:axis},${2:axisPos},${3:angle})", 
        "scope": "source.lua", 
        "prefix": "sim.rotateAroundAxis", 
        "description": "table_12 matrixOut = sim.rotateAroundAxis(table_12 matrixIn,table_3 axis,table_3 axisPos,number angle)Rotates a transformation matrix around a random axis in space. This function, when used in combination with sim.getRotationAxis, can be used to build interpolations between transformation matrices. See also sim.getObjectMatrix, sim.setObjectMatrix and the other matrix/transformation functions. matrixIn: the transformation matrix to rotateaxis: the axis vector in absolute coordinates to rotate aroundaxisPos: the position of the rotation axis in absolute coordinatesangle: the amount of rotation to performmatrixOut: the returned transformed (rotated) matrixmatrixIn: the transformation matrix to rotateaxis: the axis vector in absolute coordinates to rotate aroundaxisPos: the position of the rotation axis in absolute coordinatesangle: the amount of rotation to performmatrixOut: the returned transformed (rotated) matrixmatrixIn: the transformation matrix to rotateaxis: the axis vector in absolute coordinates to rotate aroundaxisPos: the position of the rotation axis in absolute coordinatesangle: the amount of rotation to performmatrixOut: the returned transformed (rotated) matrixmatrixIn: the transformation matrix to rotateaxis: the axis vector in absolute coordinates to rotate aroundaxisPos: the position of the rotation axis in absolute coordinatesangle: the amount of rotation to performmatrixOut: the returned transformed (rotated) matrixmatrixIn: the transformation matrix to rotateaxis: the axis vector in absolute coordinates to rotate aroundaxisPos: the position of the rotation axis in absolute coordinatesangle: the amount of rotation to performmatrixOut: the returned transformed (rotated) matrixmatrixIn: the transformation matrix to rotateaxis: the axis vector in absolute coordinates to rotate aroundaxisPos: the position of the rotation axis in absolute coordinatesangle: the amount of rotation to performmatrixOut: the returned transformed (rotated) matrix -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.jointmode_dependent": {
        "body": "sim.jointmode_dependent", 
        "scope": "source.lua", 
        "prefix": "sim.jointmode_dependent", 
        "description": "Constants"
    }, 
    "sim.visionintparam_disabled_light_components": {
        "body": "sim.visionintparam_disabled_light_components", 
        "scope": "source.lua", 
        "prefix": "sim.visionintparam_disabled_light_components", 
        "description": "Constants"
    }, 
    "sim.stringparam_app_arg1": {
        "body": "sim.stringparam_app_arg1", 
        "scope": "source.lua", 
        "prefix": "sim.stringparam_app_arg1", 
        "description": "Constants"
    }, 
    "simx.setModelProperty": {
        "body": "simx.setModelProperty(${0:clientId},${1:objectHandle},${2:modelProperty})", 
        "scope": "source.lua", 
        "prefix": "simx.setModelProperty", 
        "description": "number returnCode= simx.setModelProperty(number clientId,number objectHandle,number modelProperty)Sets the properties of a model. See also simx.getModelProperty. clientID: the client ID. refer to simx.start.objectHandle: handle of the objectprop: a model property valueoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "sim.copyPasteObjects": {
        "body": "sim.copyPasteObjects(${0:objectHandles},${1:options})", 
        "scope": "source.lua", 
        "prefix": "sim.copyPasteObjects", 
        "description": "table copiedObjectHandles = sim.copyPasteObjects(table objectHandles,number options)Copies and pastes objects, together with all their associated calculation objects and associated scripts. See also sim.removeObject and sim.removeModel. objectHandles: array containing the handles of the objects to copy and paste. The same array will receive the copied object handles.objectCount: the number of handles contained in the objectHandles array.options: bit-coded. If bit0 is set (i.e. 1), then whole models will be copied. In that case, all specified objects should be flagged as model base..objectHandles: array containing the handles of the objects to copy and paste. The same array will receive the copied object handles.objectCount: the number of handles contained in the objectHandles array.options: bit-coded. If bit0 is set (i.e. 1), then whole models will be copied. In that case, all specified objects should be flagged as model base..objectHandles: array containing the handles of the objects to copy and paste. The same array will receive the copied object handles.objectCount: the number of handles contained in the objectHandles array.options: bit-coded. If bit0 is set (i.e. 1), then whole models will be copied. In that case, all specified objects should be flagged as model base.. -1 if operation was not successful, otherwise the number of handles returned in the objectHandles array."
    }, 
    "sim.setObjectConfiguration": {
        "body": "sim.setObjectConfiguration(${0:rawBufferHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.setObjectConfiguration", 
        "description": "number result = sim.setObjectConfiguration(number rawBufferHandle)Sets configuration information for an object (object relative position/orientation, joint/path value). Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling  sim.resetDynamicObject just before). See also sim.getObjectConfiguration and sim.setConfigurationTree. data: data returned by a previous call to simGetObjectConfigurationdata: data returned by a previous call to simGetObjectConfiguration -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simx.stopSimulation": {
        "body": "simx.stopSimulation(${0:clientId})", 
        "scope": "source.lua", 
        "prefix": "simx.stopSimulation", 
        "description": "number returnCode= simx.stopSimulation(number clientId)Requests a stop of the running simulation. See also simx.startSimulation and simx.pauseSimulation. clientID: the client ID. refer to simx.start.operationMode: a remote API function operation mode. Recommended operation modes for this function is simx.opmode_oneshot. returnCode: a remote API function return code"
    }, 
    "sim.getVisionSensorCharImage": {
        "body": "sim.getVisionSensorCharImage(${0:sensorHandle},${1:posX=0},${2:posY=0},${3:sizeX=0},${4:sizeY=0},${5:RgbaCutoff=0})", 
        "scope": "source.lua", 
        "prefix": "sim.getVisionSensorCharImage", 
        "description": "string imageBuffer,number resolutionX,number resolutionY = sim.getVisionSensorCharImage(number sensorHandle,number posX=0,number posY=0,number sizeX=0,number sizeY=0,number RgbaCutoff=0)Retrieves the rgb-image (or rgba, or a portion of it) of a vision sensor. The returned data doesn't make sense if sim.handleVisionSensor wasn't called previously  (sim.handleVisionSensor is called by default in the main script if the vision sensor is not tagged as explicit handling). See also sim.getVisionSensorImage, sim.setVisionSensorCharImage and sim.saveImage. sensorHandle: handle of the vision sensor.  Can be combined with sim_handleflag_greyscale (simply add sim_handleflag_greyscale to sensorHandle), if you wish to retrieve the grey scale equivalent.resolutionX/resolutionY: the returned vision sensor resolutionsensorHandle: handle of the vision sensor.  Can be combined with sim_handleflag_greyscale (simply add sim_handleflag_greyscale to sensorHandle), if you wish to retrieve the grey scale equivalent.resolutionX/resolutionY: the returned vision sensor resolution image buffer (buffer size is resolutionX*resolution*3 or resolutionX*resolutionY in case of a grey scale image retrieval) or NULL in case of an error. The user is in charge of releasing the returned buffer with simReleaseBuffer. Returned values are in the range of 0-255 (0=min. intensity, 255=max. intensity)"
    }, 
    "sim.message_pick_select_down": {
        "body": "sim.message_pick_select_down", 
        "scope": "source.lua", 
        "prefix": "sim.message_pick_select_down", 
        "description": "Constants"
    }, 
    "sim.stringparam_app_arg3": {
        "body": "sim.stringparam_app_arg3", 
        "scope": "source.lua", 
        "prefix": "sim.stringparam_app_arg3", 
        "description": "Constants"
    }, 
    "sim.camerafloatparam_ortho_size": {
        "body": "sim.camerafloatparam_ortho_size", 
        "scope": "source.lua", 
        "prefix": "sim.camerafloatparam_ortho_size", 
        "description": "Constants"
    }, 
    "simRRS1.DEFINE_EVENT": {
        "body": "simRRS1.DEFINE_EVENT(${0:rcsHandle},${1:eventId},${2:targetId},${3:resolution},${4:typeOfEvent})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.DEFINE_EVENT", 
        "description": "int status= simRRS1.DEFINE_EVENT(bitstring2 rcsHandle,int eventId,int targetId,real resolution,int typeOfEvent)"
    }, 
    "sim.filtercomponent_rectangularcut": {
        "body": "sim.filtercomponent_rectangularcut", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_rectangularcut", 
        "description": "Constants"
    }, 
    "sim.msgbox_return_no": {
        "body": "sim.msgbox_return_no", 
        "scope": "source.lua", 
        "prefix": "sim.msgbox_return_no", 
        "description": "Constants"
    }, 
    "simUI.addConnection": {
        "body": "simUI.addConnection(${0:handle},${1:id},${2:srcNodeId},${3:srcOutlet},${4:dstNodeId},${5:dstInlet})", 
        "scope": "source.lua", 
        "prefix": "simUI.addConnection", 
        "description": "simUI.addConnection(number handle,number id,number srcNodeId,number srcOutlet,number dstNodeId,number dstInlet)"
    }, 
    "sim.particle_roughspheres": {
        "body": "sim.particle_roughspheres", 
        "scope": "source.lua", 
        "prefix": "sim.particle_roughspheres", 
        "description": "Constants"
    }, 
    "simUI.getLabelText": {
        "body": "simUI.getLabelText(${0:handle},${1:id})", 
        "scope": "source.lua", 
        "prefix": "simUI.getLabelText", 
        "description": "string text = simUI.getLabelText(number handle,number id)"
    }, 
    "sim.drawing_wireframe": {
        "body": "sim.drawing_wireframe", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_wireframe", 
        "description": "Constants"
    }, 
    "sim.auxFunc": {
        "body": "sim.auxFunc(${0:...})", 
        "scope": "source.lua", 
        "prefix": "sim.auxFunc", 
        "description": "...  = sim.auxFunc(...)"
    }, 
    "simRRS1.GET_INVERSE_KINEMATIC": {
        "body": "simRRS1.GET_INVERSE_KINEMATIC(${0:rcsHandle},${1:cartPos},${2:jointPos},${3:configuration})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.GET_INVERSE_KINEMATIC", 
        "description": "int status,jointPosType jointPos,bitString jointLimit,int numberOfMessages= simRRS1.GET_INVERSE_KINEMATIC(bitstring2 rcsHandle,cartPosType cartPos,jointPosType jointPos,string configuration)"
    }, 
    "sim.vortex_body_autosleeplinearspeedthreshold": {
        "body": "sim.vortex_body_autosleeplinearspeedthreshold", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_autosleeplinearspeedthreshold", 
        "description": "Constants"
    }, 
    "simOMPL.Algorithm.SBL": {
        "body": "simOMPL.Algorithm.SBL", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.SBL", 
        "description": "Constants"
    }, 
    "sim.vortex_bodyfrictionmodel_prophigh": {
        "body": "sim.vortex_bodyfrictionmodel_prophigh", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_bodyfrictionmodel_prophigh", 
        "description": "Constants"
    }, 
    "sysCall_suspend": {
        "body": "sysCall_suspend(${0:suspended.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_suspend", 
        "description": "sysCall_suspend(Called just before simulation gets suspended.)"
    }, 
    "sim.displayattribute_forcewireframe": {
        "body": "sim.displayattribute_forcewireframe", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_forcewireframe", 
        "description": "Constants"
    }, 
    "sim.scriptthreadresume_allnotyetresumed": {
        "body": "sim.scriptthreadresume_allnotyetresumed", 
        "scope": "source.lua", 
        "prefix": "sim.scriptthreadresume_allnotyetresumed", 
        "description": "Constants"
    }, 
    "sim.simulation_stopped": {
        "body": "sim.simulation_stopped", 
        "scope": "source.lua", 
        "prefix": "sim.simulation_stopped", 
        "description": "Constants"
    }, 
    "file:seek": {
        "body": "file:seek(${0:...})", 
        "scope": "source.lua", 
        "prefix": "file:seek", 
        "description": "5.1,5.2,5.3\n\nfile:seek ([whence] [, offset])"
    }, 
    "simOMPL.addGoalState": {
        "body": "simOMPL.addGoalState(${0:taskHandle},${1:state})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.addGoalState", 
        "description": "number result = simOMPL.addGoalState(number taskHandle,table state)"
    }, 
    "simRRS1.SELECT_TIME_COMPENSATION": {
        "body": "simRRS1.SELECT_TIME_COMPENSATION(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SELECT_TIME_COMPENSATION", 
        "description": "int status= simRRS1.SELECT_TIME_COMPENSATION(bitstring2 rcsHandle)"
    }, 
    "sim.stringparam_app_arg8": {
        "body": "sim.stringparam_app_arg8", 
        "scope": "source.lua", 
        "prefix": "sim.stringparam_app_arg8", 
        "description": "Constants"
    }, 
    "simUI.setCurrentEditWidget": {
        "body": "simUI.setCurrentEditWidget(${0:handle},${1:id})", 
        "scope": "source.lua", 
        "prefix": "simUI.setCurrentEditWidget", 
        "description": "simUI.setCurrentEditWidget(number handle,number id)"
    }, 
    "sim.getThreadId": {
        "body": "sim.getThreadId()", 
        "scope": "source.lua", 
        "prefix": "sim.getThreadId", 
        "description": "number threadId = sim.getThreadId()Returns a thread id. See also simLockResources and simUnlockResources. - -1 in case of an error, otherwise the thread id: 0 if the thread is the gui thread, 1 if the thread is the main simulation thread, n if the thread is an auxiliary simulation thread."
    }, 
    "sim.ikresult_fail": {
        "body": "sim.ikresult_fail", 
        "scope": "source.lua", 
        "prefix": "sim.ikresult_fail", 
        "description": "Constants"
    }, 
    "sim.objectproperty_canupdatedna": {
        "body": "sim.objectproperty_canupdatedna", 
        "scope": "source.lua", 
        "prefix": "sim.objectproperty_canupdatedna", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_binary": {
        "body": "sim.filtercomponent_binary", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_binary", 
        "description": "Constants"
    }, 
    "sim.colorcomponent_transparency": {
        "body": "sim.colorcomponent_transparency", 
        "scope": "source.lua", 
        "prefix": "sim.colorcomponent_transparency", 
        "description": "Constants"
    }, 
    "sim.handleflag_altname": {
        "body": "sim.handleflag_altname", 
        "scope": "source.lua", 
        "prefix": "sim.handleflag_altname", 
        "description": "Constants"
    }, 
    "simUI.getPosition": {
        "body": "simUI.getPosition(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "simUI.getPosition", 
        "description": "number x,number y = simUI.getPosition(number handle)"
    }, 
    "sim.isObjectInSelection": {
        "body": "sim.isObjectInSelection(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.isObjectInSelection", 
        "description": "number selectionState = sim.isObjectInSelection(number objectHandle)Checks whether an object is selected. See also sim.getObjectSelection, sim.removeObjectFromSelection and sim.addObjectToSelection. objectHandle: handle of the objectobjectHandle: handle of the object 3 if object is the last selection,1 if object is in selection, 0 if not, -1 if operation was not successful"
    }, 
    "sim.drawing_facingcamera": {
        "body": "sim.drawing_facingcamera", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_facingcamera", 
        "description": "Constants"
    }, 
    "simx.readVisionSensor": {
        "body": "simx.readVisionSensor(${0:clientId},${1:visionSensorHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.readVisionSensor", 
        "description": "number returnCode,table packet1,table packet2,.. = simx.readVisionSensor(number clientId,number visionSensorHandle)Reads the state of a vision sensor. This function doesn't perform detection, it merely reads the result from a previous call to sim.handleVisionSensor (sim.handleVisionSensor is called in the default main script). See also simx.getVisionSensorImage and simx.getObjectGroupData. clientID: the client ID. refer to simx.start.sensorHandle: handle of the vision sensoroperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls) returnCode: a remote API function return codedetectionState: the detection state (i.e. the trigger state)packet: various packets of auxiliary data returned from the applied filters. By default V-REP returns one packet of 15 auxiliary values:the minimum of {intensity, red, green, blue, depth value}, the maximum of {intensity, red, green, blue, depth value}, and the average of {intensity, red, green, blue, depth value}. If additional filter components return values, then they will generate additional return packets."
    }, 
    "simRemoteApi.stop": {
        "body": "simRemoteApi.stop()", 
        "scope": "source.lua", 
        "prefix": "simRemoteApi.stop", 
        "description": "number result= simRemoteApi.stop()"
    }, 
    "sim.jointintparam_motor_enabled": {
        "body": "sim.jointintparam_motor_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.jointintparam_motor_enabled", 
        "description": "Constants"
    }, 
    "simUI.curve_scatter_shape.none": {
        "body": "simUI.curve_scatter_shape.none", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_scatter_shape.none", 
        "description": "Constants"
    }, 
    "sim.jointintparam_vortex_dep_handle": {
        "body": "sim.jointintparam_vortex_dep_handle", 
        "scope": "source.lua", 
        "prefix": "sim.jointintparam_vortex_dep_handle", 
        "description": "Constants"
    }, 
    "simx.getObjects": {
        "body": "simx.getObjects(${0:clientId},${1:objectType})", 
        "scope": "source.lua", 
        "prefix": "simx.getObjects", 
        "description": "number returnCode,table objectHandles= simx.getObjects(number clientId,number objectType)Retrieves object handles of a given type, or of all types (i.e. all object handles). See also simx.getObjectGroupData. clientID: the client ID. refer to simx.start.objectType: object type (sim.object_shape_type, sim.object_joint_type, etc., or sim.handle_all for any type of objectoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return codeobjectHandles: the object handles"
    }, 
    "math.atan": {
        "body": "math.atan( ${1:y}${2:[, x]} )", 
        "scope": "source.lua", 
        "prefix": "math.atan", 
        "description": "5.1,5.2,5.3\n\nmath.atan"
    }, 
    "simUI.updateTreeItemText": {
        "body": "simUI.updateTreeItemText(${0:handle},${1:id},${2:item_id},${3:text})", 
        "scope": "source.lua", 
        "prefix": "simUI.updateTreeItemText", 
        "description": "simUI.updateTreeItemText(number handle,number id,number item_id,table text)"
    }, 
    "sim.filtercomponent_scaleandoffsetcolors": {
        "body": "sim.filtercomponent_scaleandoffsetcolors", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_scaleandoffsetcolors", 
        "description": "Constants"
    }, 
    "file:flush": {
        "body": "file:flush(${0:...})", 
        "scope": "source.lua", 
        "prefix": "file:flush", 
        "description": "5.1,5.2,5.3\n\nfile:flush ()"
    }, 
    "table.pack": {
        "body": "table.pack(${0:...})", 
        "scope": "source.lua", 
        "prefix": "table.pack", 
        "description": "5.2,5.3\n\ntable.pack (...)"
    }, 
    "debug.setmetatable": {
        "body": "debug.setmetatable( ${1:value}, ${2:table} )", 
        "scope": "source.lua", 
        "prefix": "debug.setmetatable", 
        "description": "5.1,5.2,5.3\n\ndebug.setmetatable (value, table)"
    }, 
    "sim.newton_joint_objectid": {
        "body": "sim.newton_joint_objectid", 
        "scope": "source.lua", 
        "prefix": "sim.newton_joint_objectid", 
        "description": "Constants"
    }, 
    "sim.msgbox_type_question": {
        "body": "sim.msgbox_type_question", 
        "scope": "source.lua", 
        "prefix": "sim.msgbox_type_question", 
        "description": "Constants"
    }, 
    "sim.navigation_camerarotaterightbutton": {
        "body": "sim.navigation_camerarotaterightbutton", 
        "scope": "source.lua", 
        "prefix": "sim.navigation_camerarotaterightbutton", 
        "description": "Constants"
    }, 
    "sim.customizationscriptcall_simulationsensing": {
        "body": "sim.customizationscriptcall_simulationsensing", 
        "scope": "source.lua", 
        "prefix": "sim.customizationscriptcall_simulationsensing", 
        "description": "Constants"
    }, 
    "sim.ode_global_randomseed": {
        "body": "sim.ode_global_randomseed", 
        "scope": "source.lua", 
        "prefix": "sim.ode_global_randomseed", 
        "description": "Constants"
    }, 
    "sim.boolparam_stop_toolbarbutton_enabled": {
        "body": "sim.boolparam_stop_toolbarbutton_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_stop_toolbarbutton_enabled", 
        "description": "Constants"
    }, 
    "sim.shapefloatparam_shading_angle": {
        "body": "sim.shapefloatparam_shading_angle", 
        "scope": "source.lua", 
        "prefix": "sim.shapefloatparam_shading_angle", 
        "description": "Constants"
    }, 
    "sim.intparam_edit_mode_type": {
        "body": "sim.intparam_edit_mode_type", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_edit_mode_type", 
        "description": "Constants"
    }, 
    "sim.addonscriptcall_run": {
        "body": "sim.addonscriptcall_run", 
        "scope": "source.lua", 
        "prefix": "sim.addonscriptcall_run", 
        "description": "Constants"
    }, 
    "sim.getConfigurationTree": {
        "body": "sim.getConfigurationTree(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getConfigurationTree", 
        "description": "number rawBufferHandle = sim.getConfigurationTree(number objectHandle)Retrieves configuration information for a hierarchy tree (object relative positions/orientations, joint/path values). Calling sim.setConfigurationTree at a later time, will restore the object configuration (use this function to temporarily save object positions/orientations/joint/path values) objectHandle: handle of the object that is at the base of the tree (all objects built on top of this one (including this one)) will have their configuration retrieved. sim_handle_all will retrieve the configuration for the whole sceneobjectHandle: handle of the object that is at the base of the tree (all objects built on top of this one (including this one)) will have their configuration retrieved. sim_handle_all will retrieve the configuration for the whole scene Configuration data if operation was successful, NULL otherwise. The returned data should be deleted with simReleaseBuffer when not used anymore"
    }, 
    "debug.sethook": {
        "body": "debug.sethook( ${1:[thead,]}${2:hook}, ${3:mask}${4:[, count]} )", 
        "scope": "source.lua", 
        "prefix": "debug.sethook", 
        "description": "5.1,5.2,5.3\n\ndebug.sethook ([thread,] hook, mask [, count])"
    }, 
    "io.popen": {
        "body": "io.popen(${0:...})", 
        "scope": "source.lua", 
        "prefix": "io.popen", 
        "description": "5.1,5.2,5.3\n\nio.popen (prog [, mode])"
    }, 
    "sim.handle_main_script": {
        "body": "sim.handle_main_script", 
        "scope": "source.lua", 
        "prefix": "sim.handle_main_script", 
        "description": "Constants"
    }, 
    "sim.setThreadAutomaticSwitch": {
        "body": "sim.setThreadAutomaticSwitch(${0:automaticSwitch})", 
        "scope": "source.lua", 
        "prefix": "sim.setThreadAutomaticSwitch", 
        "description": "number result = sim.setThreadAutomaticSwitch(boolean automaticSwitch)Allows to temporarily forbid thread switches. If the current script doesn't run in a thread (i.e. if it runs in the application main thread), this function has no effect. By default, V-REP doesn't use regular threads, but something similar to hybrid threads (which behave like coroutines, but can also behave like regular threads). This allows much more flexibility and execution control of the threads. For complete control over the switching moment, see also sim.getThreadAutomaticSwitch, sim.setThreadSwitchTiming, sim.switchThread, sim.setThreadIsFree and sim.setThreadResumeLocation. - -"
    }, 
    "sim.appobj_collision_type": {
        "body": "sim.appobj_collision_type", 
        "scope": "source.lua", 
        "prefix": "sim.appobj_collision_type", 
        "description": "Constants"
    }, 
    "sim.saveScene": {
        "body": "sim.saveScene(${0:filename})", 
        "scope": "source.lua", 
        "prefix": "sim.saveScene", 
        "description": "number result = sim.saveScene(string filename)Saves a scene. Any existing file with same name will be overwritten. See also sim.loadScene, simCloseScene, and sim.saveModel. filename: scene filename. The filename extension is required (ttt)filename: scene filename. The filename extension is required (ttt) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.vortex_body_normalangularaxisfriction": {
        "body": "sim.vortex_body_normalangularaxisfriction", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_normalangularaxisfriction", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_customized": {
        "body": "sim.filtercomponent_customized", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_customized", 
        "description": "Constants"
    }, 
    "simx.breakForceSensor": {
        "body": "simx.breakForceSensor(${0:clientId},${1:forceSensorHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.breakForceSensor", 
        "description": "number returnCode= simx.breakForceSensor(number clientId,number forceSensorHandle)Allows breaking a force sensor during simulation. A broken force sensor will lose its positional and orientational constraints. See also simx.readForceSensor. clientID: the client ID. refer to simx.start.forceSensorHandle: handle of the force sensoroperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "sim.scripttype_addonscript": {
        "body": "sim.scripttype_addonscript", 
        "scope": "source.lua", 
        "prefix": "sim.scripttype_addonscript", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_motorconstraintfrictionloss": {
        "body": "sim.vortex_joint_motorconstraintfrictionloss", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_motorconstraintfrictionloss", 
        "description": "Constants"
    }, 
    "sim.rmlVel": {
        "body": "sim.rmlVel(${0:dofs},${1:smallestTimeStep},${2:flags},${3:currentPosVelAccel},${4:maxAccelJerk},${5:selection},${6:targetVel})", 
        "scope": "source.lua", 
        "prefix": "sim.rmlVel", 
        "description": "number handle = sim.rmlVel(number dofs,number smallestTimeStep,number flags,table currentPosVelAccel,table maxAccelJerk,table selection,table targetVel)"
    }, 
    "simUI.isVisible": {
        "body": "simUI.isVisible(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "simUI.isVisible", 
        "description": "bool visibility = simUI.isVisible(number handle)"
    }, 
    "sim.vortex_joint_relaxationenabledbc": {
        "body": "sim.vortex_joint_relaxationenabledbc", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_relaxationenabledbc", 
        "description": "Constants"
    }, 
    "elif": {
        "body": "else if ${1:condition} then\n\t${0:-- body}\n", 
        "scope": "source.lua", 
        "prefix": "elif", 
        "description": "elif"
    }, 
    "sim.bullet_body_restitution": {
        "body": "sim.bullet_body_restitution", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_body_restitution", 
        "description": "Constants"
    }, 
    "sim.navigation_camerazoom": {
        "body": "sim.navigation_camerazoom", 
        "scope": "source.lua", 
        "prefix": "sim.navigation_camerazoom", 
        "description": "Constants"
    }, 
    "sim.mirrorintparam_enable": {
        "body": "sim.mirrorintparam_enable", 
        "scope": "source.lua", 
        "prefix": "sim.mirrorintparam_enable", 
        "description": "Constants"
    }, 
    "sim.objectspecialproperty_pathplanning_ignored": {
        "body": "sim.objectspecialproperty_pathplanning_ignored", 
        "scope": "source.lua", 
        "prefix": "sim.objectspecialproperty_pathplanning_ignored", 
        "description": "Constants"
    }, 
    "sim.drawing_itemsizes": {
        "body": "sim.drawing_itemsizes", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_itemsizes", 
        "description": "Constants"
    }, 
    "sim.getEulerAnglesFromMatrix": {
        "body": "sim.getEulerAnglesFromMatrix(${0:matrix})", 
        "scope": "source.lua", 
        "prefix": "sim.getEulerAnglesFromMatrix", 
        "description": "table_3 eulerAngles = sim.getEulerAnglesFromMatrix(table_12 matrix)Retrieves the Euler angles from a transformation matrix. See also the other matrix/transformation functions. matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])eulerAngles: pointer to 3 simFloat values representing the Euler angles of the matrixmatrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])eulerAngles: pointer to 3 simFloat values representing the Euler angles of the matrixmatrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])eulerAngles: pointer to 3 simFloat values representing the Euler angles of the matrixmatrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])eulerAngles: pointer to 3 simFloat values representing the Euler angles of the matrixmatrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])eulerAngles: pointer to 3 simFloat values representing the Euler angles of the matrixmatrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The position component is (matrix[3],matrix[7],matrix[11])eulerAngles: pointer to 3 simFloat values representing the Euler angles of the matrix -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.dummy_linktype_gcs_target": {
        "body": "sim.dummy_linktype_gcs_target", 
        "scope": "source.lua", 
        "prefix": "sim.dummy_linktype_gcs_target", 
        "description": "Constants"
    }, 
    "simB0.spin": {
        "body": "simB0.spin(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "simB0.spin", 
        "description": "simB0.spin(string handle)"
    }, 
    "sim.vortex_joint_a2damping": {
        "body": "sim.vortex_joint_a2damping", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a2damping", 
        "description": "Constants"
    }, 
    "simROS.searchParam": {
        "body": "simROS.searchParam(${0:name})", 
        "scope": "source.lua", 
        "prefix": "simROS.searchParam", 
        "description": "bool found,string name = simROS.searchParam(string name)"
    }, 
    "sim.modelproperty_not_detectable": {
        "body": "sim.modelproperty_not_detectable", 
        "scope": "source.lua", 
        "prefix": "sim.modelproperty_not_detectable", 
        "description": "Constants"
    }, 
    "simx.clearStringSignal": {
        "body": "simx.clearStringSignal(${0:clientId},${1:signalName})", 
        "scope": "source.lua", 
        "prefix": "simx.clearStringSignal", 
        "description": "number returnCode= simx.clearStringSignal(number clientId,string signalName)Clears a string signal (removes it). See also simx.setStringSignal, simx.clearIntegerSignal and simx.clearFloatSignal. clientID: the client ID. refer to simx.start.signalName: name of the signal or an empty string to clear all string signalsoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "simMTB.stopServer": {
        "body": "simMTB.stopServer()", 
        "scope": "source.lua", 
        "prefix": "simMTB.stopServer", 
        "description": "boolean result= simMTB.stopServer()"
    }, 
    "sim.scriptthreadresume_default": {
        "body": "sim.scriptthreadresume_default", 
        "scope": "source.lua", 
        "prefix": "sim.scriptthreadresume_default", 
        "description": "Constants"
    }, 
    "sim.callScriptFunction": {
        "body": "sim.callScriptFunction(${0:functionNameAtScriptName},${1:scriptHandleOrType},${2:...})", 
        "scope": "source.lua", 
        "prefix": "sim.callScriptFunction", 
        "description": "... = sim.callScriptFunction(string functionNameAtScriptName,number scriptHandleOrType,...)Calls a script function (from a plugin, the main client application, or from another script). This represents a callback inside of a script. Call this only:a) from the main thread, or:b) from a thread that originated from a threaded child script. In that case, you cannot call non-threaded child scripts.When calling simulation scripts, then simulation must be running. See also sim.executeScriptString and sim.setScriptVariable. - -"
    }, 
    "sim.getLightParameters": {
        "body": "sim.getLightParameters(${0:lightHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getLightParameters", 
        "description": "number state,table_3 zero,table_3 diffusePart,table_3 specular = sim.getLightParameters(number lightHandle)Retrieves various parameters of a light object. See also sim.setLightParameters.  objectHandle: handle of the lightsetToNULL: not used, set to NULLdiffusePart: red, green and blue component of the light's diffuse part. Can be NULLspecularPart: red, green and blue component of the light's specular part. Can be NULLobjectHandle: handle of the lightsetToNULL: not used, set to NULLdiffusePart: red, green and blue component of the light's diffuse part. Can be NULLspecularPart: red, green and blue component of the light's specular part. Can be NULLobjectHandle: handle of the lightsetToNULL: not used, set to NULLdiffusePart: red, green and blue component of the light's diffuse part. Can be NULLspecularPart: red, green and blue component of the light's specular part. Can be NULLobjectHandle: handle of the lightsetToNULL: not used, set to NULLdiffusePart: red, green and blue component of the light's diffuse part. Can be NULLspecularPart: red, green and blue component of the light's specular part. Can be NULLobjectHandle: handle of the lightsetToNULL: not used, set to NULLdiffusePart: red, green and blue component of the light's diffuse part. Can be NULLspecularPart: red, green and blue component of the light's specular part. Can be NULL -1 in case of an error, otherwise bit-coded: for now, only bit 0 is used: 1=light on"
    }, 
    "sim.boolparam_force_show_wireless_reception": {
        "body": "sim.boolparam_force_show_wireless_reception", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_force_show_wireless_reception", 
        "description": "Constants"
    }, 
    "sim.vortex_body_seclinearaxisfriction": {
        "body": "sim.vortex_body_seclinearaxisfriction", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_seclinearaxisfriction", 
        "description": "Constants"
    }, 
    "simOMPL.Algorithm.RRT": {
        "body": "simOMPL.Algorithm.RRT", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.RRT", 
        "description": "Constants"
    }, 
    "sim.object_forcesensor_type": {
        "body": "sim.object_forcesensor_type", 
        "scope": "source.lua", 
        "prefix": "sim.object_forcesensor_type", 
        "description": "Constants"
    }, 
    "sim.drawing_triangles": {
        "body": "sim.drawing_triangles", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_triangles", 
        "description": "Constants"
    }, 
    "sim.addGhost": {
        "body": "sim.addGhost(${0:ghostGroup},${1:objectHandle},${2:options},${3:startTime},${4:endTime},${5:color=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.addGhost", 
        "description": "number ghostId = sim.addGhost(number ghostGroup,number objectHandle,number options,number startTime,number endTime,table_12 color=nil)Adds a light copy of a shape in its current configuration, as a ghost object. Ghosts have a visual start and end time, and are automatically played back during simulation (i.e. visualized), but they do not influence a simulation otherwise. Ghost are a convenient way to visually compare several simulation runs. Ghosts can be modified or cleared with sim.modifyGhost. Ghosts can also be cleared in the environment properties. ghostGroup: an identifier that allows grouping several ghostsobjectHandle: the handle of a shape, or the handle of a model base. Only currently visible shapes can be duplicated as ghosts.options: bit-coded:bit0 (1) set=the provided objectHandle is a model base, and all visible shapes in the model will be duplicated as ghostsbit1 (2) set=the provided start- and end-times will be played-back in real-timebit2 (4) set=preserve the original colorsbit3 (8) set=force invisible objects to appear toobit4 (16) set=create an invisible ghostbit5 (32) set=backface culling for the ghost (only when using custom colors)startTime: the time at which the ghost should appear.endTime: the time at which the ghost should disappear.color: 12 values that represent the color of the ghost (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL for default colors.ghostGroup: an identifier that allows grouping several ghostsobjectHandle: the handle of a shape, or the handle of a model base. Only currently visible shapes can be duplicated as ghosts.options: bit-coded:bit0 (1) set=the provided objectHandle is a model base, and all visible shapes in the model will be duplicated as ghostsbit1 (2) set=the provided start- and end-times will be played-back in real-timebit2 (4) set=preserve the original colorsbit3 (8) set=force invisible objects to appear toobit4 (16) set=create an invisible ghostbit5 (32) set=backface culling for the ghost (only when using custom colors)startTime: the time at which the ghost should appear.endTime: the time at which the ghost should disappear.color: 12 values that represent the color of the ghost (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL for default colors.ghostGroup: an identifier that allows grouping several ghostsobjectHandle: the handle of a shape, or the handle of a model base. Only currently visible shapes can be duplicated as ghosts.options: bit-coded:bit0 (1) set=the provided objectHandle is a model base, and all visible shapes in the model will be duplicated as ghostsbit1 (2) set=the provided start- and end-times will be played-back in real-timebit2 (4) set=preserve the original colorsbit3 (8) set=force invisible objects to appear toobit4 (16) set=create an invisible ghostbit5 (32) set=backface culling for the ghost (only when using custom colors)startTime: the time at which the ghost should appear.endTime: the time at which the ghost should disappear.color: 12 values that represent the color of the ghost (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL for default colors.ghostGroup: an identifier that allows grouping several ghostsobjectHandle: the handle of a shape, or the handle of a model base. Only currently visible shapes can be duplicated as ghosts.options: bit-coded:bit0 (1) set=the provided objectHandle is a model base, and all visible shapes in the model will be duplicated as ghostsbit1 (2) set=the provided start- and end-times will be played-back in real-timebit2 (4) set=preserve the original colorsbit3 (8) set=force invisible objects to appear toobit4 (16) set=create an invisible ghostbit5 (32) set=backface culling for the ghost (only when using custom colors)startTime: the time at which the ghost should appear.endTime: the time at which the ghost should disappear.color: 12 values that represent the color of the ghost (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL for default colors.ghostGroup: an identifier that allows grouping several ghostsobjectHandle: the handle of a shape, or the handle of a model base. Only currently visible shapes can be duplicated as ghosts.options: bit-coded:bit0 (1) set=the provided objectHandle is a model base, and all visible shapes in the model will be duplicated as ghostsbit1 (2) set=the provided start- and end-times will be played-back in real-timebit2 (4) set=preserve the original colorsbit3 (8) set=force invisible objects to appear toobit4 (16) set=create an invisible ghostbit5 (32) set=backface culling for the ghost (only when using custom colors)startTime: the time at which the ghost should appear.endTime: the time at which the ghost should disappear.color: 12 values that represent the color of the ghost (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL for default colors.ghostGroup: an identifier that allows grouping several ghostsobjectHandle: the handle of a shape, or the handle of a model base. Only currently visible shapes can be duplicated as ghosts.options: bit-coded:bit0 (1) set=the provided objectHandle is a model base, and all visible shapes in the model will be duplicated as ghostsbit1 (2) set=the provided start- and end-times will be played-back in real-timebit2 (4) set=preserve the original colorsbit3 (8) set=force invisible objects to appear toobit4 (16) set=create an invisible ghostbit5 (32) set=backface culling for the ghost (only when using custom colors)startTime: the time at which the ghost should appear.endTime: the time at which the ghost should disappear.color: 12 values that represent the color of the ghost (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL for default colors.ghostGroup: an identifier that allows grouping several ghostsobjectHandle: the handle of a shape, or the handle of a model base. Only currently visible shapes can be duplicated as ghosts.options: bit-coded:bit0 (1) set=the provided objectHandle is a model base, and all visible shapes in the model will be duplicated as ghostsbit1 (2) set=the provided start- and end-times will be played-back in real-timebit2 (4) set=preserve the original colorsbit3 (8) set=force invisible objects to appear toobit4 (16) set=create an invisible ghostbit5 (32) set=backface culling for the ghost (only when using custom colors)startTime: the time at which the ghost should appear.endTime: the time at which the ghost should disappear.color: 12 values that represent the color of the ghost (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL for default colors.ghostGroup: an identifier that allows grouping several ghostsobjectHandle: the handle of a shape, or the handle of a model base. Only currently visible shapes can be duplicated as ghosts.options: bit-coded:bit0 (1) set=the provided objectHandle is a model base, and all visible shapes in the model will be duplicated as ghostsbit1 (2) set=the provided start- and end-times will be played-back in real-timebit2 (4) set=preserve the original colorsbit3 (8) set=force invisible objects to appear toobit4 (16) set=create an invisible ghostbit5 (32) set=backface culling for the ghost (only when using custom colors)startTime: the time at which the ghost should appear.endTime: the time at which the ghost should disappear.color: 12 values that represent the color of the ghost (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL for default colors.ghostGroup: an identifier that allows grouping several ghostsobjectHandle: the handle of a shape, or the handle of a model base. Only currently visible shapes can be duplicated as ghosts.options: bit-coded:bit0 (1) set=the provided objectHandle is a model base, and all visible shapes in the model will be duplicated as ghostsbit1 (2) set=the provided start- and end-times will be played-back in real-timebit2 (4) set=preserve the original colorsbit3 (8) set=force invisible objects to appear toobit4 (16) set=create an invisible ghostbit5 (32) set=backface culling for the ghost (only when using custom colors)startTime: the time at which the ghost should appear.endTime: the time at which the ghost should disappear.color: 12 values that represent the color of the ghost (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL for default colors.ghostGroup: an identifier that allows grouping several ghostsobjectHandle: the handle of a shape, or the handle of a model base. Only currently visible shapes can be duplicated as ghosts.options: bit-coded:bit0 (1) set=the provided objectHandle is a model base, and all visible shapes in the model will be duplicated as ghostsbit1 (2) set=the provided start- and end-times will be played-back in real-timebit2 (4) set=preserve the original colorsbit3 (8) set=force invisible objects to appear toobit4 (16) set=create an invisible ghostbit5 (32) set=backface culling for the ghost (only when using custom colors)startTime: the time at which the ghost should appear.endTime: the time at which the ghost should disappear.color: 12 values that represent the color of the ghost (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL for default colors.ghostGroup: an identifier that allows grouping several ghostsobjectHandle: the handle of a shape, or the handle of a model base. Only currently visible shapes can be duplicated as ghosts.options: bit-coded:bit0 (1) set=the provided objectHandle is a model base, and all visible shapes in the model will be duplicated as ghostsbit1 (2) set=the provided start- and end-times will be played-back in real-timebit2 (4) set=preserve the original colorsbit3 (8) set=force invisible objects to appear toobit4 (16) set=create an invisible ghostbit5 (32) set=backface culling for the ghost (only when using custom colors)startTime: the time at which the ghost should appear.endTime: the time at which the ghost should disappear.color: 12 values that represent the color of the ghost (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL for default colors.ghostGroup: an identifier that allows grouping several ghostsobjectHandle: the handle of a shape, or the handle of a model base. Only currently visible shapes can be duplicated as ghosts.options: bit-coded:bit0 (1) set=the provided objectHandle is a model base, and all visible shapes in the model will be duplicated as ghostsbit1 (2) set=the provided start- and end-times will be played-back in real-timebit2 (4) set=preserve the original colorsbit3 (8) set=force invisible objects to appear toobit4 (16) set=create an invisible ghostbit5 (32) set=backface culling for the ghost (only when using custom colors)startTime: the time at which the ghost should appear.endTime: the time at which the ghost should disappear.color: 12 values that represent the color of the ghost (ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB). Can be NULL for default colors. -1 if operation was not successful, otherwise a ghost ID. Several ghosts might share the same  ID (e.g. when a ghost was added with bit0 of options set)"
    }, 
    "local": {
        "body": "local ${1:x} = ${0:1}", 
        "scope": "source.lua", 
        "prefix": "local", 
        "description": "local x = 1"
    }, 
    "simx.getDialogResult": {
        "body": "simx.getDialogResult(${0:clientId},${1:dialogHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.getDialogResult", 
        "description": "number returnCode,number result= simx.getDialogResult(number clientId,number dialogHandle)Queries the result of a dialog box. To be used after simx.displayDialog was called. clientID: the client ID. refer to simx.start.dialogHandle: handle of generic dialog (return value of simx.displayDialog)operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot  returnCode: a remote API function return coderesult: pointer receiving the result value."
    }, 
    "sim.customizationscriptattribute_activeduringsimulation": {
        "body": "sim.customizationscriptattribute_activeduringsimulation", 
        "scope": "source.lua", 
        "prefix": "sim.customizationscriptattribute_activeduringsimulation", 
        "description": "Constants"
    }, 
    "simBubble.create": {
        "body": "simBubble.create(${0:motorJointHandles},${1:sensorHandle},${2:backRelativeVelocities})", 
        "scope": "source.lua", 
        "prefix": "simBubble.create", 
        "description": "number bubbleRobHandle = simBubble.create(table_2 motorJointHandles,number sensorHandle,table_2 backRelativeVelocities)"
    }, 
    "sim.getVelocity": {
        "body": "sim.getVelocity(${0:shapeHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getVelocity", 
        "description": "table_3 linearVelocity,table_3 angularVelocity = sim.getVelocity(number shapeHandle)Retrieves the linear and/or angular velocity of the center of mass of a non-static shape object. See also sim.getObjectVelocity. shapeHandle: handle of a dynamically enabled shapelinearVelocity: pointer to 3 values that will receive the linear velocity in absolute coordinates. Can be NULLangularVelocity: pointer to 3 values that will receive the angular velocity in absolute coordinates. Can be NULLshapeHandle: handle of a dynamically enabled shapelinearVelocity: pointer to 3 values that will receive the linear velocity in absolute coordinates. Can be NULLangularVelocity: pointer to 3 values that will receive the angular velocity in absolute coordinates. Can be NULLshapeHandle: handle of a dynamically enabled shapelinearVelocity: pointer to 3 values that will receive the linear velocity in absolute coordinates. Can be NULLangularVelocity: pointer to 3 values that will receive the angular velocity in absolute coordinates. Can be NULLshapeHandle: handle of a dynamically enabled shapelinearVelocity: pointer to 3 values that will receive the linear velocity in absolute coordinates. Can be NULLangularVelocity: pointer to 3 values that will receive the angular velocity in absolute coordinates. Can be NULL -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.setIkGroupProperties": {
        "body": "sim.setIkGroupProperties(${0:ikGroupHandle},${1:resolutionMethod},${2:maxIterations},${3:damping})", 
        "scope": "source.lua", 
        "prefix": "sim.setIkGroupProperties", 
        "description": "number result = sim.setIkGroupProperties(number ikGroupHandle,number resolutionMethod,number maxIterations,number damping)Sets properties of an inverse kinematics group (IK group). See also sim.setIkElementProperties and sim.getIkGroupHandle. ikGroupHandle: handle of the IK group resolutionMethod: the IK resolution methodmaxIterations: the maximum number of iteractions for the calculationsdamping: the DLS damping factor.reserved: reserved for future extensions. Keep at NULLikGroupHandle: handle of the IK group resolutionMethod: the IK resolution methodmaxIterations: the maximum number of iteractions for the calculationsdamping: the DLS damping factor.reserved: reserved for future extensions. Keep at NULLikGroupHandle: handle of the IK group resolutionMethod: the IK resolution methodmaxIterations: the maximum number of iteractions for the calculationsdamping: the DLS damping factor.reserved: reserved for future extensions. Keep at NULLikGroupHandle: handle of the IK group resolutionMethod: the IK resolution methodmaxIterations: the maximum number of iteractions for the calculationsdamping: the DLS damping factor.reserved: reserved for future extensions. Keep at NULLikGroupHandle: handle of the IK group resolutionMethod: the IK resolution methodmaxIterations: the maximum number of iteractions for the calculationsdamping: the DLS damping factor.reserved: reserved for future extensions. Keep at NULL -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sysCall_beforeDelete": {
        "body": "sysCall_beforeDelete(${0:operation).},${1:keys.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_beforeDelete", 
        "description": "sysCall_beforeDelete(called just before objects are deleted (in an object delete/cut operation).,Arg1 is a map with 'objectHandles' and 'allObjects' keys.)"
    }, 
    "sim.banner_keepsamesize": {
        "body": "sim.banner_keepsamesize", 
        "scope": "source.lua", 
        "prefix": "sim.banner_keepsamesize", 
        "description": "Constants"
    }, 
    "sim.buttonproperty_label": {
        "body": "sim.buttonproperty_label", 
        "scope": "source.lua", 
        "prefix": "sim.buttonproperty_label", 
        "description": "Constants"
    }, 
    "sim.displayattribute_renderpass": {
        "body": "sim.displayattribute_renderpass", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_renderpass", 
        "description": "Constants"
    }, 
    "sim.object_mirror_type": {
        "body": "sim.object_mirror_type", 
        "scope": "source.lua", 
        "prefix": "sim.object_mirror_type", 
        "description": "Constants"
    }, 
    "sim.shapeintparam_wireframe": {
        "body": "sim.shapeintparam_wireframe", 
        "scope": "source.lua", 
        "prefix": "sim.shapeintparam_wireframe", 
        "description": "Constants"
    }, 
    "sim.ode_global_fullinternalscaling": {
        "body": "sim.ode_global_fullinternalscaling", 
        "scope": "source.lua", 
        "prefix": "sim.ode_global_fullinternalscaling", 
        "description": "Constants"
    }, 
    "simUI.rescaleAxes": {
        "body": "simUI.rescaleAxes(${0:handle},${1:id},${2:name},${3:onlyEnlargeX=false},${4:onlyEnlargeY=false})", 
        "scope": "source.lua", 
        "prefix": "simUI.rescaleAxes", 
        "description": "simUI.rescaleAxes(number handle,number id,string name,bool onlyEnlargeX=false,bool onlyEnlargeY=false)"
    }, 
    "sim.packUInt16Table": {
        "body": "sim.packUInt16Table(${0:uint16Numbers},${1:startUint16Index=0},${2:uint16Count=0})", 
        "scope": "source.lua", 
        "prefix": "sim.packUInt16Table", 
        "description": "string data = sim.packUInt16Table(table uint16Numbers,number startUint16Index=0,number uint16Count=0)Packs a table of uint16 numbers into a string. See also sim.unpackUInt16Table and the other packing/unpacking functions.  - -"
    }, 
    "simRRS1.GET_NEXT_STEP": {
        "body": "simRRS1.GET_NEXT_STEP(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.GET_NEXT_STEP", 
        "description": "int status,cartPosType cartPos,jointPosType jointPos,string configuration,real elapsedTime,bitstring jointLimit,int numberOfEvents,int numberOfMessages= simRRS1.GET_NEXT_STEP(bitstring2 rcsHandle)"
    }, 
    "sim.millintparam_volume_type": {
        "body": "sim.millintparam_volume_type", 
        "scope": "source.lua", 
        "prefix": "sim.millintparam_volume_type", 
        "description": "Constants"
    }, 
    "sim.getShapeTextureId": {
        "body": "sim.getShapeTextureId(${0:shapeHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getShapeTextureId", 
        "description": "number textureId = sim.getShapeTextureId(number shapeHandle)Retrieves the texture ID of a texture that is applied to a specific shape. See also sim.getTextureId and sim.setShapeTexture. shapeHandle: handle of the shape. The texture ID, or -1 if the texture does not exist or in case of an error"
    }, 
    "simx.getLastErrors": {
        "body": "simx.getLastErrors(${0:clientId})", 
        "scope": "source.lua", 
        "prefix": "simx.getLastErrors", 
        "description": "number returnCode,table errorStrings= simx.getLastErrors(number clientId)Retrieves the last 50 errors that occured on the server side, and clears the error buffer there. Only errors that occured because of this client will be reported. clientID: the client ID. refer to simx.start.operationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls) when not debugging. For debugging purposes, use simx.opmode_blocking. returnCode: a remote API function return codeerrorStrings: a table containing the error strings."
    }, 
    "sim.displayattribute_ignorelayer": {
        "body": "sim.displayattribute_ignorelayer", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_ignorelayer", 
        "description": "Constants"
    }, 
    "simRRS1.MATRIX_TO_CONTROLLER_POSITION": {
        "body": "simRRS1.MATRIX_TO_CONTROLLER_POSITION(${0:rcsHandle},${1:cartPos})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.MATRIX_TO_CONTROLLER_POSITION", 
        "description": "int status,string contrPos= simRRS1.MATRIX_TO_CONTROLLER_POSITION(bitstring2 rcsHandle,cartPosType cartPos)"
    }, 
    "simSDF.import": {
        "body": "simSDF.import(${0:fileName},${1:ignoreMissingValues=false},${2:hideCollisionLinks=true},${3:hideJoints=true},${4:convexDecompose=true},${5:showConvexDecompositionDlg=false},${6:createVisualIfNone=true},${7:centerModel=true},${8:prepareModel=true},${9:noSelfCollision=true},${10:positionCtrl=true})", 
        "scope": "source.lua", 
        "prefix": "simSDF.import", 
        "description": "simSDF.import(string fileName,bool ignoreMissingValues=false,bool hideCollisionLinks=true,bool hideJoints=true,bool convexDecompose=true,bool showConvexDecompositionDlg=false,bool createVisualIfNone=true,bool centerModel=true,bool prepareModel=true,bool noSelfCollision=true,bool positionCtrl=true)"
    }, 
    "sim.handleflag_codedstring": {
        "body": "sim.handleflag_codedstring", 
        "scope": "source.lua", 
        "prefix": "sim.handleflag_codedstring", 
        "description": "Constants"
    }, 
    "sim.particle_itemdensities": {
        "body": "sim.particle_itemdensities", 
        "scope": "source.lua", 
        "prefix": "sim.particle_itemdensities", 
        "description": "Constants"
    }, 
    "sysCall_resume": {
        "body": "sysCall_resume(${0:resumes.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_resume", 
        "description": "sysCall_resume(Called just before simulation resumes.)"
    }, 
    "sim.visionfloatparam_pov_aperture": {
        "body": "sim.visionfloatparam_pov_aperture", 
        "scope": "source.lua", 
        "prefix": "sim.visionfloatparam_pov_aperture", 
        "description": "Constants"
    }, 
    "simx.endDialog": {
        "body": "simx.endDialog(${0:clientId},${1:dialogHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.endDialog", 
        "description": "number returnCode= simx.endDialog(number clientId,number dialogHandle)Closes and releases resource from a previous call to simx.displayDialog. Even if the dialog is not visible anymore, you should release resources by using this function (however at the end of a simulation, all dialog resources are automatically released). clientID: the client ID. refer to simx.start.dialogHandle: handle of generic dialog (return value of simx.displayDialog)operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "sim.boolparam_objectrotate_toolbarbutton_enabled": {
        "body": "sim.boolparam_objectrotate_toolbarbutton_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_objectrotate_toolbarbutton_enabled", 
        "description": "Constants"
    }, 
    "sim.setFloatParameter": {
        "body": "sim.setFloatParameter(${0:parameter},${1:floatState})", 
        "scope": "source.lua", 
        "prefix": "sim.setFloatParameter", 
        "description": "number result = sim.setFloatParameter(number parameter,number floatState)Sets a floating point parameter. See also sim.getFloatParameter, sim.setBoolParameter, sim.setArrayParameter and sim.setInt32Parameter. parameter: floating parameter identifierfloatState: new state for the parameterparameter: floating parameter identifierfloatState: new state for the parameterparameter: floating parameter identifierfloatState: new state for the parameter -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.floatparam_mouse_wheel_zoom_factor": {
        "body": "sim.floatparam_mouse_wheel_zoom_factor", 
        "scope": "source.lua", 
        "prefix": "sim.floatparam_mouse_wheel_zoom_factor", 
        "description": "Constants"
    }, 
    "simUI.removeNode": {
        "body": "simUI.removeNode(${0:handle},${1:id},${2:nodeId})", 
        "scope": "source.lua", 
        "prefix": "simUI.removeNode", 
        "description": "simUI.removeNode(number handle,number id,number nodeId)"
    }, 
    "simUI.collapseAll": {
        "body": "simUI.collapseAll(${0:handle},${1:id},${2:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.collapseAll", 
        "description": "simUI.collapseAll(number handle,number id,bool suppressEvents=true)"
    }, 
    "module": {
        "body": "module(${0:...})", 
        "scope": "source.lua", 
        "prefix": "module", 
        "description": "5.1\n\nmodule (name [, ...])"
    }, 
    "sim.addForceAndTorque": {
        "body": "sim.addForceAndTorque(${0:shapeHandle},${1:force=nil},${2:torque=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.addForceAndTorque", 
        "description": "number result = sim.addForceAndTorque(number shapeHandle,table_3 force=nil,table_3 torque=nil)Adds a force and/or torque to a shape object that is dynamically enabled. Forces are applied at the center of mass. Added forces and torques are cumulative, and are reset to zero after sim.handleDynamics was called (or by using the following flags: sim.handleflag_resetforce and/or sim.handleflag_resettorque). See also sim.addForce. shapeHandle: handle of a dynamically enabled shape. Can be combined with sim.handleflag_resetforce and/or sim.handleflag_resettorque in order to clear the accumulated force or torque.force: pointer to 3 values that represent the force (in absolute coordinates) to add. Can be NULL.torque: pointer to 3 values that represent the torque (in absolute coordinates) to add. Can be NULLshapeHandle: handle of a dynamically enabled shape. Can be combined with sim.handleflag_resetforce and/or sim.handleflag_resettorque in order to clear the accumulated force or torque.force: pointer to 3 values that represent the force (in absolute coordinates) to add. Can be NULL.torque: pointer to 3 values that represent the torque (in absolute coordinates) to add. Can be NULLshapeHandle: handle of a dynamically enabled shape. Can be combined with sim.handleflag_resetforce and/or sim.handleflag_resettorque in order to clear the accumulated force or torque.force: pointer to 3 values that represent the force (in absolute coordinates) to add. Can be NULL.torque: pointer to 3 values that represent the torque (in absolute coordinates) to add. Can be NULLshapeHandle: handle of a dynamically enabled shape. Can be combined with sim.handleflag_resetforce and/or sim.handleflag_resettorque in order to clear the accumulated force or torque.force: pointer to 3 values that represent the force (in absolute coordinates) to add. Can be NULL.torque: pointer to 3 values that represent the torque (in absolute coordinates) to add. Can be NULL -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.vortex_joint_objectid": {
        "body": "sim.vortex_joint_objectid", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_objectid", 
        "description": "Constants"
    }, 
    "simRRS1.GET_RCS_DATA": {
        "body": "simRRS1.GET_RCS_DATA(${0:rcsHandle},${1:storage},${2:firstNext})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.GET_RCS_DATA", 
        "description": "int status,string paramId,string paramContents,int permission= simRRS1.GET_RCS_DATA(bitstring2 rcsHandle,int storage,int firstNext)"
    }, 
    "sim.childscriptcall_cleanup": {
        "body": "sim.childscriptcall_cleanup", 
        "scope": "source.lua", 
        "prefix": "sim.childscriptcall_cleanup", 
        "description": "Constants"
    }, 
    "sim.addParticleObject": {
        "body": "sim.addParticleObject(${0:objectType},${1:size},${2:density},${3:params},${4:lifeTime},${5:maxItemCount},${6:ambient_diffuse=nil},${7:nil},${8:specular=nil},${9:emission=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.addParticleObject", 
        "description": "number particleObjectHandle = sim.addParticleObject(number objectType,number size,number density,table params,number lifeTime,number maxItemCount,table_3 ambient_diffuse=nil,nil,table_3 specular=nil,table_3 emission=nil)Adds a particle object that will be simulated and displayed in the scene. Particle objects are containers that hold several items (particles) of a given type. This can be used for several different applications (e.g. simulation of air/water jets) See also sim.addParticleObjectItem and sim.removeParticleObject objectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULLobjectType: a particle object type combined with attributessize: diameter of the particles (spheres)density: density of the particlesparameters: points to an array of values, allowing to specify additional parameters. Can be NULL. The first value (an integer) indicates how many parameters will be set. All following values come in pair (an integer indicating what parameter, and a float indicating the parameter value. Following indicates the parameters:0: Bullet friction coefficient (default: 0.0)1: Bullet restitution coefficient (default: 0.0)2: ODE friction coefficient (default: 0.0)3: ODE soft ERP value (default: 0.2)4: ODE soft CFM values (default: 0.0)5: Bullet, ODE, Newton and Vortex linear drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)6: Bullet, ODE, Newton and Vortex quadratic drag parameter (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)7: Bullet, ODE, Newton and Vortex linear drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*parameter)8: Bullet, ODE, Newton and Vortex quadratic drag parameter in air (z>0) if sim_particle_water was specified (default: 0.0). Adds a force opposite to the particle velocity (f=v*v*parameter)9: Vortex friction (default: 0.0)10: Vortex restitution (default: 0.0)11: Vortex restitution threshold (default: 0.001)12: Vortex compliance (default: 0.0)13: Vortex damping (default: 0.0)14: Vortex adhesive force (default: 0.0)15: Newton static friction (default: 0.0)16: Newton kinetic friction (default: 0.0)17: Newton restitution (default: 0.0)If a parameter is not set, then its default value is used. As an example, following array: [3,0,0.5,2,0.5,9,0.5] will set Bullet's,  ODE's and Vortex's friction coefficients to 0.5lifeTime: simulation time after which the particles are destroyed. Set to 0.0 for an unlimited lifetime.maxItemCount: the maximum number of particles that this object can holdambient_diffuse: default ambient/diffuse color (pointer to 3 rgb values). Can be NULLsetToNULL: not used, set to NULLspecular: default specular color (pointer to 3 rgb values). Can be NULLemission: default emissive color (pointer to 3 rgb values). Can be NULL handle of the particle object if successful, -1 otherwise"
    }, 
    "sim.vortex_body_seclinearaxisfrictionmodel": {
        "body": "sim.vortex_body_seclinearaxisfrictionmodel", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_seclinearaxisfrictionmodel", 
        "description": "Constants"
    }, 
    "sim.newton_global_exactsolver": {
        "body": "sim.newton_global_exactsolver", 
        "scope": "source.lua", 
        "prefix": "sim.newton_global_exactsolver", 
        "description": "Constants"
    }, 
    "sim.setStringParameter": {
        "body": "sim.setStringParameter(${0:parameter},${1:stringState})", 
        "scope": "source.lua", 
        "prefix": "sim.setStringParameter", 
        "description": "number result = sim.setStringParameter(number parameter,string stringState)Sets a string parameter. See also sim.getStringParameter, sim.setBoolParameter, sim.setArrayParameter, sim.setFloatParameter and sim.setInt32Parameter. parameter: string parameter identifierstringState: new state for the parameterparameter: string parameter identifierstringState: new state for the parameterparameter: string parameter identifierstringState: new state for the parameter 1 if operation was successful. -1 if parameter is not known"
    }, 
    "sim.fileDialog": {
        "body": "sim.fileDialog(${0:mode},${1:title},${2:startPath},${3:initName},${4:extName},${5:ext})", 
        "scope": "source.lua", 
        "prefix": "sim.fileDialog", 
        "description": "string pathAndName = sim.fileDialog(number mode,string title,string startPath,string initName,string extName,string ext)Opens a dialog that allows selecting a file for save or load operations, or a folder. See also sim.msgBox. dlgType: the file dialog type.title: title of the dialogstartPath: the initial path. Indicate an empty string for the path to V-REP's applicationinitName: the initial name. Can be an empty stringextName: the extension name, e.g. text file. Should be an empty string with dlgType=sim_filedlg_type_folder.ext: the extension, e.g. txt. Should be an empty string with dlgType=sim_filedlg_type_folder.dlgType: the file dialog type.title: title of the dialogstartPath: the initial path. Indicate an empty string for the path to V-REP's applicationinitName: the initial name. Can be an empty stringextName: the extension name, e.g. text file. Should be an empty string with dlgType=sim_filedlg_type_folder.ext: the extension, e.g. txt. Should be an empty string with dlgType=sim_filedlg_type_folder.dlgType: the file dialog type.title: title of the dialogstartPath: the initial path. Indicate an empty string for the path to V-REP's applicationinitName: the initial name. Can be an empty stringextName: the extension name, e.g. text file. Should be an empty string with dlgType=sim_filedlg_type_folder.ext: the extension, e.g. txt. Should be an empty string with dlgType=sim_filedlg_type_folder.dlgType: the file dialog type.title: title of the dialogstartPath: the initial path. Indicate an empty string for the path to V-REP's applicationinitName: the initial name. Can be an empty stringextName: the extension name, e.g. text file. Should be an empty string with dlgType=sim_filedlg_type_folder.ext: the extension, e.g. txt. Should be an empty string with dlgType=sim_filedlg_type_folder.dlgType: the file dialog type.title: title of the dialogstartPath: the initial path. Indicate an empty string for the path to V-REP's applicationinitName: the initial name. Can be an empty stringextName: the extension name, e.g. text file. Should be an empty string with dlgType=sim_filedlg_type_folder.ext: the extension, e.g. txt. Should be an empty string with dlgType=sim_filedlg_type_folder.dlgType: the file dialog type.title: title of the dialogstartPath: the initial path. Indicate an empty string for the path to V-REP's applicationinitName: the initial name. Can be an empty stringextName: the extension name, e.g. text file. Should be an empty string with dlgType=sim_filedlg_type_folder.ext: the extension, e.g. txt. Should be an empty string with dlgType=sim_filedlg_type_folder. pointer to a string representing the selected file name and path, or folder name and path. In case several files were selected for a load operation, then they will be separated by a semicolon. The user is in charge of releasing the buffer with simReleaseBuffer."
    }, 
    "table.concat": {
        "body": "table.concat( ${1:tablename}${2:, \", \"}${3:, start_index}${4:, end_index} )", 
        "scope": "source.lua", 
        "prefix": "table.concat", 
        "description": "5.1,5.2,5.3\n\ntable.concat"
    }, 
    "sim.setSphericalJointMatrix": {
        "body": "sim.setSphericalJointMatrix()", 
        "scope": "source.lua", 
        "prefix": "sim.setSphericalJointMatrix", 
        "description": "number result = sim.setSphericalJointMatrix()Sets the intrinsic orientation matrix of a spherical joint object. This function cannot be used with non-spherical joints (use sim.setJointPosition instead). See also sim.getJointMatrix. objectHandle: handle of the joint objectmatrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11]) (the translational components will be ignored)objectHandle: handle of the joint objectmatrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11]) (the translational components will be ignored)objectHandle: handle of the joint objectmatrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11]) (the translational components will be ignored)objectHandle: handle of the joint objectmatrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11]) (the translational components will be ignored)objectHandle: handle of the joint objectmatrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11]) (the translational components will be ignored)objectHandle: handle of the joint objectmatrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11]) (the translational components will be ignored) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.objectspecialproperty_measurable": {
        "body": "sim.objectspecialproperty_measurable", 
        "scope": "source.lua", 
        "prefix": "sim.objectspecialproperty_measurable", 
        "description": "Constants"
    }, 
    "simROS.subscribe": {
        "body": "simROS.subscribe(${0:topicName},${1:topicType},${2:topicCallback},${3:queueSize=1})", 
        "scope": "source.lua", 
        "prefix": "simROS.subscribe", 
        "description": "number subscriberHandle = simROS.subscribe(string topicName,string topicType,string topicCallback,number queueSize=1)"
    }, 
    "sim.drawing_spherepoints": {
        "body": "sim.drawing_spherepoints", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_spherepoints", 
        "description": "Constants"
    }, 
    "simUI.setNodePos": {
        "body": "simUI.setNodePos(${0:handle},${1:id},${2:nodeId},${3:x},${4:y})", 
        "scope": "source.lua", 
        "prefix": "simUI.setNodePos", 
        "description": "simUI.setNodePos(number handle,number id,number nodeId,number x,number y)"
    }, 
    "simICP.matchToShape": {
        "body": "simICP.matchToShape(${0:model_handle},${1:template_handle},${2:outlier_treshold=-1})", 
        "scope": "source.lua", 
        "prefix": "simICP.matchToShape", 
        "description": "table m = simICP.matchToShape(number model_handle,number template_handle,number outlier_treshold=-1)"
    }, 
    "simRRS1.SET_POINT_ACCURACY_PARAMETER": {
        "body": "simRRS1.SET_POINT_ACCURACY_PARAMETER(${0:rcsHandle},${1:accuracyType})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_POINT_ACCURACY_PARAMETER", 
        "description": "int status= simRRS1.SET_POINT_ACCURACY_PARAMETER(bitstring2 rcsHandle,int accuracyType)"
    }, 
    "sim.checkCollisionEx": {
        "body": "sim.checkCollisionEx(${0:entity1Handle},${1:entity2Handle})", 
        "scope": "source.lua", 
        "prefix": "sim.checkCollisionEx", 
        "description": "number segmentCount,table segmentData = sim.checkCollisionEx(number entity1Handle,number entity2Handle)Checks whether two entities are colliding. This is the extended functionality version of sim.checkCollision, and will return all intersections between the two entities. Detection is silent (no visual feedback) compared to sim.handleCollision. Also, the collidable flags of the entities are overridden if the entities are objects. See also sim.readCollision. entity1Handle: handle of entity 1 (can be an object handle or a collection handle)entity2Handle: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other collidable objectsintersectionSegments: pointer to an array of simFloat values that represent the intersections (segments) between the two entities (pt1(x,y,z), pt2(x,y,z), pt1(x,y,z), etc). This can be NULL. The user should use simReleaseBuffer to delete the returned data. That data is only valid if return value is >0entity1Handle: handle of entity 1 (can be an object handle or a collection handle)entity2Handle: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other collidable objectsintersectionSegments: pointer to an array of simFloat values that represent the intersections (segments) between the two entities (pt1(x,y,z), pt2(x,y,z), pt1(x,y,z), etc). This can be NULL. The user should use simReleaseBuffer to delete the returned data. That data is only valid if return value is >0entity1Handle: handle of entity 1 (can be an object handle or a collection handle)entity2Handle: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other collidable objectsintersectionSegments: pointer to an array of simFloat values that represent the intersections (segments) between the two entities (pt1(x,y,z), pt2(x,y,z), pt1(x,y,z), etc). This can be NULL. The user should use simReleaseBuffer to delete the returned data. That data is only valid if return value is >0entity1Handle: handle of entity 1 (can be an object handle or a collection handle)entity2Handle: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other collidable objectsintersectionSegments: pointer to an array of simFloat values that represent the intersections (segments) between the two entities (pt1(x,y,z), pt2(x,y,z), pt1(x,y,z), etc). This can be NULL. The user should use simReleaseBuffer to delete the returned data. That data is only valid if return value is >0 -1 in case of an error, otherwise the number of segments returned"
    }, 
    "sim.msgbox_return_error": {
        "body": "sim.msgbox_return_error", 
        "scope": "source.lua", 
        "prefix": "sim.msgbox_return_error", 
        "description": "Constants"
    }, 
    "sim.writeCustomDataBlock": {
        "body": "sim.writeCustomDataBlock(${0:objectHandle},${1:tagName},${2:data})", 
        "scope": "source.lua", 
        "prefix": "sim.writeCustomDataBlock", 
        "description": "number result = sim.writeCustomDataBlock(number objectHandle,string tagName,string data)Adds or removes custom data to be stored and saved together with an object, a script or a scene (i.e. the data will be part of the object, the script or the scene). If the tag name starts with the string @tmp, then the data will not be saved during a scene or model save operation. The data can also be saved globally for the application (for the current V-REP session). See also sim.readCustomDataBlock and the data packing/unpacking functions. If you wish to store a reference to another object, have a look at sim.setReferencedHandles. objectHandle: handle of the object or script where you want to store your data, or sim_handle_scene if you wish to store the data with the scene, or sim_handle_app if you wish to store the data with the application's current session.tagName: a string that identifies the data. An empty string will remove all custom data blocks.data: your custom data. If NULL, the current data under the specified dataName will be removed. dataSize: the size of your custom dataThe data will be copied to an internal buffer inside of the object or scene, and next time a scene or model is saved, will also be saved. The data buffer can be released after this call.objectHandle: handle of the object or script where you want to store your data, or sim_handle_scene if you wish to store the data with the scene, or sim_handle_app if you wish to store the data with the application's current session.tagName: a string that identifies the data. An empty string will remove all custom data blocks.data: your custom data. If NULL, the current data under the specified dataName will be removed. dataSize: the size of your custom dataThe data will be copied to an internal buffer inside of the object or scene, and next time a scene or model is saved, will also be saved. The data buffer can be released after this call.objectHandle: handle of the object or script where you want to store your data, or sim_handle_scene if you wish to store the data with the scene, or sim_handle_app if you wish to store the data with the application's current session.tagName: a string that identifies the data. An empty string will remove all custom data blocks.data: your custom data. If NULL, the current data under the specified dataName will be removed. dataSize: the size of your custom dataThe data will be copied to an internal buffer inside of the object or scene, and next time a scene or model is saved, will also be saved. The data buffer can be released after this call.objectHandle: handle of the object or script where you want to store your data, or sim_handle_scene if you wish to store the data with the scene, or sim_handle_app if you wish to store the data with the application's current session.tagName: a string that identifies the data. An empty string will remove all custom data blocks.data: your custom data. If NULL, the current data under the specified dataName will be removed. dataSize: the size of your custom dataThe data will be copied to an internal buffer inside of the object or scene, and next time a scene or model is saved, will also be saved. The data buffer can be released after this call.objectHandle: handle of the object or script where you want to store your data, or sim_handle_scene if you wish to store the data with the scene, or sim_handle_app if you wish to store the data with the application's current session.tagName: a string that identifies the data. An empty string will remove all custom data blocks.data: your custom data. If NULL, the current data under the specified dataName will be removed. dataSize: the size of your custom dataThe data will be copied to an internal buffer inside of the object or scene, and next time a scene or model is saved, will also be saved. The data buffer can be released after this call. -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.drawing_quadpoints": {
        "body": "sim.drawing_quadpoints", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_quadpoints", 
        "description": "Constants"
    }, 
    "math.log10": {
        "body": "math.log10(${0:...})", 
        "scope": "source.lua", 
        "prefix": "math.log10", 
        "description": "5.1\n\nmath.log10 (x)"
    }, 
    "sim.object_renderingsensor_type": {
        "body": "sim.object_renderingsensor_type", 
        "scope": "source.lua", 
        "prefix": "sim.object_renderingsensor_type", 
        "description": "Constants"
    }, 
    "math.sin": {
        "body": "math.sin( ${1:x} )", 
        "scope": "source.lua", 
        "prefix": "math.sin", 
        "description": "5.1,5.2,5.3\n\nmath.sin"
    }, 
    "sim.getObjects": {
        "body": "sim.getObjects(${0:index},${1:objectType})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjects", 
        "description": "number objectHandle = sim.getObjects(number index,number objectType)Retrieves object handles. Use this in a loop where index starts at 0 and is incremented to get all object handles in the scene. See also sim.getObjectsInTree. index: object index (not handle!). First object is located at index 0objectType: object type (sim_object_shape_type, sim_object_joint_type, etc. (see the object types) or sim_handle_all for any type of objectindex: object index (not handle!). First object is located at index 0objectType: object type (sim_object_shape_type, sim_object_joint_type, etc. (see the object types) or sim_handle_all for any type of objectindex: object index (not handle!). First object is located at index 0objectType: object type (sim_object_shape_type, sim_object_joint_type, etc. (see the object types) or sim_handle_all for any type of object handle of the object or -1 if no object is located at that index or in case of an error"
    }, 
    "simOMPL.setStateValidationCallback": {
        "body": "simOMPL.setStateValidationCallback(${0:taskHandle},${1:callback})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.setStateValidationCallback", 
        "description": "number result = simOMPL.setStateValidationCallback(number taskHandle,string callback)"
    }, 
    "simx.query": {
        "body": "simx.query(${0:clientId},${1:signalName},${2:signalValue},${3:retSignalName})", 
        "scope": "source.lua", 
        "prefix": "simx.query", 
        "description": "number returnCode,string retSignalValue= simx.query(number clientId,string signalName,string signalValue,string retSignalName)DEPRECATED. Refer to simx.callScriptFunction instead.Sends a query string to V-REP, and waits for a reply string. Query and reply strings can be accessed via string signals. This function allows for instance to have a child script, another remote API client or a ROS node handle special requests coming from this remote API client, then send a reply back. To pack/unpack integers/floats into/from a string, refer to simx.packInts, simx.packFloats, simx.unpackInts and simx.unpackFloats.Usage example where a child script handles a request:-- Following is the remote API client side:ret,replyData=simx.query(clientID,request,send me a 42,reply,5000)if ret==0 then    print(The reply is:,replyData)end-- This is the child script side. The child script is non-threaded and-- following part executed at each simulation pass:req=sim.getStringSignal(request)if (req) then    sim.clearStringSignal(request)    if (req==send me a 42) then        sim.setStringSignal(reply,42\u0000) -- will be automatically cleared by the client    endend clientID: the client ID. refer to simx.start.signalName: name of the signal that contains the request stringsignalValue: the request string. retSignalName: name of the signal that contains the reply stringtimeOutInMs: the maximum time in milliseconds that the function will wait for a reply. returnCode: a remote API function return coderetSignalValue: the value of the reply string"
    }, 
    "simUI.getRadiobuttonValue": {
        "body": "simUI.getRadiobuttonValue(${0:handle},${1:id})", 
        "scope": "source.lua", 
        "prefix": "simUI.getRadiobuttonValue", 
        "description": "number value = simUI.getRadiobuttonValue(number handle,number id)"
    }, 
    "sim.insertObjectIntoPointCloud": {
        "body": "sim.insertObjectIntoPointCloud(${0:pointCloudHandle},${1:objectHandle},${2:options},${3:gridSize},${4:color=nil},${5:duplicateTolerance=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.insertObjectIntoPointCloud", 
        "description": "number totalPointCnt = sim.insertObjectIntoPointCloud(number pointCloudHandle,number objectHandle,number options,number gridSize,table color=nil,number duplicateTolerance=nil)Inserts an object into a point cloud, as points. See also sim.insertPointsIntoPointCloud and the other point cloud related functions. pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleobjectHandle: the handle of the object to insert. Only potentially collidable objects are supportedoptions: reserved. Set to 0gridSize: when a shape is inserted, it will first be converted to an octree with a given grid or voxel size.color: a pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleobjectHandle: the handle of the object to insert. Only potentially collidable objects are supportedoptions: reserved. Set to 0gridSize: when a shape is inserted, it will first be converted to an octree with a given grid or voxel size.color: a pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleobjectHandle: the handle of the object to insert. Only potentially collidable objects are supportedoptions: reserved. Set to 0gridSize: when a shape is inserted, it will first be converted to an octree with a given grid or voxel size.color: a pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleobjectHandle: the handle of the object to insert. Only potentially collidable objects are supportedoptions: reserved. Set to 0gridSize: when a shape is inserted, it will first be converted to an octree with a given grid or voxel size.color: a pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleobjectHandle: the handle of the object to insert. Only potentially collidable objects are supportedoptions: reserved. Set to 0gridSize: when a shape is inserted, it will first be converted to an octree with a given grid or voxel size.color: a pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleobjectHandle: the handle of the object to insert. Only potentially collidable objects are supportedoptions: reserved. Set to 0gridSize: when a shape is inserted, it will first be converted to an octree with a given grid or voxel size.color: a pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleobjectHandle: the handle of the object to insert. Only potentially collidable objects are supportedoptions: reserved. Set to 0gridSize: when a shape is inserted, it will first be converted to an octree with a given grid or voxel size.color: a pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleobjectHandle: the handle of the object to insert. Only potentially collidable objects are supportedoptions: reserved. Set to 0gridSize: when a shape is inserted, it will first be converted to an octree with a given grid or voxel size.color: a pointer to one RGB triple, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0 -1 if operation was not successful, otherwise the total number of points in the point cloud"
    }, 
    "sim.intparam_compilation_version": {
        "body": "sim.intparam_compilation_version", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_compilation_version", 
        "description": "Constants"
    }, 
    "sim.emptyCollection": {
        "body": "sim.emptyCollection(${0:collectionHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.emptyCollection", 
        "description": "number result = sim.emptyCollection(number collectionHandle)Clears a collection from all the objects it contains. An empty collection will not survive, unless you add some objects to it again with sim.addObjectToCollection right after. See also sim.removeCollection.  collectionHandle: handle of the collection to clear. sim_handle_all clears all collections from their obects.collectionHandle: handle of the collection to clear. sim_handle_all clears all collections from their obects. -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.getVisionSensorDepthBuffer": {
        "body": "sim.getVisionSensorDepthBuffer(${0:sensorHandle},${1:posX=0},${2:posY=0},${3:sizeX=0},${4:sizeY=0})", 
        "scope": "source.lua", 
        "prefix": "sim.getVisionSensorDepthBuffer", 
        "description": "table/string depthBuffer = sim.getVisionSensorDepthBuffer(number sensorHandle,number posX=0,number posY=0,number sizeX=0,number sizeY=0)Retrieves the depth buffer (or a portion of it) of a vision sensor. Use sim.getVisionSensorResolution to know the resolution of the full depth buffer. The returned data doesn't make sense if sim.handleVisionSensor wasn't called previously (sim.handleVisionSensor is called by default in the main script if the vision sensor is not tagged as explicit handling). sensorHandle: handle of the vision sensor depth buffer (buffer size is resolutionX*resolutionY) or NULL in case of an error. The user is in charge of releasing the returned buffer with simReleaseBuffer. Returned values are in the range of 0-1 (0=closest to sensor (i.e. close clipping plane), 1=farthest from sensor (i.e. far clipping plane))"
    }, 
    "sim.addonscriptcall_cleanup": {
        "body": "sim.addonscriptcall_cleanup", 
        "scope": "source.lua", 
        "prefix": "sim.addonscriptcall_cleanup", 
        "description": "Constants"
    }, 
    "sim.vortex_global_stepsize": {
        "body": "sim.vortex_global_stepsize", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_global_stepsize", 
        "description": "Constants"
    }, 
    "sim.createPointCloud": {
        "body": "sim.createPointCloud(${0:maxVoxelSize},${1:maxPtCntPerVoxel},${2:options},${3:pointSize})", 
        "scope": "source.lua", 
        "prefix": "sim.createPointCloud", 
        "description": "number handle = sim.createPointCloud(number maxVoxelSize,number maxPtCntPerVoxel,number options,number pointSize)Creates an empty point cloud. See also sim.removeObject, sim.setPointCloudOptions and the other point cloud related functions. maxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLmaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLmaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLmaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLmaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLmaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLmaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLmaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLmaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULLmaxVoxelSize: the maximum size of the octree voxels containing pointsmaxPtCntPerVoxel: the maximum number of points allowed in a same octree voxeloptions: bit-coded:bit0 set (1): points have random colorsbit1 set (2): show octree structurebit2 set (4): reserved. keep unsetbit3 set (8): do not use an octree structure. When enabled, point cloud operations are limited, and point clouds will not be collidable, measurable or detectable anymore, but adding points will be much fasterbit4 set (16): color is emissivepointSize: the size of the points, in pixelsreserved: reserved for future extensions. Set to NULL -1 if operation was not successful, otherwise the handle of the point cloud"
    }, 
    "sim.setObjectQuaternion": {
        "body": "sim.setObjectQuaternion(${0:objectHandle},${1:relativeToObjectHandle},${2:quaternion})", 
        "scope": "source.lua", 
        "prefix": "sim.setObjectQuaternion", 
        "description": "number result = sim.setObjectQuaternion(number objectHandle,number relativeToObjectHandle,table_4 quaternion)Sets the quaternion (x,y,z,w) of an object. Be very careful to set only valid value (i.e. normalized), otherwise you will experience strange effects. Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling  sim.resetDynamicObject just before). See also sim.setObjectOrientation and the other matrix/transformation functions. objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the orientation is specified. Specify -1 to set the absolute orientation, sim_handle_parent to set the orientation relative to the object's parent, or an object handle relative to whose reference frame the orientation is specified.quaternion: the quaternion (x,y,z,w)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the orientation is specified. Specify -1 to set the absolute orientation, sim_handle_parent to set the orientation relative to the object's parent, or an object handle relative to whose reference frame the orientation is specified.quaternion: the quaternion (x,y,z,w)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the orientation is specified. Specify -1 to set the absolute orientation, sim_handle_parent to set the orientation relative to the object's parent, or an object handle relative to whose reference frame the orientation is specified.quaternion: the quaternion (x,y,z,w)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the orientation is specified. Specify -1 to set the absolute orientation, sim_handle_parent to set the orientation relative to the object's parent, or an object handle relative to whose reference frame the orientation is specified.quaternion: the quaternion (x,y,z,w) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.buffer_uint8": {
        "body": "sim.buffer_uint8", 
        "scope": "source.lua", 
        "prefix": "sim.buffer_uint8", 
        "description": "Constants"
    }, 
    "sim.setConfigurationTree": {
        "body": "sim.setConfigurationTree(${0:rawBufferHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.setConfigurationTree", 
        "description": "number result = sim.setConfigurationTree(number rawBufferHandle)Restores configuration information previously retrieved with sim.getConfigurationTree (object relative positions/orientations, joint/path values). Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling  sim.resetDynamicObject just before) data: data returned by a previous call to simGetConfigurationTreedata: data returned by a previous call to simGetConfigurationTree -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "tonumber": {
        "body": "tonumber(${1:e}${2:[, base]})", 
        "scope": "source.lua", 
        "prefix": "tonumber", 
        "description": "5.1,5.2,5.3\n\ntonumber (e [, base])"
    }, 
    "sim.script_call_error": {
        "body": "sim.script_call_error", 
        "scope": "source.lua", 
        "prefix": "sim.script_call_error", 
        "description": "Constants"
    }, 
    "simx.addStatusbarMessage": {
        "body": "simx.addStatusbarMessage(${0:clientId},${1:message})", 
        "scope": "source.lua", 
        "prefix": "simx.addStatusbarMessage", 
        "description": "number returnCode= simx.addStatusbarMessage(number clientId,string message)Adds a message to the status bar. clientID: the client ID. refer to simx.start.message: the message to displayoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "sim.object_pointcloud_type": {
        "body": "sim.object_pointcloud_type", 
        "scope": "source.lua", 
        "prefix": "sim.object_pointcloud_type", 
        "description": "Constants"
    }, 
    "sysCall_actuation": {
        "body": "sysCall_actuation(${0:phase.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_actuation", 
        "description": "sysCall_actuation(Called in the actuation phase.)"
    }, 
    "simB0.createPublisher": {
        "body": "simB0.createPublisher(${0:nodeHandle},${1:topic})", 
        "scope": "source.lua", 
        "prefix": "simB0.createPublisher", 
        "description": "string handle simB0.createPublisher(string nodeHandle,string topic)"
    }, 
    "simRRS1.SET_CARTESIAN_ORIENTATION_ACCELERATION": {
        "body": "simRRS1.SET_CARTESIAN_ORIENTATION_ACCELERATION(${0:rcsHandle},${1:rotationNo},${2:accelValue})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_CARTESIAN_ORIENTATION_ACCELERATION", 
        "description": "int status= simRRS1.SET_CARTESIAN_ORIENTATION_ACCELERATION(bitstring2 rcsHandle,int rotationNo,real accelValue)"
    }, 
    "string.sub": {
        "body": "string.sub( ${1:s}, ${2:i}${3:[, j]} )", 
        "scope": "source.lua", 
        "prefix": "string.sub", 
        "description": "5.1,5.2,5.3\n\nstring.sub"
    }, 
    "simUI.getSliderValue": {
        "body": "simUI.getSliderValue(${0:handle},${1:id})", 
        "scope": "source.lua", 
        "prefix": "simUI.getSliderValue", 
        "description": "number value = simUI.getSliderValue(number handle,number id)"
    }, 
    "simRRS1.LOAD_RCS_DATA": {
        "body": "simRRS1.LOAD_RCS_DATA()", 
        "scope": "source.lua", 
        "prefix": "simRRS1.LOAD_RCS_DATA", 
        "description": "int status,int numberOfMessages= simRRS1.LOAD_RCS_DATA()"
    }, 
    "sysCall_afterInstanceSwitch": {
        "body": "sysCall_afterInstanceSwitch(${0:switch.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_afterInstanceSwitch", 
        "description": "sysCall_afterInstanceSwitch(Called just after an instance switch.)"
    }, 
    "sim.script_reentrance_error": {
        "body": "sim.script_reentrance_error", 
        "scope": "source.lua", 
        "prefix": "sim.script_reentrance_error", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_lowerlimitmaxforce": {
        "body": "sim.vortex_joint_lowerlimitmaxforce", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_lowerlimitmaxforce", 
        "description": "Constants"
    }, 
    "sim.readDistance": {
        "body": "sim.readDistance(${0:distanceObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.readDistance", 
        "description": "number result,number smallestDistance = sim.readDistance(number distanceObjectHandle)Reads the distance of a registered distance object. This function doesn't perform distance measurement, it merely reads the result from a previous call to sim.handleDistance (sim.handleDistance is called in the default main script). See also sim.resetDistance and sim.checkDistance. distanceObjectHandle: handle of the distance objectsmallestDistance: smallest distance (valid only if return value is different from -1)distanceObjectHandle: handle of the distance objectsmallestDistance: smallest distance (valid only if return value is different from -1)distanceObjectHandle: handle of the distance objectsmallestDistance: smallest distance (valid only if return value is different from -1) different from -1 if distance was read, -1 in case of an error."
    }, 
    "sim.computeMassAndInertia": {
        "body": "sim.computeMassAndInertia(${0:shapeHandle},${1:density})", 
        "scope": "source.lua", 
        "prefix": "sim.computeMassAndInertia", 
        "description": "number result = sim.computeMassAndInertia(number shapeHandle,number density)Computes and applies the mass and inertia properties for a convex shape (or convex compound shape), based on a density value. If call this function while the simulation is running, you will have to call sim.resetDynamicObject upon the object, for the changes to take effect. See also sim.getShapeMassAndInertia and sim.convexDecompose. shapeHandle: handle of shape. The shape must be convex (or a convex compound).density: the density expressed in kg/m^3shapeHandle: handle of shape. The shape must be convex (or a convex compound).density: the density expressed in kg/m^3 -1 in case of an error, 0 if the shape is not convex, otherwise 1."
    }, 
    "sim.proxintparam_ray_invisibility": {
        "body": "sim.proxintparam_ray_invisibility", 
        "scope": "source.lua", 
        "prefix": "sim.proxintparam_ray_invisibility", 
        "description": "Constants"
    }, 
    "sim.checkDistance": {
        "body": "sim.checkDistance(${0:entity1Handle},${1:entity2Handle},${2:threshold})", 
        "scope": "source.lua", 
        "prefix": "sim.checkDistance", 
        "description": "number result,table_7 distanceData = sim.checkDistance(number entity1Handle,number entity2Handle,number threshold)Checks the minimum distance between two entities. Detection is silent (no visual feedback) compared to sim.handleDistance. Also, the measurable flags of the entities are overridden if the entities are objects. See also sim.readDistance. entity1Handle: handle of entity 1 (can be an object handle or a collection handle)entity2Handle: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other measurable objectsthreshold: if distance is bigger than the threshold, the distance is not calculated and return value is 0. If threshold is 0 or negative, then no threshold is used.distanceData: distanceData[0]-distanceData[5] represents the distance segment, distanceData[6] is the distance between the entities. This data is valid only if return value is 1entity1Handle: handle of entity 1 (can be an object handle or a collection handle)entity2Handle: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other measurable objectsthreshold: if distance is bigger than the threshold, the distance is not calculated and return value is 0. If threshold is 0 or negative, then no threshold is used.distanceData: distanceData[0]-distanceData[5] represents the distance segment, distanceData[6] is the distance between the entities. This data is valid only if return value is 1entity1Handle: handle of entity 1 (can be an object handle or a collection handle)entity2Handle: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other measurable objectsthreshold: if distance is bigger than the threshold, the distance is not calculated and return value is 0. If threshold is 0 or negative, then no threshold is used.distanceData: distanceData[0]-distanceData[5] represents the distance segment, distanceData[6] is the distance between the entities. This data is valid only if return value is 1entity1Handle: handle of entity 1 (can be an object handle or a collection handle)entity2Handle: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other measurable objectsthreshold: if distance is bigger than the threshold, the distance is not calculated and return value is 0. If threshold is 0 or negative, then no threshold is used.distanceData: distanceData[0]-distanceData[5] represents the distance segment, distanceData[6] is the distance between the entities. This data is valid only if return value is 1entity1Handle: handle of entity 1 (can be an object handle or a collection handle)entity2Handle: handle of entity 2 (can be an object handle or a collection handle), or sim_handle_all to check entity1 against all other measurable objectsthreshold: if distance is bigger than the threshold, the distance is not calculated and return value is 0. If threshold is 0 or negative, then no threshold is used.distanceData: distanceData[0]-distanceData[5] represents the distance segment, distanceData[6] is the distance between the entities. This data is valid only if return value is 1 0 or 1 if operation was successful (1 if distance is smaller than threshold), -1 otherwise"
    }, 
    "sim.ode_body_maxcontacts": {
        "body": "sim.ode_body_maxcontacts", 
        "scope": "source.lua", 
        "prefix": "sim.ode_body_maxcontacts", 
        "description": "Constants"
    }, 
    "sim.vortex_global_contacttolerance": {
        "body": "sim.vortex_global_contacttolerance", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_global_contacttolerance", 
        "description": "Constants"
    }, 
    "sim.colorcomponent_emission": {
        "body": "sim.colorcomponent_emission", 
        "scope": "source.lua", 
        "prefix": "sim.colorcomponent_emission", 
        "description": "Constants"
    }, 
    "sim.visionintparam_rendering_attributes": {
        "body": "sim.visionintparam_rendering_attributes", 
        "scope": "source.lua", 
        "prefix": "sim.visionintparam_rendering_attributes", 
        "description": "Constants"
    }, 
    "sim.proximitysensor_pyramid_subtype": {
        "body": "sim.proximitysensor_pyramid_subtype", 
        "scope": "source.lua", 
        "prefix": "sim.proximitysensor_pyramid_subtype", 
        "description": "Constants"
    }, 
    "sim.appobj_2delement_type": {
        "body": "sim.appobj_2delement_type", 
        "scope": "source.lua", 
        "prefix": "sim.appobj_2delement_type", 
        "description": "Constants"
    }, 
    "sim.getJointTargetPosition": {
        "body": "sim.getJointTargetPosition(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getJointTargetPosition", 
        "description": "number result,number targetPosition = sim.getJointTargetPosition(number objectHandle)Retrieves the target position of a joint. See also sim.setJointTargetPosition. objectHandle: handle of the joint objecttargetPosition (output): target position of the joint (angular or linear value depending on the joint type)objectHandle: handle of the joint objecttargetPosition (output): target position of the joint (angular or linear value depending on the joint type)objectHandle: handle of the joint objecttargetPosition (output): target position of the joint (angular or linear value depending on the joint type) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.dummy_linktype_dynamics_loop_closure": {
        "body": "sim.dummy_linktype_dynamics_loop_closure", 
        "scope": "source.lua", 
        "prefix": "sim.dummy_linktype_dynamics_loop_closure", 
        "description": "Constants"
    }, 
    "sim.visionintparam_pov_blur_sampled": {
        "body": "sim.visionintparam_pov_blur_sampled", 
        "scope": "source.lua", 
        "prefix": "sim.visionintparam_pov_blur_sampled", 
        "description": "Constants"
    }, 
    "sim.scriptexecorder_last": {
        "body": "sim.scriptexecorder_last", 
        "scope": "source.lua", 
        "prefix": "sim.scriptexecorder_last", 
        "description": "Constants"
    }, 
    "simRRS1.CANCEL_EVENT": {
        "body": "simRRS1.CANCEL_EVENT(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.CANCEL_EVENT", 
        "description": "int status= simRRS1.CANCEL_EVENT(bitstring2 rcsHandle)"
    }, 
    "sim.jointintparam_ctrl_enabled": {
        "body": "sim.jointintparam_ctrl_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.jointintparam_ctrl_enabled", 
        "description": "Constants"
    }, 
    "sim.getFloatParameter": {
        "body": "sim.getFloatParameter(${0:parameter})", 
        "scope": "source.lua", 
        "prefix": "sim.getFloatParameter", 
        "description": "number floatState = sim.getFloatParameter(number parameter)Retrieves a floating point value. See the floating-point parameter identifiers. See also sim.setFloatParameter, sim.getBoolParameter, sim.getInt32Parameter, sim.getArrayParameter and sim.getStringParameter. parameter: floating parameter identifierfloatState: value of the parameterparameter: floating parameter identifierfloatState: value of the parameterparameter: floating parameter identifierfloatState: value of the parameter -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "string.gmatch": {
        "body": "string.gmatch( ${1:s},${2:pattern} )", 
        "scope": "source.lua", 
        "prefix": "string.gmatch", 
        "description": "5.1,5.2,5.3\n\nstring.gmatch"
    }, 
    "simRRS1.SET_INITIAL_POSITION": {
        "body": "simRRS1.SET_INITIAL_POSITION(${0:rcsHandle},${1:cartPos},${2:jointPos})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_INITIAL_POSITION", 
        "description": "int status,bitstring jointLimit= simRRS1.SET_INITIAL_POSITION(bitstring2 rcsHandle,cartPosType cartPos,jointPosType jointPos)"
    }, 
    "simROS.shutdownPublisher": {
        "body": "simROS.shutdownPublisher(${0:publisherHandle})", 
        "scope": "source.lua", 
        "prefix": "simROS.shutdownPublisher", 
        "description": "simROS.shutdownPublisher(number publisherHandle)"
    }, 
    "simOMPL.Algorithm.LazyPRMstar": {
        "body": "simOMPL.Algorithm.LazyPRMstar", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.LazyPRMstar", 
        "description": "Constants"
    }, 
    "sim.buttonproperty_downupevent": {
        "body": "sim.buttonproperty_downupevent", 
        "scope": "source.lua", 
        "prefix": "sim.buttonproperty_downupevent", 
        "description": "Constants"
    }, 
    "sim.msgbox_return_cancel": {
        "body": "sim.msgbox_return_cancel", 
        "scope": "source.lua", 
        "prefix": "sim.msgbox_return_cancel", 
        "description": "Constants"
    }, 
    "sim.transformImage": {
        "body": "sim.transformImage(${0:image},${1:resolution},${2:options})", 
        "scope": "source.lua", 
        "prefix": "sim.transformImage", 
        "description": "number result = sim.transformImage(string image,table_2 resolution,number options)Transforms an image in various ways. See also sim.loadImage, sim.getScaledImage, sim.transformBuffer and sim.combineRgbImages. image: a pointer to rgb or rgba values of the imageresolution: the resolution of the imageoptions: bit-coded:bit0 set (1): the provided image is rgba, otherwise it is rgbbit1 set (2): the image will be flipped on its x-axisbit2 set (4): the image will be flipped on its y-axisfloatParams: Reserved for future extension. Set to NULL.intParams: Reserved for future extension. Set to NULL.reserved: Reserved for future extension. Set to NULL.image: a pointer to rgb or rgba values of the imageresolution: the resolution of the imageoptions: bit-coded:bit0 set (1): the provided image is rgba, otherwise it is rgbbit1 set (2): the image will be flipped on its x-axisbit2 set (4): the image will be flipped on its y-axisfloatParams: Reserved for future extension. Set to NULL.intParams: Reserved for future extension. Set to NULL.reserved: Reserved for future extension. Set to NULL.image: a pointer to rgb or rgba values of the imageresolution: the resolution of the imageoptions: bit-coded:bit0 set (1): the provided image is rgba, otherwise it is rgbbit1 set (2): the image will be flipped on its x-axisbit2 set (4): the image will be flipped on its y-axisfloatParams: Reserved for future extension. Set to NULL.intParams: Reserved for future extension. Set to NULL.reserved: Reserved for future extension. Set to NULL.image: a pointer to rgb or rgba values of the imageresolution: the resolution of the imageoptions: bit-coded:bit0 set (1): the provided image is rgba, otherwise it is rgbbit1 set (2): the image will be flipped on its x-axisbit2 set (4): the image will be flipped on its y-axisfloatParams: Reserved for future extension. Set to NULL.intParams: Reserved for future extension. Set to NULL.reserved: Reserved for future extension. Set to NULL.image: a pointer to rgb or rgba values of the imageresolution: the resolution of the imageoptions: bit-coded:bit0 set (1): the provided image is rgba, otherwise it is rgbbit1 set (2): the image will be flipped on its x-axisbit2 set (4): the image will be flipped on its y-axisfloatParams: Reserved for future extension. Set to NULL.intParams: Reserved for future extension. Set to NULL.reserved: Reserved for future extension. Set to NULL.image: a pointer to rgb or rgba values of the imageresolution: the resolution of the imageoptions: bit-coded:bit0 set (1): the provided image is rgba, otherwise it is rgbbit1 set (2): the image will be flipped on its x-axisbit2 set (4): the image will be flipped on its y-axisfloatParams: Reserved for future extension. Set to NULL.intParams: Reserved for future extension. Set to NULL.reserved: Reserved for future extension. Set to NULL.image: a pointer to rgb or rgba values of the imageresolution: the resolution of the imageoptions: bit-coded:bit0 set (1): the provided image is rgba, otherwise it is rgbbit1 set (2): the image will be flipped on its x-axisbit2 set (4): the image will be flipped on its y-axisfloatParams: Reserved for future extension. Set to NULL.intParams: Reserved for future extension. Set to NULL.reserved: Reserved for future extension. Set to NULL.image: a pointer to rgb or rgba values of the imageresolution: the resolution of the imageoptions: bit-coded:bit0 set (1): the provided image is rgba, otherwise it is rgbbit1 set (2): the image will be flipped on its x-axisbit2 set (4): the image will be flipped on its y-axisfloatParams: Reserved for future extension. Set to NULL.intParams: Reserved for future extension. Set to NULL.reserved: Reserved for future extension. Set to NULL.image: a pointer to rgb or rgba values of the imageresolution: the resolution of the imageoptions: bit-coded:bit0 set (1): the provided image is rgba, otherwise it is rgbbit1 set (2): the image will be flipped on its x-axisbit2 set (4): the image will be flipped on its y-axisfloatParams: Reserved for future extension. Set to NULL.intParams: Reserved for future extension. Set to NULL.reserved: Reserved for future extension. Set to NULL. -1 if operation was not successful."
    }, 
    "sim.shapeintparam_respondable_mask": {
        "body": "sim.shapeintparam_respondable_mask", 
        "scope": "source.lua", 
        "prefix": "sim.shapeintparam_respondable_mask", 
        "description": "Constants"
    }, 
    "sim.boolparam_distance_handling_enabled": {
        "body": "sim.boolparam_distance_handling_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_distance_handling_enabled", 
        "description": "Constants"
    }, 
    "simCHAI3D.updateConstraint": {
        "body": "simCHAI3D.updateConstraint(${0:objectID},${1:positionA},${2:positionB},${3:Kp},${4:Kv},${5:Fmax})", 
        "scope": "source.lua", 
        "prefix": "simCHAI3D.updateConstraint", 
        "description": "simCHAI3D.updateConstraint(number objectID,table_3 positionA,table_3 positionB,number Kp,number Kv,number Fmax)"
    }, 
    "sim.setFloatSignal": {
        "body": "sim.setFloatSignal(${0:signalName},${1:signalValue})", 
        "scope": "source.lua", 
        "prefix": "sim.setFloatSignal", 
        "description": "number result = sim.setFloatSignal(string signalName,number signalValue)Sets the value of a float signal. If that signal is not yet present, it is added. Signals created in the main script or in a child script are automatically cleared at simulation end. See also sim.getFloatSignal, the other signal functions,  and sim.persistentDataWrite. signalName: name of the signalsignalValue: value of the signalsignalName: name of the signalsignalValue: value of the signalsignalName: name of the signalsignalValue: value of the signal -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simx.opmode_buffer": {
        "body": "simx.opmode_buffer", 
        "scope": "source.lua", 
        "prefix": "simx.opmode_buffer", 
        "description": "Constants"
    }, 
    "sim.vortex_body_convexshapesasrandom": {
        "body": "sim.vortex_body_convexshapesasrandom", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_convexshapesasrandom", 
        "description": "Constants"
    }, 
    "sim.handleflag_assembly": {
        "body": "sim.handleflag_assembly", 
        "scope": "source.lua", 
        "prefix": "sim.handleflag_assembly", 
        "description": "Constants"
    }, 
    "sim.scripttype_generalcallback": {
        "body": "sim.scripttype_generalcallback", 
        "scope": "source.lua", 
        "prefix": "sim.scripttype_generalcallback", 
        "description": "Constants"
    }, 
    "simUI.curve_style.step_left": {
        "body": "simUI.curve_style.step_left", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_style.step_left", 
        "description": "Constants"
    }, 
    "sim.getThreadAutomaticSwitch": {
        "body": "sim.getThreadAutomaticSwitch()", 
        "scope": "source.lua", 
        "prefix": "sim.getThreadAutomaticSwitch", 
        "description": "boolean result = sim.getThreadAutomaticSwitch()Queries whether the current thread will eventually automatically switch to another thread. If the current script doesn't run in a thread (i.e. if it runs in the application main thread), this function always return false. See also sim.setThreadAutomaticSwitch. - -"
    }, 
    "simx.getCollectionHandle": {
        "body": "simx.getCollectionHandle(${0:clientId},${1:collectionName})", 
        "scope": "source.lua", 
        "prefix": "simx.getCollectionHandle", 
        "description": "number returnCode,number collectionHandle= simx.getCollectionHandle(number clientId,string collectionName)Retrieves a collection handle based on its name. If the client application is launched from a child script, then you could also let the child script figure out what handle correspond to what collection, and send the handles as additional arguments to the client application during its launch. See also simx.getObjectGroupData. clientID: the client ID. refer to simx.start.collectionName: name of the collection. If possibe, don't rely on the automatic name adjustment mechanism, and always specify the full collection name, including the #: if the collection is myCollection, specify myCollection#, if the collection is myCollection#0, specify myCollection#0, etc.operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return codehandle: the handle"
    }, 
    "sim.moveToObject": {
        "body": "sim.moveToObject(${0:objectHandle},${1:targetObjectHandle},${2:positionAndOrOrientation},${3:relativeDistanceOnPath},${4:velocity},${5:accel})", 
        "scope": "source.lua", 
        "prefix": "sim.moveToObject", 
        "description": "number deltaTimeLeft = sim.moveToObject(number objectHandle,number targetObjectHandle,number positionAndOrOrientation,number relativeDistanceOnPath,number velocity,number accel)Moves an object to the position/orientation of another moving object (target object) by performing interpolations (i.e. the object will effectiviely follow the target object). If the target object is a path, a position on the path can be specified. If the target object is not moving, use rather sim.getObjectPosition, sim.getObjectOrientation or sim.getPositionOnPath, sim.getOrientationOnPath in conjunction with sim.rmlMoveToPosition. This function can only be called from child scripts running in a thread (since this is a blocking operation) and is not available from the C-API. See also sim.followPath. - -"
    }, 
    "sim.bullet_constraintsolvertype_dantzig": {
        "body": "sim.bullet_constraintsolvertype_dantzig", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_constraintsolvertype_dantzig", 
        "description": "Constants"
    }, 
    "simOMPL.StateSpaceType.pose2d": {
        "body": "simOMPL.StateSpaceType.pose2d", 
        "scope": "source.lua", 
        "prefix": "simOMPL.StateSpaceType.pose2d", 
        "description": "Constants"
    }, 
    "sim.callbackid_rossubscriber": {
        "body": "sim.callbackid_rossubscriber", 
        "scope": "source.lua", 
        "prefix": "sim.callbackid_rossubscriber", 
        "description": "Constants"
    }, 
    "sim.boolparam_collision_handling_enabled": {
        "body": "sim.boolparam_collision_handling_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_collision_handling_enabled", 
        "description": "Constants"
    }, 
    "simRRS1.SET_INTERPOLATION_TIME": {
        "body": "simRRS1.SET_INTERPOLATION_TIME(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_INTERPOLATION_TIME", 
        "description": "int status= simRRS1.SET_INTERPOLATION_TIME(bitstring2 rcsHandle)"
    }, 
    "sim.boolparam_threaded_rendering_enabled": {
        "body": "sim.boolparam_threaded_rendering_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_threaded_rendering_enabled", 
        "description": "Constants"
    }, 
    "sim.getJointMatrix": {
        "body": "sim.getJointMatrix(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getJointMatrix", 
        "description": "table_12 matrix = sim.getJointMatrix(number objectHandle)Retrieves the intrinsic transformation matrix of a joint (the transformation caused by the joint movement). See also sim.setSphericalJointMatrix. objectHandle: handle of the jointmatrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11])objectHandle: handle of the jointmatrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11])objectHandle: handle of the jointmatrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11])objectHandle: handle of the jointmatrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11])objectHandle: handle of the jointmatrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11])objectHandle: handle of the jointmatrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11]) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "assert": {
        "body": "assert(${1:v}${2:[, message]})", 
        "scope": "source.lua", 
        "prefix": "assert", 
        "description": "5.1,5.2,5.3\n\nassert()"
    }, 
    "file:read": {
        "body": "file:read(${0:...})", 
        "scope": "source.lua", 
        "prefix": "file:read", 
        "description": "5.1,5.2,5.3\n\nfile:read (...)"
    }, 
    "coroutine.status": {
        "body": "coroutine.status( ${1:co} )", 
        "scope": "source.lua", 
        "prefix": "coroutine.status", 
        "description": "5.1,5.2,5.3\n\ncoroutine.status"
    }, 
    "sim.setInt32Parameter": {
        "body": "sim.setInt32Parameter(${0:parameter},${1:intState})", 
        "scope": "source.lua", 
        "prefix": "sim.setInt32Parameter", 
        "description": "number result = sim.setInt32Parameter(number parameter,number intState)Sets an integer parameter. See also sim.getInt32Parameter, sim.setBoolParameter, sim.setArrayParameter and sim.setFloatParameter. parameter: integer parameter identifierintState: new state for the parameterparameter: integer parameter identifierintState: new state for the parameterparameter: integer parameter identifierintState: new state for the parameter -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.arrayparam_fog": {
        "body": "sim.arrayparam_fog", 
        "scope": "source.lua", 
        "prefix": "sim.arrayparam_fog", 
        "description": "Constants"
    }, 
    "sim.banner_fullyfacingcamera": {
        "body": "sim.banner_fullyfacingcamera", 
        "scope": "source.lua", 
        "prefix": "sim.banner_fullyfacingcamera", 
        "description": "Constants"
    }, 
    "simUI.setComboboxSelectedIndex": {
        "body": "simUI.setComboboxSelectedIndex(${0:handle},${1:id},${2:index},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setComboboxSelectedIndex", 
        "description": "simUI.setComboboxSelectedIndex(number handle,number id,number index,bool suppressEvents=true)"
    }, 
    "simUI.growPlotRanges": {
        "body": "simUI.growPlotRanges(${0:handle},${1:id},${2:xmin},${3:xmax},${4:ymin},${5:ymax})", 
        "scope": "source.lua", 
        "prefix": "simUI.growPlotRanges", 
        "description": "simUI.growPlotRanges(number handle,number id,number xmin,number xmax,number ymin,number ymax)"
    }, 
    "sim.drawing_backfaceculling": {
        "body": "sim.drawing_backfaceculling", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_backfaceculling", 
        "description": "Constants"
    }, 
    "sim.vortex_bodyfrictionmodel_scaledbox": {
        "body": "sim.vortex_bodyfrictionmodel_scaledbox", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_bodyfrictionmodel_scaledbox", 
        "description": "Constants"
    }, 
    "sim.customizationscriptcall_lastbeforeinstanceswitch": {
        "body": "sim.customizationscriptcall_lastbeforeinstanceswitch", 
        "scope": "source.lua", 
        "prefix": "sim.customizationscriptcall_lastbeforeinstanceswitch", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_swapwithbuffer1": {
        "body": "sim.filtercomponent_swapwithbuffer1", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_swapwithbuffer1", 
        "description": "Constants"
    }, 
    "sim.setCollectionName": {
        "body": "sim.setCollectionName(${0:collectionHandle},${1:collectionName})", 
        "scope": "source.lua", 
        "prefix": "sim.setCollectionName", 
        "description": "number result = sim.setCollectionName(number collectionHandle,string collectionName)Sets the name of a collection based on its handle. See also sim.getCollectionName. collectionHandle: handle of the collectioncollectionName: new name of the collectioncollectionHandle: handle of the collectioncollectionName: new name of the collectioncollectionHandle: handle of the collectioncollectionName: new name of the collection -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.vortex_body_primangulararaxisfrictionmodel": {
        "body": "sim.vortex_body_primangulararaxisfrictionmodel", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_primangulararaxisfrictionmodel", 
        "description": "Constants"
    }, 
    "sim.shapefloatparam_edge_angle": {
        "body": "sim.shapefloatparam_edge_angle", 
        "scope": "source.lua", 
        "prefix": "sim.shapefloatparam_edge_angle", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_blobextraction": {
        "body": "sim.filtercomponent_blobextraction", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_blobextraction", 
        "description": "Constants"
    }, 
    "table.maxn": {
        "body": "table.maxn(${0:...})", 
        "scope": "source.lua", 
        "prefix": "table.maxn", 
        "description": "5.1\n\ntable.maxn (table)"
    }, 
    "simOMPL.setValidStateSamplerCallback": {
        "body": "simOMPL.setValidStateSamplerCallback(${0:taskHandle},${1:callback},${2:callbackNear})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.setValidStateSamplerCallback", 
        "description": "number result = simOMPL.setValidStateSamplerCallback(number taskHandle,string callback,string callbackNear)"
    }, 
    "sim.scriptthreadresume_sensing_first": {
        "body": "sim.scriptthreadresume_sensing_first", 
        "scope": "source.lua", 
        "prefix": "sim.scriptthreadresume_sensing_first", 
        "description": "Constants"
    }, 
    "sim.resetDynamicObject": {
        "body": "sim.resetDynamicObject(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.resetDynamicObject", 
        "description": "number result = sim.resetDynamicObject(number objectHandle)Dynamically resets an object that is dynamically simulated. This means that the object representation in the dynamics engine is removed, and added again. This can be useful when the set-up of a dynamically simulated chain needs to be modified during simulation (e.g. joint or shape attachement position/orientation changed). It should be noted that calling this on a dynamically simulated object might slightly change its position/orientation relative to its parent (since the object will be disconnected from the dynamics world in its current position/orientation), so the user is in charge of rectifying for that. objectHandle: handle of the object or sim_handle_all (to reset all dynamic content in the scene). objectHandle can be combined with sim_handleflag_model, if you wish to reset all objects in a model (where objectHandle would be the model base).objectHandle: handle of the object or sim_handle_all (to reset all dynamic content in the scene). objectHandle can be combined with sim_handleflag_model, if you wish to reset all objects in a model (where objectHandle would be the model base). -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.shapefloatparam_texture_b": {
        "body": "sim.shapefloatparam_texture_b", 
        "scope": "source.lua", 
        "prefix": "sim.shapefloatparam_texture_b", 
        "description": "Constants"
    }, 
    "sim.dlgstyle_yes_no": {
        "body": "sim.dlgstyle_yes_no", 
        "scope": "source.lua", 
        "prefix": "sim.dlgstyle_yes_no", 
        "description": "Constants"
    }, 
    "sim.displayattribute_ignorerenderableflag": {
        "body": "sim.displayattribute_ignorerenderableflag", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_ignorerenderableflag", 
        "description": "Constants"
    }, 
    "sim.setGraphUserData": {
        "body": "sim.setGraphUserData(${0:graphHandle},${1:dataStreamName},${2:data})", 
        "scope": "source.lua", 
        "prefix": "sim.setGraphUserData", 
        "description": "number result = sim.setGraphUserData(number graphHandle,string dataStreamName,number data)Sets one value in a user-defined graph data stream. See also sim.resetGraph and sim.handleGraph. graphHandle: handle of the graph objectdataStreamName: the name of the data stream. The data stream must be of type user-defineddata: the value to set. If, for a given simulation step this function is not called for a user-defined data stream, then the data will be missing for that simulation step.graphHandle: handle of the graph objectdataStreamName: the name of the data stream. The data stream must be of type user-defineddata: the value to set. If, for a given simulation step this function is not called for a user-defined data stream, then the data will be missing for that simulation step.graphHandle: handle of the graph objectdataStreamName: the name of the data stream. The data stream must be of type user-defineddata: the value to set. If, for a given simulation step this function is not called for a user-defined data stream, then the data will be missing for that simulation step.graphHandle: handle of the graph objectdataStreamName: the name of the data stream. The data stream must be of type user-defineddata: the value to set. If, for a given simulation step this function is not called for a user-defined data stream, then the data will be missing for that simulation step. -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simRRS1.GET_FORWARD_KINEMATIC": {
        "body": "simRRS1.GET_FORWARD_KINEMATIC(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.GET_FORWARD_KINEMATIC", 
        "description": "int status,cartPosType cartPos,jointPosType jointPos,string configuration,bitString jointLimit,int numberOfMessages= simRRS1.GET_FORWARD_KINEMATIC(bitstring2 rcsHandle)"
    }, 
    "simOMPL.createStateSpace": {
        "body": "simOMPL.createStateSpace(${0:name},${1:type},${2:objectHandle},${3:boundsLow},${4:boundsHigh},${5:useForProjection},${6:weight=1.0},${7:refObjectHandle=-1})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.createStateSpace", 
        "description": "number stateSpaceHandle = simOMPL.createStateSpace(string name,number type,number objectHandle,table boundsLow,table boundsHigh,number useForProjection,number weight=1.0,number refObjectHandle=-1)"
    }, 
    "sim.particle_points4": {
        "body": "sim.particle_points4", 
        "scope": "source.lua", 
        "prefix": "sim.particle_points4", 
        "description": "Constants"
    }, 
    "simUI.setSize": {
        "body": "simUI.setSize(${0:handle},${1:w},${2:h},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setSize", 
        "description": "simUI.setSize(number handle,number w,number h,bool suppressEvents=true)"
    }, 
    "sim.particle_points1": {
        "body": "sim.particle_points1", 
        "scope": "source.lua", 
        "prefix": "sim.particle_points1", 
        "description": "Constants"
    }, 
    "sim.getVisionSensorResolution": {
        "body": "sim.getVisionSensorResolution(${0:sensorHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getVisionSensorResolution", 
        "description": "table_2 resolution = sim.getVisionSensorResolution(number sensorHandle)Retrieves the resolution at which the given vision sensor operates (this might be different from what is indicated in the vision sensor dialog: should your graphic card model be rather old, then only resolutions a 2n will be supported). Useful in combination with sim.getVisionSensorImage/sim.getVisionSensorDepthBuffer sensorHandle: handle of the vision sensorresolution: 2 values for the x and y componentsensorHandle: handle of the vision sensorresolution: 2 values for the x and y componentsensorHandle: handle of the vision sensorresolution: 2 values for the x and y component -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.filtercomponent_correlationwithbuffer1": {
        "body": "sim.filtercomponent_correlationwithbuffer1", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_correlationwithbuffer1", 
        "description": "Constants"
    }, 
    "sim.particle_points2": {
        "body": "sim.particle_points2", 
        "scope": "source.lua", 
        "prefix": "sim.particle_points2", 
        "description": "Constants"
    }, 
    "sim.endDialog": {
        "body": "sim.endDialog(${0:genericDlgHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.endDialog", 
        "description": "number result = sim.endDialog(number genericDlgHandle)Closes and releases resource from a previous call to sim.displayDialog. Even if the dialog is not visible anymore, you should release resources by using this function (however at the end of a simulation, all dialog resources allocated from a main script or a child script are automatically released). genericDialogHandle: handle of generic dialog (return value of simDisplayDialog)genericDialogHandle: handle of generic dialog (return value of simDisplayDialog) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.scripttype_addonfunction": {
        "body": "sim.scripttype_addonfunction", 
        "scope": "source.lua", 
        "prefix": "sim.scripttype_addonfunction", 
        "description": "Constants"
    }, 
    "sim.dlgstyle_ok_cancel": {
        "body": "sim.dlgstyle_ok_cancel", 
        "scope": "source.lua", 
        "prefix": "sim.dlgstyle_ok_cancel", 
        "description": "Constants"
    }, 
    "sim.setShapeTexture": {
        "body": "sim.setShapeTexture(${0:shapeHandle},${1:textureId},${2:mappingMode},${3:options},${4:uvScaling},${5:position=nil},${6:orientation=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.setShapeTexture", 
        "description": "number result = sim.setShapeTexture(number shapeHandle,number textureId,number mappingMode,number options,table_2 uvScaling,table_3 position=nil,table_3 orientation=nil)Applies (or removes) a texture to a shape. See also sim.getTextureId, sim.getShapeTextureId and sim.createTexture. shapeHandle: the handle of the shape.textureId: the ID of the texture or -1 to remove any existing texture. See also simGetTextureId, simGetShapeTextureId and simCreateTexture.mappingMode: the texture mapping mode.options: bit-coded:bit0: if set (1), then adjacent texture pixels are not interpolated.bit1:  if set (2), then the texture is applied as a decal (its appearance won't be influenced by light conditions).bit2: if set (4), then the texture will be repeated along the U direction.bit3: if set (8), then the texture will be repeated along the V direction.uvScaling: a pointer to 2 values that indicate the texture scaling factors along the U and V directions.position: a pointer to 3 values (x,y,z) that indicate the texture position on the shape. Can be NULL for default values.orientation: a pointer to 3 values (Euler angles) that indicate the texture orientation on the shape. Can be NULL for default values.shapeHandle: the handle of the shape.textureId: the ID of the texture or -1 to remove any existing texture. See also simGetTextureId, simGetShapeTextureId and simCreateTexture.mappingMode: the texture mapping mode.options: bit-coded:bit0: if set (1), then adjacent texture pixels are not interpolated.bit1:  if set (2), then the texture is applied as a decal (its appearance won't be influenced by light conditions).bit2: if set (4), then the texture will be repeated along the U direction.bit3: if set (8), then the texture will be repeated along the V direction.uvScaling: a pointer to 2 values that indicate the texture scaling factors along the U and V directions.position: a pointer to 3 values (x,y,z) that indicate the texture position on the shape. Can be NULL for default values.orientation: a pointer to 3 values (Euler angles) that indicate the texture orientation on the shape. Can be NULL for default values.shapeHandle: the handle of the shape.textureId: the ID of the texture or -1 to remove any existing texture. See also simGetTextureId, simGetShapeTextureId and simCreateTexture.mappingMode: the texture mapping mode.options: bit-coded:bit0: if set (1), then adjacent texture pixels are not interpolated.bit1:  if set (2), then the texture is applied as a decal (its appearance won't be influenced by light conditions).bit2: if set (4), then the texture will be repeated along the U direction.bit3: if set (8), then the texture will be repeated along the V direction.uvScaling: a pointer to 2 values that indicate the texture scaling factors along the U and V directions.position: a pointer to 3 values (x,y,z) that indicate the texture position on the shape. Can be NULL for default values.orientation: a pointer to 3 values (Euler angles) that indicate the texture orientation on the shape. Can be NULL for default values.shapeHandle: the handle of the shape.textureId: the ID of the texture or -1 to remove any existing texture. See also simGetTextureId, simGetShapeTextureId and simCreateTexture.mappingMode: the texture mapping mode.options: bit-coded:bit0: if set (1), then adjacent texture pixels are not interpolated.bit1:  if set (2), then the texture is applied as a decal (its appearance won't be influenced by light conditions).bit2: if set (4), then the texture will be repeated along the U direction.bit3: if set (8), then the texture will be repeated along the V direction.uvScaling: a pointer to 2 values that indicate the texture scaling factors along the U and V directions.position: a pointer to 3 values (x,y,z) that indicate the texture position on the shape. Can be NULL for default values.orientation: a pointer to 3 values (Euler angles) that indicate the texture orientation on the shape. Can be NULL for default values.shapeHandle: the handle of the shape.textureId: the ID of the texture or -1 to remove any existing texture. See also simGetTextureId, simGetShapeTextureId and simCreateTexture.mappingMode: the texture mapping mode.options: bit-coded:bit0: if set (1), then adjacent texture pixels are not interpolated.bit1:  if set (2), then the texture is applied as a decal (its appearance won't be influenced by light conditions).bit2: if set (4), then the texture will be repeated along the U direction.bit3: if set (8), then the texture will be repeated along the V direction.uvScaling: a pointer to 2 values that indicate the texture scaling factors along the U and V directions.position: a pointer to 3 values (x,y,z) that indicate the texture position on the shape. Can be NULL for default values.orientation: a pointer to 3 values (Euler angles) that indicate the texture orientation on the shape. Can be NULL for default values.shapeHandle: the handle of the shape.textureId: the ID of the texture or -1 to remove any existing texture. See also simGetTextureId, simGetShapeTextureId and simCreateTexture.mappingMode: the texture mapping mode.options: bit-coded:bit0: if set (1), then adjacent texture pixels are not interpolated.bit1:  if set (2), then the texture is applied as a decal (its appearance won't be influenced by light conditions).bit2: if set (4), then the texture will be repeated along the U direction.bit3: if set (8), then the texture will be repeated along the V direction.uvScaling: a pointer to 2 values that indicate the texture scaling factors along the U and V directions.position: a pointer to 3 values (x,y,z) that indicate the texture position on the shape. Can be NULL for default values.orientation: a pointer to 3 values (Euler angles) that indicate the texture orientation on the shape. Can be NULL for default values.shapeHandle: the handle of the shape.textureId: the ID of the texture or -1 to remove any existing texture. See also simGetTextureId, simGetShapeTextureId and simCreateTexture.mappingMode: the texture mapping mode.options: bit-coded:bit0: if set (1), then adjacent texture pixels are not interpolated.bit1:  if set (2), then the texture is applied as a decal (its appearance won't be influenced by light conditions).bit2: if set (4), then the texture will be repeated along the U direction.bit3: if set (8), then the texture will be repeated along the V direction.uvScaling: a pointer to 2 values that indicate the texture scaling factors along the U and V directions.position: a pointer to 3 values (x,y,z) that indicate the texture position on the shape. Can be NULL for default values.orientation: a pointer to 3 values (Euler angles) that indicate the texture orientation on the shape. Can be NULL for default values.shapeHandle: the handle of the shape.textureId: the ID of the texture or -1 to remove any existing texture. See also simGetTextureId, simGetShapeTextureId and simCreateTexture.mappingMode: the texture mapping mode.options: bit-coded:bit0: if set (1), then adjacent texture pixels are not interpolated.bit1:  if set (2), then the texture is applied as a decal (its appearance won't be influenced by light conditions).bit2: if set (4), then the texture will be repeated along the U direction.bit3: if set (8), then the texture will be repeated along the V direction.uvScaling: a pointer to 2 values that indicate the texture scaling factors along the U and V directions.position: a pointer to 3 values (x,y,z) that indicate the texture position on the shape. Can be NULL for default values.orientation: a pointer to 3 values (Euler angles) that indicate the texture orientation on the shape. Can be NULL for default values.shapeHandle: the handle of the shape.textureId: the ID of the texture or -1 to remove any existing texture. See also simGetTextureId, simGetShapeTextureId and simCreateTexture.mappingMode: the texture mapping mode.options: bit-coded:bit0: if set (1), then adjacent texture pixels are not interpolated.bit1:  if set (2), then the texture is applied as a decal (its appearance won't be influenced by light conditions).bit2: if set (4), then the texture will be repeated along the U direction.bit3: if set (8), then the texture will be repeated along the V direction.uvScaling: a pointer to 2 values that indicate the texture scaling factors along the U and V directions.position: a pointer to 3 values (x,y,z) that indicate the texture position on the shape. Can be NULL for default values.orientation: a pointer to 3 values (Euler angles) that indicate the texture orientation on the shape. Can be NULL for default values.shapeHandle: the handle of the shape.textureId: the ID of the texture or -1 to remove any existing texture. See also simGetTextureId, simGetShapeTextureId and simCreateTexture.mappingMode: the texture mapping mode.options: bit-coded:bit0: if set (1), then adjacent texture pixels are not interpolated.bit1:  if set (2), then the texture is applied as a decal (its appearance won't be influenced by light conditions).bit2: if set (4), then the texture will be repeated along the U direction.bit3: if set (8), then the texture will be repeated along the V direction.uvScaling: a pointer to 2 values that indicate the texture scaling factors along the U and V directions.position: a pointer to 3 values (x,y,z) that indicate the texture position on the shape. Can be NULL for default values.orientation: a pointer to 3 values (Euler angles) that indicate the texture orientation on the shape. Can be NULL for default values.shapeHandle: the handle of the shape.textureId: the ID of the texture or -1 to remove any existing texture. See also simGetTextureId, simGetShapeTextureId and simCreateTexture.mappingMode: the texture mapping mode.options: bit-coded:bit0: if set (1), then adjacent texture pixels are not interpolated.bit1:  if set (2), then the texture is applied as a decal (its appearance won't be influenced by light conditions).bit2: if set (4), then the texture will be repeated along the U direction.bit3: if set (8), then the texture will be repeated along the V direction.uvScaling: a pointer to 2 values that indicate the texture scaling factors along the U and V directions.position: a pointer to 3 values (x,y,z) that indicate the texture position on the shape. Can be NULL for default values.orientation: a pointer to 3 values (Euler angles) that indicate the texture orientation on the shape. Can be NULL for default values. -1 in case of an error."
    }, 
    "sim.getObjectMatrix": {
        "body": "sim.getObjectMatrix(${0:objectHandle},${1:relativeToObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectMatrix", 
        "description": "table_12 matrix = sim.getObjectMatrix(number objectHandle,number relativeToObjectHandle)Retrieves the transformation matrix of an object. See also sim.setObjectMatrix, sim.getObjectPosition, sim.getObjectOrientation and the other matrix/transformation functions. objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the matrix. Specify -1 to retrieve the absolute transformation matrix, sim_handle_parent to retrieve the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame we want the transformation matrix.matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11])objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the matrix. Specify -1 to retrieve the absolute transformation matrix, sim_handle_parent to retrieve the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame we want the transformation matrix.matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11])objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the matrix. Specify -1 to retrieve the absolute transformation matrix, sim_handle_parent to retrieve the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame we want the transformation matrix.matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11])objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the matrix. Specify -1 to retrieve the absolute transformation matrix, sim_handle_parent to retrieve the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame we want the transformation matrix.matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11])objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the matrix. Specify -1 to retrieve the absolute transformation matrix, sim_handle_parent to retrieve the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame we want the transformation matrix.matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11])objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the matrix. Specify -1 to retrieve the absolute transformation matrix, sim_handle_parent to retrieve the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame we want the transformation matrix.matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11])objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the matrix. Specify -1 to retrieve the absolute transformation matrix, sim_handle_parent to retrieve the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame we want the transformation matrix.matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11]) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.vortex_bodyfrictionmodel_scaledboxfast": {
        "body": "sim.vortex_bodyfrictionmodel_scaledboxfast", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_bodyfrictionmodel_scaledboxfast", 
        "description": "Constants"
    }, 
    "sim.handle_parent": {
        "body": "sim.handle_parent", 
        "scope": "source.lua", 
        "prefix": "sim.handle_parent", 
        "description": "Constants"
    }, 
    "sim.setObjectSpecialProperty": {
        "body": "sim.setObjectSpecialProperty(${0:objectHandle},${1:property})", 
        "scope": "source.lua", 
        "prefix": "sim.setObjectSpecialProperty", 
        "description": "number result = sim.setObjectSpecialProperty(number objectHandle,number property)Sets the special properties of a scene object. See also sim.getObjectSpecialProperty, sim.setObjectProperty and sim.setModelProperty. objectHandle: object handleprop: object special property. See the object special property values. Combine them with the or-operatorobjectHandle: object handleprop: object special property. See the object special property values. Combine them with the or-operatorobjectHandle: object handleprop: object special property. See the object special property values. Combine them with the or-operator -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.insertPathCtrlPoints": {
        "body": "sim.insertPathCtrlPoints(${0:pathHandle},${1:options},${2:startIndex},${3:ptCnt},${4:ptData})", 
        "scope": "source.lua", 
        "prefix": "sim.insertPathCtrlPoints", 
        "description": "number result = sim.insertPathCtrlPoints(number pathHandle,number options,number startIndex,number ptCnt,table ptData)Inserts one or several control points into a path object. See also sim.cutPathCtrlPoints and sim.createPath. pathHandle: the handle of the path. Refer also to simGetObjectHandle.options: bit-coded:bit0: if set (1), then the path will be closed (given that there are enough control points in the path)bit1: if set (2), then the expected value count (valCnt) for each point will be 16 instead of 11 (see further down)startIndex: the zero-based index where the first new control point should be inserted.ptCnt: the number of control points to insert.ptData (input): a buffer of ptCnt*valCnt values (float or int). ValCnt is 16 if bit1 of options is set, otherwise 11. Each new control point should have its properties described with following valCnt values:ptData[0]-ptData[2] (float values): the position of the control point (x,y,z), relative to the path objectptData[3]-ptData[5] (float values): the orientation of the control point in Euler angles (alpha,beta,gamma), relative to the path objectptData[6] (float value): the relative velocity at the control pointptData[7] (float value): the virtual distance at the control pointptData[8] (int value): the number of Bezier points at the control pointptData[9] (float value): the Bezier interpolation factor 1 at the control pointptData[10] (float value): the Bezier interpolation factor 2 at the control pointptData[11] (int value): the auxiliary flags at the control pointptData[12]-ptData[15] (float values): the 4 auxiliary values at the control pointpathHandle: the handle of the path. Refer also to simGetObjectHandle.options: bit-coded:bit0: if set (1), then the path will be closed (given that there are enough control points in the path)bit1: if set (2), then the expected value count (valCnt) for each point will be 16 instead of 11 (see further down)startIndex: the zero-based index where the first new control point should be inserted.ptCnt: the number of control points to insert.ptData (input): a buffer of ptCnt*valCnt values (float or int). ValCnt is 16 if bit1 of options is set, otherwise 11. Each new control point should have its properties described with following valCnt values:ptData[0]-ptData[2] (float values): the position of the control point (x,y,z), relative to the path objectptData[3]-ptData[5] (float values): the orientation of the control point in Euler angles (alpha,beta,gamma), relative to the path objectptData[6] (float value): the relative velocity at the control pointptData[7] (float value): the virtual distance at the control pointptData[8] (int value): the number of Bezier points at the control pointptData[9] (float value): the Bezier interpolation factor 1 at the control pointptData[10] (float value): the Bezier interpolation factor 2 at the control pointptData[11] (int value): the auxiliary flags at the control pointptData[12]-ptData[15] (float values): the 4 auxiliary values at the control pointpathHandle: the handle of the path. Refer also to simGetObjectHandle.options: bit-coded:bit0: if set (1), then the path will be closed (given that there are enough control points in the path)bit1: if set (2), then the expected value count (valCnt) for each point will be 16 instead of 11 (see further down)startIndex: the zero-based index where the first new control point should be inserted.ptCnt: the number of control points to insert.ptData (input): a buffer of ptCnt*valCnt values (float or int). ValCnt is 16 if bit1 of options is set, otherwise 11. Each new control point should have its properties described with following valCnt values:ptData[0]-ptData[2] (float values): the position of the control point (x,y,z), relative to the path objectptData[3]-ptData[5] (float values): the orientation of the control point in Euler angles (alpha,beta,gamma), relative to the path objectptData[6] (float value): the relative velocity at the control pointptData[7] (float value): the virtual distance at the control pointptData[8] (int value): the number of Bezier points at the control pointptData[9] (float value): the Bezier interpolation factor 1 at the control pointptData[10] (float value): the Bezier interpolation factor 2 at the control pointptData[11] (int value): the auxiliary flags at the control pointptData[12]-ptData[15] (float values): the 4 auxiliary values at the control pointpathHandle: the handle of the path. Refer also to simGetObjectHandle.options: bit-coded:bit0: if set (1), then the path will be closed (given that there are enough control points in the path)bit1: if set (2), then the expected value count (valCnt) for each point will be 16 instead of 11 (see further down)startIndex: the zero-based index where the first new control point should be inserted.ptCnt: the number of control points to insert.ptData (input): a buffer of ptCnt*valCnt values (float or int). ValCnt is 16 if bit1 of options is set, otherwise 11. Each new control point should have its properties described with following valCnt values:ptData[0]-ptData[2] (float values): the position of the control point (x,y,z), relative to the path objectptData[3]-ptData[5] (float values): the orientation of the control point in Euler angles (alpha,beta,gamma), relative to the path objectptData[6] (float value): the relative velocity at the control pointptData[7] (float value): the virtual distance at the control pointptData[8] (int value): the number of Bezier points at the control pointptData[9] (float value): the Bezier interpolation factor 1 at the control pointptData[10] (float value): the Bezier interpolation factor 2 at the control pointptData[11] (int value): the auxiliary flags at the control pointptData[12]-ptData[15] (float values): the 4 auxiliary values at the control pointpathHandle: the handle of the path. Refer also to simGetObjectHandle.options: bit-coded:bit0: if set (1), then the path will be closed (given that there are enough control points in the path)bit1: if set (2), then the expected value count (valCnt) for each point will be 16 instead of 11 (see further down)startIndex: the zero-based index where the first new control point should be inserted.ptCnt: the number of control points to insert.ptData (input): a buffer of ptCnt*valCnt values (float or int). ValCnt is 16 if bit1 of options is set, otherwise 11. Each new control point should have its properties described with following valCnt values:ptData[0]-ptData[2] (float values): the position of the control point (x,y,z), relative to the path objectptData[3]-ptData[5] (float values): the orientation of the control point in Euler angles (alpha,beta,gamma), relative to the path objectptData[6] (float value): the relative velocity at the control pointptData[7] (float value): the virtual distance at the control pointptData[8] (int value): the number of Bezier points at the control pointptData[9] (float value): the Bezier interpolation factor 1 at the control pointptData[10] (float value): the Bezier interpolation factor 2 at the control pointptData[11] (int value): the auxiliary flags at the control pointptData[12]-ptData[15] (float values): the 4 auxiliary values at the control pointpathHandle: the handle of the path. Refer also to simGetObjectHandle.options: bit-coded:bit0: if set (1), then the path will be closed (given that there are enough control points in the path)bit1: if set (2), then the expected value count (valCnt) for each point will be 16 instead of 11 (see further down)startIndex: the zero-based index where the first new control point should be inserted.ptCnt: the number of control points to insert.ptData (input): a buffer of ptCnt*valCnt values (float or int). ValCnt is 16 if bit1 of options is set, otherwise 11. Each new control point should have its properties described with following valCnt values:ptData[0]-ptData[2] (float values): the position of the control point (x,y,z), relative to the path objectptData[3]-ptData[5] (float values): the orientation of the control point in Euler angles (alpha,beta,gamma), relative to the path objectptData[6] (float value): the relative velocity at the control pointptData[7] (float value): the virtual distance at the control pointptData[8] (int value): the number of Bezier points at the control pointptData[9] (float value): the Bezier interpolation factor 1 at the control pointptData[10] (float value): the Bezier interpolation factor 2 at the control pointptData[11] (int value): the auxiliary flags at the control pointptData[12]-ptData[15] (float values): the 4 auxiliary values at the control pointpathHandle: the handle of the path. Refer also to simGetObjectHandle.options: bit-coded:bit0: if set (1), then the path will be closed (given that there are enough control points in the path)bit1: if set (2), then the expected value count (valCnt) for each point will be 16 instead of 11 (see further down)startIndex: the zero-based index where the first new control point should be inserted.ptCnt: the number of control points to insert.ptData (input): a buffer of ptCnt*valCnt values (float or int). ValCnt is 16 if bit1 of options is set, otherwise 11. Each new control point should have its properties described with following valCnt values:ptData[0]-ptData[2] (float values): the position of the control point (x,y,z), relative to the path objectptData[3]-ptData[5] (float values): the orientation of the control point in Euler angles (alpha,beta,gamma), relative to the path objectptData[6] (float value): the relative velocity at the control pointptData[7] (float value): the virtual distance at the control pointptData[8] (int value): the number of Bezier points at the control pointptData[9] (float value): the Bezier interpolation factor 1 at the control pointptData[10] (float value): the Bezier interpolation factor 2 at the control pointptData[11] (int value): the auxiliary flags at the control pointptData[12]-ptData[15] (float values): the 4 auxiliary values at the control pointpathHandle: the handle of the path. Refer also to simGetObjectHandle.options: bit-coded:bit0: if set (1), then the path will be closed (given that there are enough control points in the path)bit1: if set (2), then the expected value count (valCnt) for each point will be 16 instead of 11 (see further down)startIndex: the zero-based index where the first new control point should be inserted.ptCnt: the number of control points to insert.ptData (input): a buffer of ptCnt*valCnt values (float or int). ValCnt is 16 if bit1 of options is set, otherwise 11. Each new control point should have its properties described with following valCnt values:ptData[0]-ptData[2] (float values): the position of the control point (x,y,z), relative to the path objectptData[3]-ptData[5] (float values): the orientation of the control point in Euler angles (alpha,beta,gamma), relative to the path objectptData[6] (float value): the relative velocity at the control pointptData[7] (float value): the virtual distance at the control pointptData[8] (int value): the number of Bezier points at the control pointptData[9] (float value): the Bezier interpolation factor 1 at the control pointptData[10] (float value): the Bezier interpolation factor 2 at the control pointptData[11] (int value): the auxiliary flags at the control pointptData[12]-ptData[15] (float values): the 4 auxiliary values at the control pointpathHandle: the handle of the path. Refer also to simGetObjectHandle.options: bit-coded:bit0: if set (1), then the path will be closed (given that there are enough control points in the path)bit1: if set (2), then the expected value count (valCnt) for each point will be 16 instead of 11 (see further down)startIndex: the zero-based index where the first new control point should be inserted.ptCnt: the number of control points to insert.ptData (input): a buffer of ptCnt*valCnt values (float or int). ValCnt is 16 if bit1 of options is set, otherwise 11. Each new control point should have its properties described with following valCnt values:ptData[0]-ptData[2] (float values): the position of the control point (x,y,z), relative to the path objectptData[3]-ptData[5] (float values): the orientation of the control point in Euler angles (alpha,beta,gamma), relative to the path objectptData[6] (float value): the relative velocity at the control pointptData[7] (float value): the virtual distance at the control pointptData[8] (int value): the number of Bezier points at the control pointptData[9] (float value): the Bezier interpolation factor 1 at the control pointptData[10] (float value): the Bezier interpolation factor 2 at the control pointptData[11] (int value): the auxiliary flags at the control pointptData[12]-ptData[15] (float values): the 4 auxiliary values at the control pointpathHandle: the handle of the path. Refer also to simGetObjectHandle.options: bit-coded:bit0: if set (1), then the path will be closed (given that there are enough control points in the path)bit1: if set (2), then the expected value count (valCnt) for each point will be 16 instead of 11 (see further down)startIndex: the zero-based index where the first new control point should be inserted.ptCnt: the number of control points to insert.ptData (input): a buffer of ptCnt*valCnt values (float or int). ValCnt is 16 if bit1 of options is set, otherwise 11. Each new control point should have its properties described with following valCnt values:ptData[0]-ptData[2] (float values): the position of the control point (x,y,z), relative to the path objectptData[3]-ptData[5] (float values): the orientation of the control point in Euler angles (alpha,beta,gamma), relative to the path objectptData[6] (float value): the relative velocity at the control pointptData[7] (float value): the virtual distance at the control pointptData[8] (int value): the number of Bezier points at the control pointptData[9] (float value): the Bezier interpolation factor 1 at the control pointptData[10] (float value): the Bezier interpolation factor 2 at the control pointptData[11] (int value): the auxiliary flags at the control pointptData[12]-ptData[15] (float values): the 4 auxiliary values at the control pointpathHandle: the handle of the path. Refer also to simGetObjectHandle.options: bit-coded:bit0: if set (1), then the path will be closed (given that there are enough control points in the path)bit1: if set (2), then the expected value count (valCnt) for each point will be 16 instead of 11 (see further down)startIndex: the zero-based index where the first new control point should be inserted.ptCnt: the number of control points to insert.ptData (input): a buffer of ptCnt*valCnt values (float or int). ValCnt is 16 if bit1 of options is set, otherwise 11. Each new control point should have its properties described with following valCnt values:ptData[0]-ptData[2] (float values): the position of the control point (x,y,z), relative to the path objectptData[3]-ptData[5] (float values): the orientation of the control point in Euler angles (alpha,beta,gamma), relative to the path objectptData[6] (float value): the relative velocity at the control pointptData[7] (float value): the virtual distance at the control pointptData[8] (int value): the number of Bezier points at the control pointptData[9] (float value): the Bezier interpolation factor 1 at the control pointptData[10] (float value): the Bezier interpolation factor 2 at the control pointptData[11] (int value): the auxiliary flags at the control pointptData[12]-ptData[15] (float values): the 4 auxiliary values at the control pointpathHandle: the handle of the path. Refer also to simGetObjectHandle.options: bit-coded:bit0: if set (1), then the path will be closed (given that there are enough control points in the path)bit1: if set (2), then the expected value count (valCnt) for each point will be 16 instead of 11 (see further down)startIndex: the zero-based index where the first new control point should be inserted.ptCnt: the number of control points to insert.ptData (input): a buffer of ptCnt*valCnt values (float or int). ValCnt is 16 if bit1 of options is set, otherwise 11. Each new control point should have its properties described with following valCnt values:ptData[0]-ptData[2] (float values): the position of the control point (x,y,z), relative to the path objectptData[3]-ptData[5] (float values): the orientation of the control point in Euler angles (alpha,beta,gamma), relative to the path objectptData[6] (float value): the relative velocity at the control pointptData[7] (float value): the virtual distance at the control pointptData[8] (int value): the number of Bezier points at the control pointptData[9] (float value): the Bezier interpolation factor 1 at the control pointptData[10] (float value): the Bezier interpolation factor 2 at the control pointptData[11] (int value): the auxiliary flags at the control pointptData[12]-ptData[15] (float values): the 4 auxiliary values at the control pointpathHandle: the handle of the path. Refer also to simGetObjectHandle.options: bit-coded:bit0: if set (1), then the path will be closed (given that there are enough control points in the path)bit1: if set (2), then the expected value count (valCnt) for each point will be 16 instead of 11 (see further down)startIndex: the zero-based index where the first new control point should be inserted.ptCnt: the number of control points to insert.ptData (input): a buffer of ptCnt*valCnt values (float or int). ValCnt is 16 if bit1 of options is set, otherwise 11. Each new control point should have its properties described with following valCnt values:ptData[0]-ptData[2] (float values): the position of the control point (x,y,z), relative to the path objectptData[3]-ptData[5] (float values): the orientation of the control point in Euler angles (alpha,beta,gamma), relative to the path objectptData[6] (float value): the relative velocity at the control pointptData[7] (float value): the virtual distance at the control pointptData[8] (int value): the number of Bezier points at the control pointptData[9] (float value): the Bezier interpolation factor 1 at the control pointptData[10] (float value): the Bezier interpolation factor 2 at the control pointptData[11] (int value): the auxiliary flags at the control pointptData[12]-ptData[15] (float values): the 4 auxiliary values at the control pointpathHandle: the handle of the path. Refer also to simGetObjectHandle.options: bit-coded:bit0: if set (1), then the path will be closed (given that there are enough control points in the path)bit1: if set (2), then the expected value count (valCnt) for each point will be 16 instead of 11 (see further down)startIndex: the zero-based index where the first new control point should be inserted.ptCnt: the number of control points to insert.ptData (input): a buffer of ptCnt*valCnt values (float or int). ValCnt is 16 if bit1 of options is set, otherwise 11. Each new control point should have its properties described with following valCnt values:ptData[0]-ptData[2] (float values): the position of the control point (x,y,z), relative to the path objectptData[3]-ptData[5] (float values): the orientation of the control point in Euler angles (alpha,beta,gamma), relative to the path objectptData[6] (float value): the relative velocity at the control pointptData[7] (float value): the virtual distance at the control pointptData[8] (int value): the number of Bezier points at the control pointptData[9] (float value): the Bezier interpolation factor 1 at the control pointptData[10] (float value): the Bezier interpolation factor 2 at the control pointptData[11] (int value): the auxiliary flags at the control pointptData[12]-ptData[15] (float values): the 4 auxiliary values at the control pointpathHandle: the handle of the path. Refer also to simGetObjectHandle.options: bit-coded:bit0: if set (1), then the path will be closed (given that there are enough control points in the path)bit1: if set (2), then the expected value count (valCnt) for each point will be 16 instead of 11 (see further down)startIndex: the zero-based index where the first new control point should be inserted.ptCnt: the number of control points to insert.ptData (input): a buffer of ptCnt*valCnt values (float or int). ValCnt is 16 if bit1 of options is set, otherwise 11. Each new control point should have its properties described with following valCnt values:ptData[0]-ptData[2] (float values): the position of the control point (x,y,z), relative to the path objectptData[3]-ptData[5] (float values): the orientation of the control point in Euler angles (alpha,beta,gamma), relative to the path objectptData[6] (float value): the relative velocity at the control pointptData[7] (float value): the virtual distance at the control pointptData[8] (int value): the number of Bezier points at the control pointptData[9] (float value): the Bezier interpolation factor 1 at the control pointptData[10] (float value): the Bezier interpolation factor 2 at the control pointptData[11] (int value): the auxiliary flags at the control pointptData[12]-ptData[15] (float values): the 4 auxiliary values at the control pointpathHandle: the handle of the path. Refer also to simGetObjectHandle.options: bit-coded:bit0: if set (1), then the path will be closed (given that there are enough control points in the path)bit1: if set (2), then the expected value count (valCnt) for each point will be 16 instead of 11 (see further down)startIndex: the zero-based index where the first new control point should be inserted.ptCnt: the number of control points to insert.ptData (input): a buffer of ptCnt*valCnt values (float or int). ValCnt is 16 if bit1 of options is set, otherwise 11. Each new control point should have its properties described with following valCnt values:ptData[0]-ptData[2] (float values): the position of the control point (x,y,z), relative to the path objectptData[3]-ptData[5] (float values): the orientation of the control point in Euler angles (alpha,beta,gamma), relative to the path objectptData[6] (float value): the relative velocity at the control pointptData[7] (float value): the virtual distance at the control pointptData[8] (int value): the number of Bezier points at the control pointptData[9] (float value): the Bezier interpolation factor 1 at the control pointptData[10] (float value): the Bezier interpolation factor 2 at the control pointptData[11] (int value): the auxiliary flags at the control pointptData[12]-ptData[15] (float values): the 4 auxiliary values at the control point -1 if operation was not successful."
    }, 
    "sim.navigation_objectshift": {
        "body": "sim.navigation_objectshift", 
        "scope": "source.lua", 
        "prefix": "sim.navigation_objectshift", 
        "description": "Constants"
    }, 
    "sim.createMeshShape": {
        "body": "sim.createMeshShape(${0:options},${1:shadingAngle},${2:vertices},${3:indices})", 
        "scope": "source.lua", 
        "prefix": "sim.createMeshShape", 
        "description": "number objectHandle = sim.createMeshShape(number options,number shadingAngle,table vertices,table indices)Creates a mesh shape. See also sim.createPureShape, sim.createHeightfieldShape and sim.getShapeMesh, and see sim.importMesh for a usage example. options: Bit-coded: if bit0 is set (1), backfaces are culled. If bit1 is set (2), edges are visibleshadingAngle: the shading anglevertices: an array of verticesverticesSize: the size of the vertice arrayindices: an array of indicesindicesSize: the size of the indice arrayreserved: reserved for future extensions. Keep at NULL.options: Bit-coded: if bit0 is set (1), backfaces are culled. If bit1 is set (2), edges are visibleshadingAngle: the shading anglevertices: an array of verticesverticesSize: the size of the vertice arrayindices: an array of indicesindicesSize: the size of the indice arrayreserved: reserved for future extensions. Keep at NULL.options: Bit-coded: if bit0 is set (1), backfaces are culled. If bit1 is set (2), edges are visibleshadingAngle: the shading anglevertices: an array of verticesverticesSize: the size of the vertice arrayindices: an array of indicesindicesSize: the size of the indice arrayreserved: reserved for future extensions. Keep at NULL.options: Bit-coded: if bit0 is set (1), backfaces are culled. If bit1 is set (2), edges are visibleshadingAngle: the shading anglevertices: an array of verticesverticesSize: the size of the vertice arrayindices: an array of indicesindicesSize: the size of the indice arrayreserved: reserved for future extensions. Keep at NULL.options: Bit-coded: if bit0 is set (1), backfaces are culled. If bit1 is set (2), edges are visibleshadingAngle: the shading anglevertices: an array of verticesverticesSize: the size of the vertice arrayindices: an array of indicesindicesSize: the size of the indice arrayreserved: reserved for future extensions. Keep at NULL.options: Bit-coded: if bit0 is set (1), backfaces are culled. If bit1 is set (2), edges are visibleshadingAngle: the shading anglevertices: an array of verticesverticesSize: the size of the vertice arrayindices: an array of indicesindicesSize: the size of the indice arrayreserved: reserved for future extensions. Keep at NULL.options: Bit-coded: if bit0 is set (1), backfaces are culled. If bit1 is set (2), edges are visibleshadingAngle: the shading anglevertices: an array of verticesverticesSize: the size of the vertice arrayindices: an array of indicesindicesSize: the size of the indice arrayreserved: reserved for future extensions. Keep at NULL. -1 if operation was not successful, otherwise the handle of the newly created shape"
    }, 
    "simUI.mouse.left_button_down": {
        "body": "simUI.mouse.left_button_down", 
        "scope": "source.lua", 
        "prefix": "simUI.mouse.left_button_down", 
        "description": "Constants"
    }, 
    "sim.getScaledImage": {
        "body": "sim.getScaledImage(${0:imageIn},${1:resolutionIn},${2:desiredResolutionOut},${3:options})", 
        "scope": "source.lua", 
        "prefix": "sim.getScaledImage", 
        "description": "string imageOut,table_2 effectiveResolutionOut = sim.getScaledImage(string imageIn,table_2 resolutionIn,table_2 desiredResolutionOut,number options)Generates a scaled-up or scaled down version of the input image. See also sim.transformImage, sim.loadImage, sim.saveImage and sim.setVisionSensorCharImage. imageIn: a pointer to rgb or rgba values of the input image.resolutionIn: the resolution of the input image.resolutionOut: the desired resolution of the output image. The values will be replaced by the effective resolution of the output imageoptions: bit-coded:bit0 set (1): the input image is rgba, otherwise it is rgbbit1 set (2): the returned image is rgba, otherwise it is rgbbit2-3: 0:ignore aspect ratio, 4:keep aspect ratio (the effective resolution of the returned image will be different), 8:keep aspect ratio by expanding (the effective resolution of the returned image will be different)bit4 set (16): no smooth transformationreserved: Reserved for future extension. Set to NULL.imageIn: a pointer to rgb or rgba values of the input image.resolutionIn: the resolution of the input image.resolutionOut: the desired resolution of the output image. The values will be replaced by the effective resolution of the output imageoptions: bit-coded:bit0 set (1): the input image is rgba, otherwise it is rgbbit1 set (2): the returned image is rgba, otherwise it is rgbbit2-3: 0:ignore aspect ratio, 4:keep aspect ratio (the effective resolution of the returned image will be different), 8:keep aspect ratio by expanding (the effective resolution of the returned image will be different)bit4 set (16): no smooth transformationreserved: Reserved for future extension. Set to NULL.imageIn: a pointer to rgb or rgba values of the input image.resolutionIn: the resolution of the input image.resolutionOut: the desired resolution of the output image. The values will be replaced by the effective resolution of the output imageoptions: bit-coded:bit0 set (1): the input image is rgba, otherwise it is rgbbit1 set (2): the returned image is rgba, otherwise it is rgbbit2-3: 0:ignore aspect ratio, 4:keep aspect ratio (the effective resolution of the returned image will be different), 8:keep aspect ratio by expanding (the effective resolution of the returned image will be different)bit4 set (16): no smooth transformationreserved: Reserved for future extension. Set to NULL.imageIn: a pointer to rgb or rgba values of the input image.resolutionIn: the resolution of the input image.resolutionOut: the desired resolution of the output image. The values will be replaced by the effective resolution of the output imageoptions: bit-coded:bit0 set (1): the input image is rgba, otherwise it is rgbbit1 set (2): the returned image is rgba, otherwise it is rgbbit2-3: 0:ignore aspect ratio, 4:keep aspect ratio (the effective resolution of the returned image will be different), 8:keep aspect ratio by expanding (the effective resolution of the returned image will be different)bit4 set (16): no smooth transformationreserved: Reserved for future extension. Set to NULL.imageIn: a pointer to rgb or rgba values of the input image.resolutionIn: the resolution of the input image.resolutionOut: the desired resolution of the output image. The values will be replaced by the effective resolution of the output imageoptions: bit-coded:bit0 set (1): the input image is rgba, otherwise it is rgbbit1 set (2): the returned image is rgba, otherwise it is rgbbit2-3: 0:ignore aspect ratio, 4:keep aspect ratio (the effective resolution of the returned image will be different), 8:keep aspect ratio by expanding (the effective resolution of the returned image will be different)bit4 set (16): no smooth transformationreserved: Reserved for future extension. Set to NULL.imageIn: a pointer to rgb or rgba values of the input image.resolutionIn: the resolution of the input image.resolutionOut: the desired resolution of the output image. The values will be replaced by the effective resolution of the output imageoptions: bit-coded:bit0 set (1): the input image is rgba, otherwise it is rgbbit1 set (2): the returned image is rgba, otherwise it is rgbbit2-3: 0:ignore aspect ratio, 4:keep aspect ratio (the effective resolution of the returned image will be different), 8:keep aspect ratio by expanding (the effective resolution of the returned image will be different)bit4 set (16): no smooth transformationreserved: Reserved for future extension. Set to NULL.imageIn: a pointer to rgb or rgba values of the input image.resolutionIn: the resolution of the input image.resolutionOut: the desired resolution of the output image. The values will be replaced by the effective resolution of the output imageoptions: bit-coded:bit0 set (1): the input image is rgba, otherwise it is rgbbit1 set (2): the returned image is rgba, otherwise it is rgbbit2-3: 0:ignore aspect ratio, 4:keep aspect ratio (the effective resolution of the returned image will be different), 8:keep aspect ratio by expanding (the effective resolution of the returned image will be different)bit4 set (16): no smooth transformationreserved: Reserved for future extension. Set to NULL.imageIn: a pointer to rgb or rgba values of the input image.resolutionIn: the resolution of the input image.resolutionOut: the desired resolution of the output image. The values will be replaced by the effective resolution of the output imageoptions: bit-coded:bit0 set (1): the input image is rgba, otherwise it is rgbbit1 set (2): the returned image is rgba, otherwise it is rgbbit2-3: 0:ignore aspect ratio, 4:keep aspect ratio (the effective resolution of the returned image will be different), 8:keep aspect ratio by expanding (the effective resolution of the returned image will be different)bit4 set (16): no smooth transformationreserved: Reserved for future extension. Set to NULL.imageIn: a pointer to rgb or rgba values of the input image.resolutionIn: the resolution of the input image.resolutionOut: the desired resolution of the output image. The values will be replaced by the effective resolution of the output imageoptions: bit-coded:bit0 set (1): the input image is rgba, otherwise it is rgbbit1 set (2): the returned image is rgba, otherwise it is rgbbit2-3: 0:ignore aspect ratio, 4:keep aspect ratio (the effective resolution of the returned image will be different), 8:keep aspect ratio by expanding (the effective resolution of the returned image will be different)bit4 set (16): no smooth transformationreserved: Reserved for future extension. Set to NULL. NULL if operation was not successful, otherwise a buffer containing the output image data. The user is in charge of releasing the buffer with simReleaseBuffer."
    }, 
    "simRRS1.GET_CELL_FRAME": {
        "body": "simRRS1.GET_CELL_FRAME(${0:rcsHandle},${1:storage},${2:firstNext})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.GET_CELL_FRAME", 
        "description": "int status,string frameId,int frameType,string relativeToId,bitstring jointNumber,frame frameData= simRRS1.GET_CELL_FRAME(bitstring2 rcsHandle,int storage,int firstNext)"
    }, 
    "sim.bullet_constraintsolvertype_projectedgaussseidel": {
        "body": "sim.bullet_constraintsolvertype_projectedgaussseidel", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_constraintsolvertype_projectedgaussseidel", 
        "description": "Constants"
    }, 
    "sim.getModuleName": {
        "body": "sim.getModuleName(${0:index})", 
        "scope": "source.lua", 
        "prefix": "sim.getModuleName", 
        "description": "string moduleName,number version = sim.getModuleName(number index)Retrieves a plugin name that was previously registered with sim.loadModule. The simulator normally automatically loads and registers plugins present in the application directory. Users can use the sim.getModuleName to verify if a specific module is present index: index to a module. To list-up all module names, start with index=0 and increment index until return value is NULLmoduleVersion: version of the plugin. Can be NULL.index: index to a module. To list-up all module names, start with index=0 and increment index until return value is NULLmoduleVersion: version of the plugin. Can be NULL.index: index to a module. To list-up all module names, start with index=0 and increment index until return value is NULLmoduleVersion: version of the plugin. Can be NULL. Name of the module or NULL if no module is available at index position, or in case of an error. The user is in charge of destroying the returned name with simReleaseBuffer"
    }, 
    "sim.intparam_core_count": {
        "body": "sim.intparam_core_count", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_core_count", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_a2stiffness": {
        "body": "sim.vortex_joint_a2stiffness", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a2stiffness", 
        "description": "Constants"
    }, 
    "sysCall_afterDelete": {
        "body": "sysCall_afterDelete(${0:keys.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_afterDelete", 
        "description": "sysCall_afterDelete(called just after objects were deleted. Arg1 is a map with 'objectHandles' keys.)"
    }, 
    "sim.getReferencedHandles": {
        "body": "sim.getReferencedHandles(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getReferencedHandles", 
        "description": "table referencedHandles = sim.getReferencedHandles(number objectHandle)Retrieves a list of custom handles, linking a given object to other objects. See also sim.setReferencedHandles.  objectHandle: handle of the scene object that stores the list of handlesreferencedHandles: a pointer to a pointer that will be allocated and receive the list of handles. The user is in charge of releasing that buffer with simReleaseBuffer. Handles of following object types are supported: scene objects, collision objects, distance objects, IK groups, collections, and geometric constraint solver objects.reserved1: reserved for future extensionsreserved2: reserved for future extensionsobjectHandle: handle of the scene object that stores the list of handlesreferencedHandles: a pointer to a pointer that will be allocated and receive the list of handles. The user is in charge of releasing that buffer with simReleaseBuffer. Handles of following object types are supported: scene objects, collision objects, distance objects, IK groups, collections, and geometric constraint solver objects.reserved1: reserved for future extensionsreserved2: reserved for future extensionsobjectHandle: handle of the scene object that stores the list of handlesreferencedHandles: a pointer to a pointer that will be allocated and receive the list of handles. The user is in charge of releasing that buffer with simReleaseBuffer. Handles of following object types are supported: scene objects, collision objects, distance objects, IK groups, collections, and geometric constraint solver objects.reserved1: reserved for future extensionsreserved2: reserved for future extensionsobjectHandle: handle of the scene object that stores the list of handlesreferencedHandles: a pointer to a pointer that will be allocated and receive the list of handles. The user is in charge of releasing that buffer with simReleaseBuffer. Handles of following object types are supported: scene objects, collision objects, distance objects, IK groups, collections, and geometric constraint solver objects.reserved1: reserved for future extensionsreserved2: reserved for future extensions -1 in case of an error. Otherwise, the number of handles returned."
    }, 
    "sim.getGraphCurve": {
        "body": "sim.getGraphCurve(${0:graphHandle},${1:graphType},${2:curveIndex})", 
        "scope": "source.lua", 
        "prefix": "sim.getGraphCurve", 
        "description": "string label,number curveType,table curveColor,table xData,table yData,table zData,table minMax = sim.getGraphCurve(number graphHandle,number graphType,number curveIndex)"
    }, 
    "sim.getSignalName": {
        "body": "sim.getSignalName(${0:signalIndex},${1:signalType})", 
        "scope": "source.lua", 
        "prefix": "sim.getSignalName", 
        "description": "string signalName = sim.getSignalName(number signalIndex,number signalType)Returns the signal name at the given index.  Use this function in a loop until return is NULL to read all set signals. Signals are values that are global to a given simulator scene and cleared at simulation start. See also the other signal functions. signalIndex: zero based indexsignalType: signal type. 0 is for integer signals, 1 for float signals and 2 for string signalssignalIndex: zero based indexsignalType: signal type. 0 is for integer signals, 1 for float signals and 2 for string signalssignalIndex: zero based indexsignalType: signal type. 0 is for integer signals, 1 for float signals and 2 for string signals NULL if operation was not successful or signal does not exist at this index, otherwise the name of the signal at the given index (the user is in charge of releasing the returned buffer with simReleaseBuffer)"
    }, 
    "sim.banner_nobackground": {
        "body": "sim.banner_nobackground", 
        "scope": "source.lua", 
        "prefix": "sim.banner_nobackground", 
        "description": "Constants"
    }, 
    "sim.vortex_bodyfrictionmodel_box": {
        "body": "sim.vortex_bodyfrictionmodel_box", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_bodyfrictionmodel_box", 
        "description": "Constants"
    }, 
    "sim.objectproperty_collapsed": {
        "body": "sim.objectproperty_collapsed", 
        "scope": "source.lua", 
        "prefix": "sim.objectproperty_collapsed", 
        "description": "Constants"
    }, 
    "simOpenMesh.getDecimated": {
        "body": "simOpenMesh.getDecimated(${0:vertices},${1:indices},${2:maxVertices})", 
        "scope": "source.lua", 
        "prefix": "simOpenMesh.getDecimated", 
        "description": "table newVertices,table newIndices= simOpenMesh.getDecimated(table vertices,table indices,number maxVertices)"
    }, 
    "sim.getDistanceHandle": {
        "body": "sim.getDistanceHandle(${0:distanceObjectName})", 
        "scope": "source.lua", 
        "prefix": "sim.getDistanceHandle", 
        "description": "number distanceObjectHandle = sim.getDistanceHandle(string distanceObjectName)Retrieves the handle of a distance object. The operation of this function depends on the current name suffix settings (see sim.getNameSuffix, sim.setNameSuffix, and the section on accessing general-type objects). See also sim.isHandleValid. distanceObjectName: name of distance objectdistanceObjectName: name of distance object handle of the distance object or -1 if operation was not successful"
    }, 
    "math.max": {
        "body": "math.max( ${1:x},${2:...} )", 
        "scope": "source.lua", 
        "prefix": "math.max", 
        "description": "5.1,5.2,5.3\n\nmath.max"
    }, 
    "simOMPL.solve": {
        "body": "simOMPL.solve(${0:taskHandle},${1:maxTime})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.solve", 
        "description": "number result = simOMPL.solve(number taskHandle,number maxTime)"
    }, 
    "sim.saveImage": {
        "body": "sim.saveImage(${0:image},${1:resolution},${2:options},${3:filename},${4:quality})", 
        "scope": "source.lua", 
        "prefix": "sim.saveImage", 
        "description": "number result = sim.saveImage(string image,table_2 resolution,number options,string filename,number quality)Saves an image to file or to memory. See also sim.loadImage, sim.getScaledImage and sim.getVisionSensorCharImage. image: a pointer to rgb or rgba values.resolution: the x/y resolution of the provided image.options: bit-coded. If bit0 is set (1), then the provided image is rgba, otherwise it is rgb.filename: the name of the file to write. The file extension indicates the format.quality: the quality of the written image: 0 for best compression, 100 for largest file. Use -1 for default behaviour.reserved: Reserved for future extension. Set to NULL.image: a pointer to rgb or rgba values.resolution: the x/y resolution of the provided image.options: bit-coded. If bit0 is set (1), then the provided image is rgba, otherwise it is rgb.filename: the name of the file to write. The file extension indicates the format.quality: the quality of the written image: 0 for best compression, 100 for largest file. Use -1 for default behaviour.reserved: Reserved for future extension. Set to NULL.image: a pointer to rgb or rgba values.resolution: the x/y resolution of the provided image.options: bit-coded. If bit0 is set (1), then the provided image is rgba, otherwise it is rgb.filename: the name of the file to write. The file extension indicates the format.quality: the quality of the written image: 0 for best compression, 100 for largest file. Use -1 for default behaviour.reserved: Reserved for future extension. Set to NULL.image: a pointer to rgb or rgba values.resolution: the x/y resolution of the provided image.options: bit-coded. If bit0 is set (1), then the provided image is rgba, otherwise it is rgb.filename: the name of the file to write. The file extension indicates the format.quality: the quality of the written image: 0 for best compression, 100 for largest file. Use -1 for default behaviour.reserved: Reserved for future extension. Set to NULL.image: a pointer to rgb or rgba values.resolution: the x/y resolution of the provided image.options: bit-coded. If bit0 is set (1), then the provided image is rgba, otherwise it is rgb.filename: the name of the file to write. The file extension indicates the format.quality: the quality of the written image: 0 for best compression, 100 for largest file. Use -1 for default behaviour.reserved: Reserved for future extension. Set to NULL.image: a pointer to rgb or rgba values.resolution: the x/y resolution of the provided image.options: bit-coded. If bit0 is set (1), then the provided image is rgba, otherwise it is rgb.filename: the name of the file to write. The file extension indicates the format.quality: the quality of the written image: 0 for best compression, 100 for largest file. Use -1 for default behaviour.reserved: Reserved for future extension. Set to NULL. -1 if operation was not successful."
    }, 
    "sim.shapefloatparam_init_velocity_g": {
        "body": "sim.shapefloatparam_init_velocity_g", 
        "scope": "source.lua", 
        "prefix": "sim.shapefloatparam_init_velocity_g", 
        "description": "Constants"
    }, 
    "sim.tubeClose": {
        "body": "sim.tubeClose(${0:tubeHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.tubeClose", 
        "description": "number result = sim.tubeClose(number tubeHandle)Closes a communication tube previously opened with sim.tubeOpen. Data written with sim.tubeWrite and that hasn't been read yet on the other side of the tube will persist. tubeHandle: the handle of the tube that was returned by the simTubeOpen function. Once a tube was closed on one side, it is again ready for a new connection.tubeHandle: the handle of the tube that was returned by the simTubeOpen function. Once a tube was closed on one side, it is again ready for a new connection. -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.boolparam_aux_clip_planes_enabled": {
        "body": "sim.boolparam_aux_clip_planes_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_aux_clip_planes_enabled", 
        "description": "Constants"
    }, 
    "simx.pauseSimulation": {
        "body": "simx.pauseSimulation(${0:clientId})", 
        "scope": "source.lua", 
        "prefix": "simx.pauseSimulation", 
        "description": "number returnCode= simx.pauseSimulation(number clientId)Requests a pause of a simulation. See also simx.startSimulation and simx.stopSimulation. clientID: the client ID. refer to simx.start.operationMode: a remote API function operation mode. Recommended operation modes for this function is simx.opmode_oneshot. returnCode: a remote API function return code"
    }, 
    "sim.shapeintparam_convex": {
        "body": "sim.shapeintparam_convex", 
        "scope": "source.lua", 
        "prefix": "sim.shapeintparam_convex", 
        "description": "Constants"
    }, 
    "simRRS1.SET_REST_PARAMETER": {
        "body": "simRRS1.SET_REST_PARAMETER(${0:rcsHandle},${1:paramNumber})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_REST_PARAMETER", 
        "description": "int status= simRRS1.SET_REST_PARAMETER(bitstring2 rcsHandle,int paramNumber)"
    }, 
    "simB0.destroyServiceClient": {
        "body": "simB0.destroyServiceClient(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "simB0.destroyServiceClient", 
        "description": "simB0.destroyServiceClient(string handle)"
    }, 
    "simx.setBooleanParameter": {
        "body": "simx.setBooleanParameter(${0:clientId},${1:paramIdentifier},${2:paramValue})", 
        "scope": "source.lua", 
        "prefix": "simx.setBooleanParameter", 
        "description": "number returnCode= simx.setBooleanParameter(number clientId,number paramIdentifier,boolean paramValue)Sets a boolean parameter. See also simx.getBooleanParameter, simx.setIntegerParameter, simx.setArrayParameter and simx.setFloatingParameter. clientID: the client ID. refer to simx.start.paramIdentifier: a Boolean parameter identifierparamValue: the parameter valueoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "sysCall_nonSimulation": {
        "body": "sysCall_nonSimulation(${0:running.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_nonSimulation", 
        "description": "sysCall_nonSimulation(Called when simulation is not running.)"
    }, 
    "loadfile": {
        "body": "loadfile(${0:...})", 
        "scope": "source.lua", 
        "prefix": "loadfile", 
        "description": "5.1,5.2,5.3\n\nloadfile ([filename])"
    }, 
    "sim.objintparam_parent_role": {
        "body": "sim.objintparam_parent_role", 
        "scope": "source.lua", 
        "prefix": "sim.objintparam_parent_role", 
        "description": "Constants"
    }, 
    "sim.boolparam_browser_toolbarbutton_enabled": {
        "body": "sim.boolparam_browser_toolbarbutton_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_browser_toolbarbutton_enabled", 
        "description": "Constants"
    }, 
    "sim.intparam_prox_sensor_select_up": {
        "body": "sim.intparam_prox_sensor_select_up", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_prox_sensor_select_up", 
        "description": "Constants"
    }, 
    "sim.intparam_scene_index": {
        "body": "sim.intparam_scene_index", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_scene_index", 
        "description": "Constants"
    }, 
    "sim.childscriptattribute_enabled": {
        "body": "sim.childscriptattribute_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.childscriptattribute_enabled", 
        "description": "Constants"
    }, 
    "simVision.handleVelodyneVPL16": {
        "body": "simVision.handleVelodyneVPL16(${0:velodyneHandle})", 
        "scope": "source.lua", 
        "prefix": "simVision.handleVelodyneVPL16", 
        "description": "table points= simVision.handleVelodyneVPL16(number velodyneHandle)"
    }, 
    "sim.particle_itemsizes": {
        "body": "sim.particle_itemsizes", 
        "scope": "source.lua", 
        "prefix": "sim.particle_itemsizes", 
        "description": "Constants"
    }, 
    "sim.intparam_error_report_mode": {
        "body": "sim.intparam_error_report_mode", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_error_report_mode", 
        "description": "Constants"
    }, 
    "simUI.getComboboxItemCount": {
        "body": "simUI.getComboboxItemCount(${0:handle},${1:id})", 
        "scope": "source.lua", 
        "prefix": "simUI.getComboboxItemCount", 
        "description": "number count = simUI.getComboboxItemCount(number handle,number id)"
    }, 
    "sysCall_init": {
        "body": "sysCall_init(${0:initialized.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_init", 
        "description": "sysCall_init(Called when the script is initialized.)"
    }, 
    "sim.boolparam_waiting_for_trigger": {
        "body": "sim.boolparam_waiting_for_trigger", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_waiting_for_trigger", 
        "description": "Constants"
    }, 
    "sim.vortex_body_autoangulardampingtensionratio": {
        "body": "sim.vortex_body_autoangulardampingtensionratio", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_autoangulardampingtensionratio", 
        "description": "Constants"
    }, 
    "simx.getFloatingParameter": {
        "body": "simx.getFloatingParameter(${0:clientId},${1:paramIdentifier})", 
        "scope": "source.lua", 
        "prefix": "simx.getFloatingParameter", 
        "description": "number returnCode,number paramValue= simx.getFloatingParameter(number clientId,number paramIdentifier)Retrieves a floating point value. See the floating-point parameter identifiers. See also simx.setFloatingParameter, simx.getBooleanParameter, simx.getIntegerParameter, simx.getArrayParameter and simx.getStringParameter. clientID: the client ID. refer to simx.start.paramIdentifier: a floating parameter identifieroperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking (if not called on a regular basis) returnCode: a remote API function return codeparamValue: the parameter value"
    }, 
    "simOMPL.setStateSpace": {
        "body": "simOMPL.setStateSpace(${0:taskHandle},${1:stateSpaceHandles})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.setStateSpace", 
        "description": "number result = simOMPL.setStateSpace(number taskHandle,table stateSpaceHandles)"
    }, 
    "string.len": {
        "body": "string.len( ${1:s} )", 
        "scope": "source.lua", 
        "prefix": "string.len", 
        "description": "5.1,5.2,5.3\n\nstring.len"
    }, 
    "sim.dlgret_ok": {
        "body": "sim.dlgret_ok", 
        "scope": "source.lua", 
        "prefix": "sim.dlgret_ok", 
        "description": "Constants"
    }, 
    "sim.setThreadSwitchTiming": {
        "body": "sim.setThreadSwitchTiming(${0:deltaTimeInMilliseconds})", 
        "scope": "source.lua", 
        "prefix": "sim.setThreadSwitchTiming", 
        "description": "number result = sim.setThreadSwitchTiming(number deltaTimeInMilliseconds)Allows specifying a switching time for the thread in which the current script runs. If the current script doesn't run in a thread (i.e. if it runs in the application main thread), this function has no effect. By default, V-REP doesn't use regular threads, but something similar to hybrid threads (which behave like coroutines, but can also behave like regular threads). This allows much more flexibility and execution control of the threads: each thread (except for the main or application thread) has a switch timing associated, which specifies how long the thread will run before switching to other threads (the execution duration per calculation pass). By default this value is 2 millisecond, but this function allows changing that value (on a thread-basis). Acceptable values are between 0 and 200. For complete control over the switching moment, see also sim.setThreadAutomaticSwitch, sim.switchThread, sim.setThreadIsFree and sim.setThreadResumeLocation. - -"
    }, 
    "sim.bullet_body_sticky": {
        "body": "sim.bullet_body_sticky", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_body_sticky", 
        "description": "Constants"
    }, 
    "sim.dlgret_yes": {
        "body": "sim.dlgret_yes", 
        "scope": "source.lua", 
        "prefix": "sim.dlgret_yes", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_a1loss": {
        "body": "sim.vortex_joint_a1loss", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a1loss", 
        "description": "Constants"
    }, 
    "sim.cameraFitToView": {
        "body": "sim.cameraFitToView(${0:viewHandleOrIndex},${1:objectHandles=nil},${2:options=0},${3:scaling=1})", 
        "scope": "source.lua", 
        "prefix": "sim.cameraFitToView", 
        "description": "number result = sim.cameraFitToView(number viewHandleOrIndex,table objectHandles=nil,simInt options=0,simFloat scaling=1)Shifts and adjusts a camera associated with a view to fill the view entirely with the specified objects or models. See also the sim.adjustView and sim.floatingViewAdd functions. viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view. If the camera is not associated with any view, then you can specify the handle of the camera, together with the sim_handleflag_camera flag.objectCount: number of intems in the objectHandles pointer. Can be 0, in which case the whole visible scene will be filling the view.objectHandles: pointer to objectHandles. Only visible objects will be taken into account. Can be NULL, in which case the whole visible scene will be filling the view.options: bit-coded:bit0 (1): if set, then individual objects will be filling the view. If not set, then models associated with model base objects will also be includedbit1 (2): if set, then the view proportions will be 1 by 1, independently on what the view size isscaling: scaling factor. Use '1' for normal behaviour.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view. If the camera is not associated with any view, then you can specify the handle of the camera, together with the sim_handleflag_camera flag.objectCount: number of intems in the objectHandles pointer. Can be 0, in which case the whole visible scene will be filling the view.objectHandles: pointer to objectHandles. Only visible objects will be taken into account. Can be NULL, in which case the whole visible scene will be filling the view.options: bit-coded:bit0 (1): if set, then individual objects will be filling the view. If not set, then models associated with model base objects will also be includedbit1 (2): if set, then the view proportions will be 1 by 1, independently on what the view size isscaling: scaling factor. Use '1' for normal behaviour.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view. If the camera is not associated with any view, then you can specify the handle of the camera, together with the sim_handleflag_camera flag.objectCount: number of intems in the objectHandles pointer. Can be 0, in which case the whole visible scene will be filling the view.objectHandles: pointer to objectHandles. Only visible objects will be taken into account. Can be NULL, in which case the whole visible scene will be filling the view.options: bit-coded:bit0 (1): if set, then individual objects will be filling the view. If not set, then models associated with model base objects will also be includedbit1 (2): if set, then the view proportions will be 1 by 1, independently on what the view size isscaling: scaling factor. Use '1' for normal behaviour.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view. If the camera is not associated with any view, then you can specify the handle of the camera, together with the sim_handleflag_camera flag.objectCount: number of intems in the objectHandles pointer. Can be 0, in which case the whole visible scene will be filling the view.objectHandles: pointer to objectHandles. Only visible objects will be taken into account. Can be NULL, in which case the whole visible scene will be filling the view.options: bit-coded:bit0 (1): if set, then individual objects will be filling the view. If not set, then models associated with model base objects will also be includedbit1 (2): if set, then the view proportions will be 1 by 1, independently on what the view size isscaling: scaling factor. Use '1' for normal behaviour.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view. If the camera is not associated with any view, then you can specify the handle of the camera, together with the sim_handleflag_camera flag.objectCount: number of intems in the objectHandles pointer. Can be 0, in which case the whole visible scene will be filling the view.objectHandles: pointer to objectHandles. Only visible objects will be taken into account. Can be NULL, in which case the whole visible scene will be filling the view.options: bit-coded:bit0 (1): if set, then individual objects will be filling the view. If not set, then models associated with model base objects will also be includedbit1 (2): if set, then the view proportions will be 1 by 1, independently on what the view size isscaling: scaling factor. Use '1' for normal behaviour.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view. If the camera is not associated with any view, then you can specify the handle of the camera, together with the sim_handleflag_camera flag.objectCount: number of intems in the objectHandles pointer. Can be 0, in which case the whole visible scene will be filling the view.objectHandles: pointer to objectHandles. Only visible objects will be taken into account. Can be NULL, in which case the whole visible scene will be filling the view.options: bit-coded:bit0 (1): if set, then individual objects will be filling the view. If not set, then models associated with model base objects will also be includedbit1 (2): if set, then the view proportions will be 1 by 1, independently on what the view size isscaling: scaling factor. Use '1' for normal behaviour.viewHandleOrIndex: the handle of the view (can also be a floating view), or the index of the view. If the camera is not associated with any view, then you can specify the handle of the camera, together with the sim_handleflag_camera flag.objectCount: number of intems in the objectHandles pointer. Can be 0, in which case the whole visible scene will be filling the view.objectHandles: pointer to objectHandles. Only visible objects will be taken into account. Can be NULL, in which case the whole visible scene will be filling the view.options: bit-coded:bit0 (1): if set, then individual objects will be filling the view. If not set, then models associated with model base objects will also be includedbit1 (2): if set, then the view proportions will be 1 by 1, independently on what the view size isscaling: scaling factor. Use '1' for normal behaviour. -1 if operation was not successful. 0 for a silent error (e.g. when the indicated view doesn't exist anymore), 1 for success"
    }, 
    "sim.newton_joint_dependencyfactor": {
        "body": "sim.newton_joint_dependencyfactor", 
        "scope": "source.lua", 
        "prefix": "sim.newton_joint_dependencyfactor", 
        "description": "Constants"
    }, 
    "sim.vortex_body_primaxisvectorx": {
        "body": "sim.vortex_body_primaxisvectorx", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_primaxisvectorx", 
        "description": "Constants"
    }, 
    "sim.convexDecompose": {
        "body": "sim.convexDecompose(${0:shapeHandle},${1:options},${2:intParams},${3:floatParams})", 
        "scope": "source.lua", 
        "prefix": "sim.convexDecompose", 
        "description": "number shapeHandle = sim.convexDecompose(number shapeHandle,number options,table_4 intParams,table_3 floatParams)Calculates the convex decomposition of a shape using the HACD or V-HACD algorithms. See also sim.getQHull, sim.getDecimatedMesh, sim.ungroupShape and sim.computeMassAndInertia. shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default).shapeHandle: handle of the shape to operate onoptions: bit-coded:bit0 set (1): the specified shape will be morphed into its convex decomposition. Otherwise, the convex decomposition will smply be added to the scenebit1 set (2): specified convex decomposition parameters will be displayed in a dialog, allowing the user to modify them.bit2 set (4): same convex decomposition parameters will be used as a previous call to this function. Only when this bit is set can the convex decomposition parameters be omitted.bit3 set (8): HACD: extra points will be added when computing the concavitybit4 set (16): HACD: faces points will be added when computing the concavitybit5 set (32): each individual mesh of a compound shape will be handled on its own during decomposition, otherwise the compound shape is considered as a single meshbit6  (64): reserved. Do not set.bit7 set (128): the V-HACD algorithm \u25cbwill be used. If not set, the HACD algorithm will be used.bit8 set (256): V-HACD: pca is enabled (default is disabled).bit9 set (512): V-HACD: tetrahedron-based approximate convex decomposition. If not set, then the voxel-based approximate convex decomposition will be used (default).intParams: 10 int values:intParams[0]: HACD: the minimum number of clusters to be generated (e.g. 1)intParams[1]: HACD: the targeted number of triangles of the decimated mesh (e.g. 500)intParams[2]: HACD: the maximum number of vertices for each generated convex hull (e.g. 100)intParams[3]: HACD: the maximum number of iterations. Use 0 for the default value (i.e. 4).intParams[4]: reserved. Set to 0.intParams[5]: V-HACD: resolution (10000-64000000, 100000 is default).intParams[6]: V-HACD: depth (1-32, 20 is default).intParams[7]: V-HACD: plane downsampling (1-16, 4 is default).intParams[8]: V-HACD: convex hull downsampling (1-16, 4 is default).intParams[9]: V-HACD: max. number of vertices per convex hull (4-1024, 64 is default).floatParams: 10 float values:floatParams[0]: HACD: the maximum allowed concavity (e.g. 100.0)floatParams[1]: HACD: the maximum allowed distance to get convex clusters connected (e.g. 30)floatParams[2]: HACD: the threshold to detect small clusters. The threshold is expressed as a percentage of the total mesh surface (e.g. 0.25)floatParams[3]: reserved. Set to 0.0floatParams[4]: reserved. Set to 0.0floatParams[5]: V-HACD: concavity (0.0-1.0, 0.0025 is default).floatParams[6]: V-HACD: alpha (0.0-1.0, 0.05 is default).floatParams[7]: V-HACD: beta (0.0-1.0, 0.05 is default).floatParams[8]: V-HACD: gamma (0.0-1.0, 0.00125 is default).floatParams[9]: V-HACD: min. volume per convex hull (0.0-0.01, 0.0001 is default). -1 if operation was not successful. Otherwise the handle of the new shape, or the handle of the original shape when morphing."
    }, 
    "sim.intparam_work_thread_count": {
        "body": "sim.intparam_work_thread_count", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_work_thread_count", 
        "description": "Constants"
    }, 
    "load": {
        "body": "load(${0:...})", 
        "scope": "source.lua", 
        "prefix": "load", 
        "description": "5.1,5.2,5.3\n\nload (func [, chunkname])"
    }, 
    "sim.setVisionSensorCharImage": {
        "body": "sim.setVisionSensorCharImage(${0:sensorHandle},${1:imageBuffer})", 
        "scope": "source.lua", 
        "prefix": "sim.setVisionSensorCharImage", 
        "description": "number result = sim.setVisionSensorCharImage(number sensorHandle,string imageBuffer)Sets the rgb-image of a vision sensor (and applies any image processing filter if specified in the vision sensor dialog). Make sure the vision sensor is flagged as external input. Use sim.getVisionSensorResolution to know the size of the image buffer that you need to provide (buffer size=resolutionX *resolutionY*3). The regular use of this function is to first read the data from a vision sensor with sim.getVisionSensorCharImage, do some custom filtering, then write the modified image back. The alternate use of this function is to display textures, video images, etc. by using a vision sensor object (without however making use of the vision sensor functionality), since a vision sensor can be looked through like camera objects. See also sim.setVisionSensorImage. sensorHandle: handle of the vision sensor object.   Can be combined with sim_handleflag_greyscale (simply add sim_handleflag_greyscale to sensorHandle), if you wish to provide grey scale values instead of rgb values..image: rgb buffer containing the image (buffer size must be resolutionX*resolutionY*3). Values in the buffer should vary between 0 and 255. In case a grey scale image is provided, the buffer size must be resolutionX*resolutionY.sensorHandle: handle of the vision sensor object.   Can be combined with sim_handleflag_greyscale (simply add sim_handleflag_greyscale to sensorHandle), if you wish to provide grey scale values instead of rgb values..image: rgb buffer containing the image (buffer size must be resolutionX*resolutionY*3). Values in the buffer should vary between 0 and 255. In case a grey scale image is provided, the buffer size must be resolutionX*resolutionY. -1 if operation was not successful. 0 if the applied filter didn't trigger anything, 1 if the appIied filter triggered a detection"
    }, 
    "sim.vortex_body_primaxisvectorz": {
        "body": "sim.vortex_body_primaxisvectorz", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_primaxisvectorz", 
        "description": "Constants"
    }, 
    "coroutine.wrap": {
        "body": "coroutine.wrap( ${1:function} )", 
        "scope": "source.lua", 
        "prefix": "coroutine.wrap", 
        "description": "5.1,5.2,5.3\n\ncoroutine.wrap"
    }, 
    "sim.modelproperty_not_model": {
        "body": "sim.modelproperty_not_model", 
        "scope": "source.lua", 
        "prefix": "sim.modelproperty_not_model", 
        "description": "Constants"
    }, 
    "sim.test": {
        "body": "sim.test(${0:used})", 
        "scope": "source.lua", 
        "prefix": "sim.test", 
        "description": "sim.test(test function - shouldn't be used)"
    }, 
    "simx.loadScene": {
        "body": "simx.loadScene(${0:clientId},${1:scenePathAndName},${2:options})", 
        "scope": "source.lua", 
        "prefix": "simx.loadScene", 
        "description": "number returnCode= simx.loadScene(number clientId,string scenePathAndName,number options)Loads a previously saved scene. Should only be called when simulation is not running and is only executed by continuous remote API server services. See also simx.closeScene, simx.loadModel, and simx.transferFile. clientID: the client ID. refer to simx.start.scenePathAndName: the scene filename, including the path and extension (ttt). The file is relative to the client or server system depending on the options value (see next argument)scenePathAndName: the scene filename, including the path and extension (ttt). The file is relative to the client or server system depending on the options value (see next argument)options: options, bit-coded:operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return code"
    }, 
    "sim.msgbox_buttons_okcancel": {
        "body": "sim.msgbox_buttons_okcancel", 
        "scope": "source.lua", 
        "prefix": "sim.msgbox_buttons_okcancel", 
        "description": "Constants"
    }, 
    "simROS.shutdownSubscriber": {
        "body": "simROS.shutdownSubscriber(${0:subscriberHandle})", 
        "scope": "source.lua", 
        "prefix": "simROS.shutdownSubscriber", 
        "description": "simROS.shutdownSubscriber(number subscriberHandle)"
    }, 
    "simUI.getComboboxItems": {
        "body": "simUI.getComboboxItems(${0:handle},${1:id})", 
        "scope": "source.lua", 
        "prefix": "simUI.getComboboxItems", 
        "description": "table items = simUI.getComboboxItems(number handle,number id)"
    }, 
    "simRRS1.SELECT_WORK_FRAMES": {
        "body": "simRRS1.SELECT_WORK_FRAMES(${0:rcsHandle},${1:toolId})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SELECT_WORK_FRAMES", 
        "description": "int status= simRRS1.SELECT_WORK_FRAMES(bitstring2 rcsHandle,string toolId)"
    }, 
    "sim.jointmode_passive": {
        "body": "sim.jointmode_passive", 
        "scope": "source.lua", 
        "prefix": "sim.jointmode_passive", 
        "description": "Constants"
    }, 
    "sim.msgbox_buttons_yesno": {
        "body": "sim.msgbox_buttons_yesno", 
        "scope": "source.lua", 
        "prefix": "sim.msgbox_buttons_yesno", 
        "description": "Constants"
    }, 
    "sim.objfloatparam_abs_rot_velocity": {
        "body": "sim.objfloatparam_abs_rot_velocity", 
        "scope": "source.lua", 
        "prefix": "sim.objfloatparam_abs_rot_velocity", 
        "description": "Constants"
    }, 
    "sim.rmlStep": {
        "body": "sim.rmlStep(${0:handle},${1:timeStep})", 
        "scope": "source.lua", 
        "prefix": "sim.rmlStep", 
        "description": "number result,table newPosVelAccel,number synchronizationTime = sim.rmlStep(number handle,number timeStep)"
    }, 
    "bit32.replace": {
        "body": "bit32.replace(${0:...})", 
        "scope": "source.lua", 
        "prefix": "bit32.replace", 
        "description": "5.2\n\nbit32.replace (n, v, field [, width])"
    }, 
    "sim.floatingViewAdd": {
        "body": "sim.floatingViewAdd(${0:posX},${1:posY},${2:sizeX},${3:sizeY},${4:options})", 
        "scope": "source.lua", 
        "prefix": "sim.floatingViewAdd", 
        "description": "number floatingViewHandle = sim.floatingViewAdd(number posX,number posY,number sizeX,number sizeY,number options)Adds a floating view to current page. See also the sim.floatingViewRemove, sim.adjustView and sim.cameraFitToView functions. posX & posY: relative position of the center of the floating view. Accepted values are between 0 and 1.sizeX & sizeY: relative size of the floating view. Accepted values are between 0 and 1.options: bit-coded:bit0 set (1)=double click allows swapping the floating view with the main viewbit1 set (2)=the floating view doesn't have a close buttonbit2 set (4)=the floating view cannot be shiftedbit3 set (8)=the floating view cannot be resizedposX & posY: relative position of the center of the floating view. Accepted values are between 0 and 1.sizeX & sizeY: relative size of the floating view. Accepted values are between 0 and 1.options: bit-coded:bit0 set (1)=double click allows swapping the floating view with the main viewbit1 set (2)=the floating view doesn't have a close buttonbit2 set (4)=the floating view cannot be shiftedbit3 set (8)=the floating view cannot be resizedposX & posY: relative position of the center of the floating view. Accepted values are between 0 and 1.sizeX & sizeY: relative size of the floating view. Accepted values are between 0 and 1.options: bit-coded:bit0 set (1)=double click allows swapping the floating view with the main viewbit1 set (2)=the floating view doesn't have a close buttonbit2 set (4)=the floating view cannot be shiftedbit3 set (8)=the floating view cannot be resizedposX & posY: relative position of the center of the floating view. Accepted values are between 0 and 1.sizeX & sizeY: relative size of the floating view. Accepted values are between 0 and 1.options: bit-coded:bit0 set (1)=double click allows swapping the floating view with the main viewbit1 set (2)=the floating view doesn't have a close buttonbit2 set (4)=the floating view cannot be shiftedbit3 set (8)=the floating view cannot be resizedposX & posY: relative position of the center of the floating view. Accepted values are between 0 and 1.sizeX & sizeY: relative size of the floating view. Accepted values are between 0 and 1.options: bit-coded:bit0 set (1)=double click allows swapping the floating view with the main viewbit1 set (2)=the floating view doesn't have a close buttonbit2 set (4)=the floating view cannot be shiftedbit3 set (8)=the floating view cannot be resizedposX & posY: relative position of the center of the floating view. Accepted values are between 0 and 1.sizeX & sizeY: relative size of the floating view. Accepted values are between 0 and 1.options: bit-coded:bit0 set (1)=double click allows swapping the floating view with the main viewbit1 set (2)=the floating view doesn't have a close buttonbit2 set (4)=the floating view cannot be shiftedbit3 set (8)=the floating view cannot be resizedposX & posY: relative position of the center of the floating view. Accepted values are between 0 and 1.sizeX & sizeY: relative size of the floating view. Accepted values are between 0 and 1.options: bit-coded:bit0 set (1)=double click allows swapping the floating view with the main viewbit1 set (2)=the floating view doesn't have a close buttonbit2 set (4)=the floating view cannot be shiftedbit3 set (8)=the floating view cannot be resized Handle of the floating view, or -1 in case of an error."
    }, 
    "math.floor": {
        "body": "math.floor( ${1:x} )", 
        "scope": "source.lua", 
        "prefix": "math.floor", 
        "description": "5.1,5.2,5.3\n\nmath.floor"
    }, 
    "simROS.hasParam": {
        "body": "simROS.hasParam(${0:name})", 
        "scope": "source.lua", 
        "prefix": "simROS.hasParam", 
        "description": "bool exists = simROS.hasParam(string name)"
    }, 
    "ipairs": {
        "body": "ipairs(${0:...})", 
        "scope": "source.lua", 
        "prefix": "ipairs", 
        "description": "5.1,5.2,5.3\n\nipairs (t)"
    }, 
    "sim.filtercomponent_velodyne": {
        "body": "sim.filtercomponent_velodyne", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_velodyne", 
        "description": "Constants"
    }, 
    "simOMPL.Algorithm.EST": {
        "body": "simOMPL.Algorithm.EST", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.EST", 
        "description": "Constants"
    }, 
    "sim.ik_jacobian_transpose_method": {
        "body": "sim.ik_jacobian_transpose_method", 
        "scope": "source.lua", 
        "prefix": "sim.ik_jacobian_transpose_method", 
        "description": "Constants"
    }, 
    "sim.visionintparam_resolution_x": {
        "body": "sim.visionintparam_resolution_x", 
        "scope": "source.lua", 
        "prefix": "sim.visionintparam_resolution_x", 
        "description": "Constants"
    }, 
    "sim.visionintparam_resolution_y": {
        "body": "sim.visionintparam_resolution_y", 
        "scope": "source.lua", 
        "prefix": "sim.visionintparam_resolution_y", 
        "description": "Constants"
    }, 
    "sim.getDataOnPath": {
        "body": "sim.getDataOnPath(${0:pathHandle},${1:relativeDistance})", 
        "scope": "source.lua", 
        "prefix": "sim.getDataOnPath", 
        "description": "number auxFlags,table_4 auxChannels = sim.getDataOnPath(number pathHandle,number relativeDistance)Retrieves interpolated user data along a path object. See also sim.getPositionOnPath, sim.getOrientationOnPath, sim.getPathPosition and sim.getClosestPositionOnPath. pathHandle: handle of the path objectrelativeDistance: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate path length calculation method. See also simGetPathLength. In order to retrieve data that lies exactly on a specific path control point, specify following for relativeDistance: -ctrlPtIndex-1 (the value will be rounded appropriately).dataType: the type of the desired data. Keep 0.intData: pointer to a one-dimensional array that will receive the auxiliary flags value at the given path relative distance.floatData: pointer to a 4-dimensional array that will receive the auxiliary channel values at the given path relative distance.pathHandle: handle of the path objectrelativeDistance: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate path length calculation method. See also simGetPathLength. In order to retrieve data that lies exactly on a specific path control point, specify following for relativeDistance: -ctrlPtIndex-1 (the value will be rounded appropriately).dataType: the type of the desired data. Keep 0.intData: pointer to a one-dimensional array that will receive the auxiliary flags value at the given path relative distance.floatData: pointer to a 4-dimensional array that will receive the auxiliary channel values at the given path relative distance.pathHandle: handle of the path objectrelativeDistance: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate path length calculation method. See also simGetPathLength. In order to retrieve data that lies exactly on a specific path control point, specify following for relativeDistance: -ctrlPtIndex-1 (the value will be rounded appropriately).dataType: the type of the desired data. Keep 0.intData: pointer to a one-dimensional array that will receive the auxiliary flags value at the given path relative distance.floatData: pointer to a 4-dimensional array that will receive the auxiliary channel values at the given path relative distance.pathHandle: handle of the path objectrelativeDistance: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate path length calculation method. See also simGetPathLength. In order to retrieve data that lies exactly on a specific path control point, specify following for relativeDistance: -ctrlPtIndex-1 (the value will be rounded appropriately).dataType: the type of the desired data. Keep 0.intData: pointer to a one-dimensional array that will receive the auxiliary flags value at the given path relative distance.floatData: pointer to a 4-dimensional array that will receive the auxiliary channel values at the given path relative distance.pathHandle: handle of the path objectrelativeDistance: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate path length calculation method. See also simGetPathLength. In order to retrieve data that lies exactly on a specific path control point, specify following for relativeDistance: -ctrlPtIndex-1 (the value will be rounded appropriately).dataType: the type of the desired data. Keep 0.intData: pointer to a one-dimensional array that will receive the auxiliary flags value at the given path relative distance.floatData: pointer to a 4-dimensional array that will receive the auxiliary channel values at the given path relative distance. -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simUI.setNodeOutletCount": {
        "body": "simUI.setNodeOutletCount(${0:handle},${1:id},${2:nodeId},${3:count})", 
        "scope": "source.lua", 
        "prefix": "simUI.setNodeOutletCount", 
        "description": "simUI.setNodeOutletCount(number handle,number id,number nodeId,number count)"
    }, 
    "sim.particle_water": {
        "body": "sim.particle_water", 
        "scope": "source.lua", 
        "prefix": "sim.particle_water", 
        "description": "Constants"
    }, 
    "simOMPL.writeState": {
        "body": "simOMPL.writeState(${0:taskHandle},${1:state})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.writeState", 
        "description": "number result = simOMPL.writeState(number taskHandle,table state)"
    }, 
    "sim.vortex_joint_p2stiffness": {
        "body": "sim.vortex_joint_p2stiffness", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p2stiffness", 
        "description": "Constants"
    }, 
    "simCHAI3D.updateShape": {
        "body": "simCHAI3D.updateShape(${0:objectID},${1:position},${2:orientation},${3:stiffnessFactor})", 
        "scope": "source.lua", 
        "prefix": "simCHAI3D.updateShape", 
        "description": "simCHAI3D.updateShape(number objectID,table_3 position,table_3 orientation,number stiffnessFactor)"
    }, 
    "sim.vortex_joint_a1frictionmaxforce": {
        "body": "sim.vortex_joint_a1frictionmaxforce", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a1frictionmaxforce", 
        "description": "Constants"
    }, 
    "sim.setModelProperty": {
        "body": "sim.setModelProperty(${0:objectHandle},${1:property})", 
        "scope": "source.lua", 
        "prefix": "sim.setModelProperty", 
        "description": "number result = sim.setModelProperty(number objectHandle,number property)Sets the properties of a model. See also sim.getModelProperty, sim.setObjectProperty and sim.setObjectSpecialProperty. objectHandle: handle of the object that serves as the model baseprop: model property. See the model property values. Combine them with the or-operatorobjectHandle: handle of the object that serves as the model baseprop: model property. See the model property values. Combine them with the or-operatorobjectHandle: handle of the object that serves as the model baseprop: model property. See the model property values. Combine them with the or-operator -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.intparam_infotext_style": {
        "body": "sim.intparam_infotext_style", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_infotext_style", 
        "description": "Constants"
    }, 
    "sim.readVisionSensor": {
        "body": "sim.readVisionSensor(${0:sensorHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.readVisionSensor", 
        "description": "number result,table auxiliaryValues = sim.readVisionSensor(number sensorHandle)Reads the state of a vision sensor. This function doesn't perform detection, it merely reads the result from a previous call to sim.handleVisionSensor (sim.handleVisionSensor is called in the default main script). See also sim.checkVisionSensor, sim.checkVisionSensorEx and sim.resetVisionSensor. visionSensorHandle: handle of a vision sensor objectauxValues: auxiliary values returned from the applied filters. By default V-REP returns one packet of 15 auxiliary values:the minimum of {intensity, red, green, blue, depth value}, the maximum of {intensity, red, green, blue, depth value}, and the average of {intensity, red, green, blue, depth value}. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with simReleaseBuffer(*auxValues).auxValuesCount: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with simReleaseBuffer(*auxValuesCount).See simHandleVisionSensor for a usage examplevisionSensorHandle: handle of a vision sensor objectauxValues: auxiliary values returned from the applied filters. By default V-REP returns one packet of 15 auxiliary values:the minimum of {intensity, red, green, blue, depth value}, the maximum of {intensity, red, green, blue, depth value}, and the average of {intensity, red, green, blue, depth value}. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with simReleaseBuffer(*auxValues).auxValuesCount: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with simReleaseBuffer(*auxValuesCount).See simHandleVisionSensor for a usage examplevisionSensorHandle: handle of a vision sensor objectauxValues: auxiliary values returned from the applied filters. By default V-REP returns one packet of 15 auxiliary values:the minimum of {intensity, red, green, blue, depth value}, the maximum of {intensity, red, green, blue, depth value}, and the average of {intensity, red, green, blue, depth value}. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with simReleaseBuffer(*auxValues).auxValuesCount: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with simReleaseBuffer(*auxValuesCount).See simHandleVisionSensor for a usage examplevisionSensorHandle: handle of a vision sensor objectauxValues: auxiliary values returned from the applied filters. By default V-REP returns one packet of 15 auxiliary values:the minimum of {intensity, red, green, blue, depth value}, the maximum of {intensity, red, green, blue, depth value}, and the average of {intensity, red, green, blue, depth value}. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with simReleaseBuffer(*auxValues).auxValuesCount: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with simReleaseBuffer(*auxValuesCount).See simHandleVisionSensor for a usage example detection state (0 or 1), or -1 in case of an error, or if simHandleVisionSensor was never called, or if simResetVisionSensor was previously called."
    }, 
    "sim.distcalcmethod_dl": {
        "body": "sim.distcalcmethod_dl", 
        "scope": "source.lua", 
        "prefix": "sim.distcalcmethod_dl", 
        "description": "Constants"
    }, 
    "sim.boolparam_calcmodules_toolbarbutton_enabled": {
        "body": "sim.boolparam_calcmodules_toolbarbutton_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_calcmodules_toolbarbutton_enabled", 
        "description": "Constants"
    }, 
    "sim.objectproperty_selectinvisible": {
        "body": "sim.objectproperty_selectinvisible", 
        "scope": "source.lua", 
        "prefix": "sim.objectproperty_selectinvisible", 
        "description": "Constants"
    }, 
    "sim.ungroupShape": {
        "body": "sim.ungroupShape(${0:shapeHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.ungroupShape", 
        "description": "table simpleShapeHandles = sim.ungroupShape(number shapeHandle)Ungroups a compound shape into several simple shapes. See also sim.groupShapes, sim.convexDecompose, sim.getQHull and sim.getDecimatedMesh. shapeHandle: the handles of the shape you wish to ungroup. If you specify for this argument (-2-handleOfShape), then the shape will be divided instead of ungrouped.shapeCount (output): the size of the returned buffer.shapeHandle: the handles of the shape you wish to ungroup. If you specify for this argument (-2-handleOfShape), then the shape will be divided instead of ungrouped.shapeCount (output): the size of the returned buffer.shapeHandle: the handles of the shape you wish to ungroup. If you specify for this argument (-2-handleOfShape), then the shape will be divided instead of ungrouped.shapeCount (output): the size of the returned buffer. a pointer to an array holding the handles of the resulting shapes, or NULL in case of an error. The user is in charge of releasing the array buffer with simReleaseBuffer."
    }, 
    "simx.finish": {
        "body": "simx.finish()", 
        "scope": "source.lua", 
        "prefix": "simx.finish", 
        "description": "simx.finish()Ends the communication thread. This should be the very last remote API function called on the client side. simx.finish should only be called after a successfull call to simx.start. This is a remote API helper function. clientID: the client ID. refer to simx.start. Can be -1 to end all running communication threads."
    }, 
    "sim.displayattribute_nopointclouds": {
        "body": "sim.displayattribute_nopointclouds", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_nopointclouds", 
        "description": "Constants"
    }, 
    "sim.closeModule": {
        "body": "sim.closeModule(${0:sim_handle_all})", 
        "scope": "source.lua", 
        "prefix": "sim.closeModule", 
        "description": "number result = sim.closeModule(sim_handle_all)Releases resources reserved with the sim.openModule command. This command can only be called from the main script. Call it from the main script in the last simulation pass (usually with sim.handle_all argument). sim.closeModule is not available in the C-API. Look at the default main script to get an idea about how to use sim.openModule, sim.handleModule and simCloseModule. - -"
    }, 
    "sim.object_path_type": {
        "body": "sim.object_path_type", 
        "scope": "source.lua", 
        "prefix": "sim.object_path_type", 
        "description": "Constants"
    }, 
    "simx.getModelProperty": {
        "body": "simx.getModelProperty(${0:clientId},${1:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.getModelProperty", 
        "description": "number returnCode,number property= simx.getModelProperty(number clientId,number objectHandle)Retrieves the properties of a model. See also simx.setModelProperty. clientID: the client ID. refer to simx.start.objectHandle: handle of the objectoperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls), or simx.opmode_blocking (depending on the intended usage) returnCode: a remote API function return codeprop: the model property value"
    }, 
    "sim.objectproperty_selectmodelbaseinstead": {
        "body": "sim.objectproperty_selectmodelbaseinstead", 
        "scope": "source.lua", 
        "prefix": "sim.objectproperty_selectmodelbaseinstead", 
        "description": "Constants"
    }, 
    "simB0.destroySubscriber": {
        "body": "simB0.destroySubscriber(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "simB0.destroySubscriber", 
        "description": "simB0.destroySubscriber(string handle)"
    }, 
    "simx.headeroffset_client_time": {
        "body": "simx.headeroffset_client_time", 
        "scope": "source.lua", 
        "prefix": "simx.headeroffset_client_time", 
        "description": "Constants"
    }, 
    "simUI.curve_scatter_shape.square": {
        "body": "simUI.curve_scatter_shape.square", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_scatter_shape.square", 
        "description": "Constants"
    }, 
    "sim.vortex_global_constraintangularcompliance": {
        "body": "sim.vortex_global_constraintangularcompliance", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_global_constraintangularcompliance", 
        "description": "Constants"
    }, 
    "sim.saveModel": {
        "body": "sim.saveModel(${0:modelBaseHandle},${1:filename})", 
        "scope": "source.lua", 
        "prefix": "sim.saveModel", 
        "description": "number result = sim.saveModel(number modelBaseHandle,string filename)Saves a model (an object marked as Object is model base and all other objects in its hierarchy tree). Any existing file with same name will be overwritten. See also sim.loadModel, and sim.saveScene. baseOfModelHandle: handle of an object marked as Object is model basefilename: model filename. The filename extension is required (ttm)baseOfModelHandle: handle of an object marked as Object is model basefilename: model filename. The filename extension is required (ttm) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simx.getIntegerParameter": {
        "body": "simx.getIntegerParameter(${0:clientId},${1:paramIdentifier})", 
        "scope": "source.lua", 
        "prefix": "simx.getIntegerParameter", 
        "description": "number returnCode,number paramValue= simx.getIntegerParameter(number clientId,number paramIdentifier)Retrieves an integer value. See the integer parameter identifiers. See also simx.setIntegerParameter, simx.getBooleanParameter, simx.getFloatingParameter, simx.getArrayParameter and simx.getStringParameter. clientID: the client ID. refer to simx.start.paramIdentifier: an integer parameter identifieroperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking (if not called on a regular basis) returnCode: a remote API function return codeparamValue: the parameter value"
    }, 
    "sim.getScriptAssociatedWithObject": {
        "body": "sim.getScriptAssociatedWithObject(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getScriptAssociatedWithObject", 
        "description": "number scriptHandle = sim.getScriptAssociatedWithObject(number objectHandle)Retrieves a child script's handle based on its associated object. See also sim.getObjectAssociatedWithScript, sim.getCustomizationScriptAssociatedWithObject and sim.associateScriptWithObject. objectHandle: handle of the object that might have a child script associatedobjectHandle: handle of the object that might have a child script associated handle of the child script associated with the object, or -1 if the operation was not successful or the object doesn't have an associated script"
    }, 
    "sim.shapefloatparam_init_velocity_x": {
        "body": "sim.shapefloatparam_init_velocity_x", 
        "scope": "source.lua", 
        "prefix": "sim.shapefloatparam_init_velocity_x", 
        "description": "Constants"
    }, 
    "sim.boolparam_rendering_sensor_handling_enabled": {
        "body": "sim.boolparam_rendering_sensor_handling_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_rendering_sensor_handling_enabled", 
        "description": "Constants"
    }, 
    "sim.intparam_platform": {
        "body": "sim.intparam_platform", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_platform", 
        "description": "Constants"
    }, 
    "simOMPL.compute": {
        "body": "simOMPL.compute(${0:taskHandle},${1:maxTime},${2:maxSimplificationTime=-1.0},${3:stateCnt=0})", 
        "scope": "source.lua", 
        "prefix": "simOMPL.compute", 
        "description": "number result,table states = simOMPL.compute(number taskHandle,number maxTime,number maxSimplificationTime=-1.0,number stateCnt=0)"
    }, 
    "simRRS1.SET_PAYLOAD_PARAMETER": {
        "body": "simRRS1.SET_PAYLOAD_PARAMETER(${0:rcsHandle},${1:storage},${2:frameId},${3:paramNumber})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_PAYLOAD_PARAMETER", 
        "description": "int status= simRRS1.SET_PAYLOAD_PARAMETER(bitstring2 rcsHandle,int storage,string frameId,int paramNumber)"
    }, 
    "sim.vortex_global_constraintangularkineticloss": {
        "body": "sim.vortex_global_constraintangularkineticloss", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_global_constraintangularkineticloss", 
        "description": "Constants"
    }, 
    "package.config": {
        "body": "package.config(${0:...})", 
        "scope": "source.lua", 
        "prefix": "package.config", 
        "description": "5.2,5.3\n\npackage.config"
    }, 
    "simROS.setParamBool": {
        "body": "simROS.setParamBool(${0:name},${1:value})", 
        "scope": "source.lua", 
        "prefix": "simROS.setParamBool", 
        "description": "simROS.setParamBool(string name,bool value)"
    }, 
    "simx.cmdheaderoffset_cmd": {
        "body": "simx.cmdheaderoffset_cmd", 
        "scope": "source.lua", 
        "prefix": "simx.cmdheaderoffset_cmd", 
        "description": "Constants"
    }, 
    "simK3.getInfrared": {
        "body": "simK3.getInfrared(${0:k3Handle},${1:index})", 
        "scope": "source.lua", 
        "prefix": "simK3.getInfrared", 
        "description": "number distance = simK3.getInfrared(number k3Handle,number index)"
    }, 
    "simx.return_illegal_opmode_flag": {
        "body": "simx.return_illegal_opmode_flag", 
        "scope": "source.lua", 
        "prefix": "simx.return_illegal_opmode_flag", 
        "description": "Constants"
    }, 
    "sim.launchThreadedChildScripts": {
        "body": "sim.launchThreadedChildScripts()", 
        "scope": "source.lua", 
        "prefix": "sim.launchThreadedChildScripts", 
        "description": "number launchCount = sim.launchThreadedChildScripts()Starts or restarts (if appropriately flagged) all threaded child scripts. This command should only be called from the main script. Refer also to following related functions: sim.switchThread, sim.setThreadSwitchTiming, sim.setThreadAutomaticSwitch, sim.setThreadIsFree, sim.setThreadResumeLocation and sim.resumeThreads. - -"
    }, 
    "sim.vortex_body_pureshapesasconvex": {
        "body": "sim.vortex_body_pureshapesasconvex", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_pureshapesasconvex", 
        "description": "Constants"
    }, 
    "sim.getConfigForTipPose": {
        "body": "sim.getConfigForTipPose(${0:ikGroupHandle},${1:jointHandles},${2:distanceThreshold},${3:maxTimeInMs},${4:metric=nil},${5:collisionPairs=nil},${6:jointOptions=nil},${7:lowLimits=nil},${8:ranges=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.getConfigForTipPose", 
        "description": "table jointPositions = sim.getConfigForTipPose(number ikGroupHandle,table jointHandles,number distanceThreshold,number maxTimeInMs,table_4 metric=nil,table collisionPairs=nil,table jointOptions=nil,table lowLimits=nil,table ranges=nil)Searches for a manipulator configuration that matches a given end-effector position/orientation in space. Search is randomized. ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.thresholdDist: a distance indicating when IK should be computed in order to try to bring the tip onto the target: since the search algorithm proceeds by generating random configurations, many of them produce a tip pose that is too far from the target pose to run IK successfully. Choosing a large value will result in slow calculations, choosing a small value might produce a smaller subset of solutions. Distance between two poses is calculated using a metric.maxTimeInMs: a maximum time in ms after which the search is aborted.retConfig (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.metric (input): an array to 4 values indicating a metric used to compute pose-pose distances: distance=sqrt((dx*metric[0])^2+(dy*metric[1])^2+(dz*metric[2])^2+(angle*metric[3])^2). Can be NULL for a default metric of {1.0,1.0,1.0,0.1}.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.lowLimits: an optional array pointing to different low limit values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's low limit values. If not NULL, then ranges should also not be NULL.ranges: an optional array pointing to different range values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's range values. If not NULL, then lowLimits should also not be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.thresholdDist: a distance indicating when IK should be computed in order to try to bring the tip onto the target: since the search algorithm proceeds by generating random configurations, many of them produce a tip pose that is too far from the target pose to run IK successfully. Choosing a large value will result in slow calculations, choosing a small value might produce a smaller subset of solutions. Distance between two poses is calculated using a metric.maxTimeInMs: a maximum time in ms after which the search is aborted.retConfig (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.metric (input): an array to 4 values indicating a metric used to compute pose-pose distances: distance=sqrt((dx*metric[0])^2+(dy*metric[1])^2+(dz*metric[2])^2+(angle*metric[3])^2). Can be NULL for a default metric of {1.0,1.0,1.0,0.1}.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.lowLimits: an optional array pointing to different low limit values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's low limit values. If not NULL, then ranges should also not be NULL.ranges: an optional array pointing to different range values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's range values. If not NULL, then lowLimits should also not be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.thresholdDist: a distance indicating when IK should be computed in order to try to bring the tip onto the target: since the search algorithm proceeds by generating random configurations, many of them produce a tip pose that is too far from the target pose to run IK successfully. Choosing a large value will result in slow calculations, choosing a small value might produce a smaller subset of solutions. Distance between two poses is calculated using a metric.maxTimeInMs: a maximum time in ms after which the search is aborted.retConfig (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.metric (input): an array to 4 values indicating a metric used to compute pose-pose distances: distance=sqrt((dx*metric[0])^2+(dy*metric[1])^2+(dz*metric[2])^2+(angle*metric[3])^2). Can be NULL for a default metric of {1.0,1.0,1.0,0.1}.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.lowLimits: an optional array pointing to different low limit values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's low limit values. If not NULL, then ranges should also not be NULL.ranges: an optional array pointing to different range values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's range values. If not NULL, then lowLimits should also not be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.thresholdDist: a distance indicating when IK should be computed in order to try to bring the tip onto the target: since the search algorithm proceeds by generating random configurations, many of them produce a tip pose that is too far from the target pose to run IK successfully. Choosing a large value will result in slow calculations, choosing a small value might produce a smaller subset of solutions. Distance between two poses is calculated using a metric.maxTimeInMs: a maximum time in ms after which the search is aborted.retConfig (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.metric (input): an array to 4 values indicating a metric used to compute pose-pose distances: distance=sqrt((dx*metric[0])^2+(dy*metric[1])^2+(dz*metric[2])^2+(angle*metric[3])^2). Can be NULL for a default metric of {1.0,1.0,1.0,0.1}.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.lowLimits: an optional array pointing to different low limit values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's low limit values. If not NULL, then ranges should also not be NULL.ranges: an optional array pointing to different range values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's range values. If not NULL, then lowLimits should also not be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.thresholdDist: a distance indicating when IK should be computed in order to try to bring the tip onto the target: since the search algorithm proceeds by generating random configurations, many of them produce a tip pose that is too far from the target pose to run IK successfully. Choosing a large value will result in slow calculations, choosing a small value might produce a smaller subset of solutions. Distance between two poses is calculated using a metric.maxTimeInMs: a maximum time in ms after which the search is aborted.retConfig (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.metric (input): an array to 4 values indicating a metric used to compute pose-pose distances: distance=sqrt((dx*metric[0])^2+(dy*metric[1])^2+(dz*metric[2])^2+(angle*metric[3])^2). Can be NULL for a default metric of {1.0,1.0,1.0,0.1}.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.lowLimits: an optional array pointing to different low limit values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's low limit values. If not NULL, then ranges should also not be NULL.ranges: an optional array pointing to different range values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's range values. If not NULL, then lowLimits should also not be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.thresholdDist: a distance indicating when IK should be computed in order to try to bring the tip onto the target: since the search algorithm proceeds by generating random configurations, many of them produce a tip pose that is too far from the target pose to run IK successfully. Choosing a large value will result in slow calculations, choosing a small value might produce a smaller subset of solutions. Distance between two poses is calculated using a metric.maxTimeInMs: a maximum time in ms after which the search is aborted.retConfig (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.metric (input): an array to 4 values indicating a metric used to compute pose-pose distances: distance=sqrt((dx*metric[0])^2+(dy*metric[1])^2+(dz*metric[2])^2+(angle*metric[3])^2). Can be NULL for a default metric of {1.0,1.0,1.0,0.1}.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.lowLimits: an optional array pointing to different low limit values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's low limit values. If not NULL, then ranges should also not be NULL.ranges: an optional array pointing to different range values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's range values. If not NULL, then lowLimits should also not be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.thresholdDist: a distance indicating when IK should be computed in order to try to bring the tip onto the target: since the search algorithm proceeds by generating random configurations, many of them produce a tip pose that is too far from the target pose to run IK successfully. Choosing a large value will result in slow calculations, choosing a small value might produce a smaller subset of solutions. Distance between two poses is calculated using a metric.maxTimeInMs: a maximum time in ms after which the search is aborted.retConfig (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.metric (input): an array to 4 values indicating a metric used to compute pose-pose distances: distance=sqrt((dx*metric[0])^2+(dy*metric[1])^2+(dz*metric[2])^2+(angle*metric[3])^2). Can be NULL for a default metric of {1.0,1.0,1.0,0.1}.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.lowLimits: an optional array pointing to different low limit values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's low limit values. If not NULL, then ranges should also not be NULL.ranges: an optional array pointing to different range values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's range values. If not NULL, then lowLimits should also not be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.thresholdDist: a distance indicating when IK should be computed in order to try to bring the tip onto the target: since the search algorithm proceeds by generating random configurations, many of them produce a tip pose that is too far from the target pose to run IK successfully. Choosing a large value will result in slow calculations, choosing a small value might produce a smaller subset of solutions. Distance between two poses is calculated using a metric.maxTimeInMs: a maximum time in ms after which the search is aborted.retConfig (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.metric (input): an array to 4 values indicating a metric used to compute pose-pose distances: distance=sqrt((dx*metric[0])^2+(dy*metric[1])^2+(dz*metric[2])^2+(angle*metric[3])^2). Can be NULL for a default metric of {1.0,1.0,1.0,0.1}.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.lowLimits: an optional array pointing to different low limit values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's low limit values. If not NULL, then ranges should also not be NULL.ranges: an optional array pointing to different range values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's range values. If not NULL, then lowLimits should also not be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.thresholdDist: a distance indicating when IK should be computed in order to try to bring the tip onto the target: since the search algorithm proceeds by generating random configurations, many of them produce a tip pose that is too far from the target pose to run IK successfully. Choosing a large value will result in slow calculations, choosing a small value might produce a smaller subset of solutions. Distance between two poses is calculated using a metric.maxTimeInMs: a maximum time in ms after which the search is aborted.retConfig (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.metric (input): an array to 4 values indicating a metric used to compute pose-pose distances: distance=sqrt((dx*metric[0])^2+(dy*metric[1])^2+(dz*metric[2])^2+(angle*metric[3])^2). Can be NULL for a default metric of {1.0,1.0,1.0,0.1}.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.lowLimits: an optional array pointing to different low limit values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's low limit values. If not NULL, then ranges should also not be NULL.ranges: an optional array pointing to different range values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's range values. If not NULL, then lowLimits should also not be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.thresholdDist: a distance indicating when IK should be computed in order to try to bring the tip onto the target: since the search algorithm proceeds by generating random configurations, many of them produce a tip pose that is too far from the target pose to run IK successfully. Choosing a large value will result in slow calculations, choosing a small value might produce a smaller subset of solutions. Distance between two poses is calculated using a metric.maxTimeInMs: a maximum time in ms after which the search is aborted.retConfig (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.metric (input): an array to 4 values indicating a metric used to compute pose-pose distances: distance=sqrt((dx*metric[0])^2+(dy*metric[1])^2+(dz*metric[2])^2+(angle*metric[3])^2). Can be NULL for a default metric of {1.0,1.0,1.0,0.1}.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.lowLimits: an optional array pointing to different low limit values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's low limit values. If not NULL, then ranges should also not be NULL.ranges: an optional array pointing to different range values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's range values. If not NULL, then lowLimits should also not be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.thresholdDist: a distance indicating when IK should be computed in order to try to bring the tip onto the target: since the search algorithm proceeds by generating random configurations, many of them produce a tip pose that is too far from the target pose to run IK successfully. Choosing a large value will result in slow calculations, choosing a small value might produce a smaller subset of solutions. Distance between two poses is calculated using a metric.maxTimeInMs: a maximum time in ms after which the search is aborted.retConfig (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.metric (input): an array to 4 values indicating a metric used to compute pose-pose distances: distance=sqrt((dx*metric[0])^2+(dy*metric[1])^2+(dz*metric[2])^2+(angle*metric[3])^2). Can be NULL for a default metric of {1.0,1.0,1.0,0.1}.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.lowLimits: an optional array pointing to different low limit values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's low limit values. If not NULL, then ranges should also not be NULL.ranges: an optional array pointing to different range values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's range values. If not NULL, then lowLimits should also not be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.thresholdDist: a distance indicating when IK should be computed in order to try to bring the tip onto the target: since the search algorithm proceeds by generating random configurations, many of them produce a tip pose that is too far from the target pose to run IK successfully. Choosing a large value will result in slow calculations, choosing a small value might produce a smaller subset of solutions. Distance between two poses is calculated using a metric.maxTimeInMs: a maximum time in ms after which the search is aborted.retConfig (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.metric (input): an array to 4 values indicating a metric used to compute pose-pose distances: distance=sqrt((dx*metric[0])^2+(dy*metric[1])^2+(dz*metric[2])^2+(angle*metric[3])^2). Can be NULL for a default metric of {1.0,1.0,1.0,0.1}.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.lowLimits: an optional array pointing to different low limit values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's low limit values. If not NULL, then ranges should also not be NULL.ranges: an optional array pointing to different range values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's range values. If not NULL, then lowLimits should also not be NULL.reserved: reserved for future extension. Set to NULL.ikGroupHandle: the handle of an IK group that is in charge of bringing the manipulator's tip onto a target. The IK group can also be marked as explicit handling if needed. See also simGetIkGroupHandle.jointCnt: the number of joint handles provided in the jointHandles array.jointHandles (input): an array with jointCnt entries, that specifies the joint handles for the joints we wish to retrieve the values calculated by the IK.thresholdDist: a distance indicating when IK should be computed in order to try to bring the tip onto the target: since the search algorithm proceeds by generating random configurations, many of them produce a tip pose that is too far from the target pose to run IK successfully. Choosing a large value will result in slow calculations, choosing a small value might produce a smaller subset of solutions. Distance between two poses is calculated using a metric.maxTimeInMs: a maximum time in ms after which the search is aborted.retConfig (output): an array with jointCnt entries, that will receive the IK calculated joint values, as specified by the jointHandles array.metric (input): an array to 4 values indicating a metric used to compute pose-pose distances: distance=sqrt((dx*metric[0])^2+(dy*metric[1])^2+(dz*metric[2])^2+(angle*metric[3])^2). Can be NULL for a default metric of {1.0,1.0,1.0,0.1}.collisionPairCnt: the number of collision pairs. Can be 0 if collision checking is not required.collisionPairs: an array containing 2 entity handles for each collision pair. A collision pair is represented by a collider and a collidee, that will be tested against each other. The first pair could be used for robot self-collision testing, and a second pair could be used for robot-environment collision testing. The collider can be an object or a collection handle. The collidee can be an object or collection handle, or sim_handle_all, in which case the collider will be checked agains all other collidable objects in the scene. Can be NULL if collision checking is not required.jointOptions: a bit-coded value corresponding to each specified joint handle. Bit 0 (i.e. 1) indicates the corresponding joint is dependent of another joint. Can be NULL.lowLimits: an optional array pointing to different low limit values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's low limit values. If not NULL, then ranges should also not be NULL.ranges: an optional array pointing to different range values for each specified joint. This can be useful when you wish to explore a sub-set of the joint's intervals. Can be NULL for the default joint's range values. If not NULL, then lowLimits should also not be NULL.reserved: reserved for future extension. Set to NULL. -1 in case of an error, 0 if no result was found, otherwise 1."
    }, 
    "sim.removePointsFromPointCloud": {
        "body": "sim.removePointsFromPointCloud(${0:pointCloudHandle},${1:options},${2:points},${3:tolerance})", 
        "scope": "source.lua", 
        "prefix": "sim.removePointsFromPointCloud", 
        "description": "number totalPointCnt = sim.removePointsFromPointCloud(number pointCloudHandle,number options,table points,number tolerance)Removes points from a point cloud. When a point cloud doesn't use an octree calculation structure, then individual points cannot be removed, only all points can be removed in that case. See also sim.insertPointsIntoPointCloud, sim.setPointCloudOptions and the other point cloud related functions. pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framepts: a pointer to the point positions specified as X/Y/Z coordinates. Set to NULL to remove all pointsptCnt: the number of point coordinates contained in ptstolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framepts: a pointer to the point positions specified as X/Y/Z coordinates. Set to NULL to remove all pointsptCnt: the number of point coordinates contained in ptstolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framepts: a pointer to the point positions specified as X/Y/Z coordinates. Set to NULL to remove all pointsptCnt: the number of point coordinates contained in ptstolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framepts: a pointer to the point positions specified as X/Y/Z coordinates. Set to NULL to remove all pointsptCnt: the number of point coordinates contained in ptstolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framepts: a pointer to the point positions specified as X/Y/Z coordinates. Set to NULL to remove all pointsptCnt: the number of point coordinates contained in ptstolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framepts: a pointer to the point positions specified as X/Y/Z coordinates. Set to NULL to remove all pointsptCnt: the number of point coordinates contained in ptstolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framepts: a pointer to the point positions specified as X/Y/Z coordinates. Set to NULL to remove all pointsptCnt: the number of point coordinates contained in ptstolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULL -1 if operation was not successful, otherwise the total number of points in the point cloud"
    }, 
    "simUI.clearTable": {
        "body": "simUI.clearTable(${0:handle},${1:id},${2:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.clearTable", 
        "description": "simUI.clearTable(number handle,number id,bool suppressEvents=true)"
    }, 
    "sim.getPathLength": {
        "body": "sim.getPathLength(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getPathLength", 
        "description": "number length = sim.getPathLength(number objectHandle)Retrieves the length of a path object. The length is given in meters, but the actual returned length is dependent on the selected path length calculation method for the given path object. See also sim.getPathPosition and sim.setPathPosition. objectHandle: handle of the path objectlength: length of the path given in meters (but dependent on the selected path length calculation method)objectHandle: handle of the path objectlength: length of the path given in meters (but dependent on the selected path length calculation method)objectHandle: handle of the path objectlength: length of the path given in meters (but dependent on the selected path length calculation method) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simB0.call": {
        "body": "simB0.call(${0:handle},${1:payload})", 
        "scope": "source.lua", 
        "prefix": "simB0.call", 
        "description": "string payload simB0.call(string handle,string payload)"
    }, 
    "sim.buttonproperty_borderless": {
        "body": "sim.buttonproperty_borderless", 
        "scope": "source.lua", 
        "prefix": "sim.buttonproperty_borderless", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_a0frictionmaxforce": {
        "body": "sim.vortex_joint_a0frictionmaxforce", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a0frictionmaxforce", 
        "description": "Constants"
    }, 
    "sim.getObjectHandle": {
        "body": "sim.getObjectHandle(${0:objectName})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectHandle", 
        "description": "number objectHandle = sim.getObjectHandle(string objectName)Retrieves an object handle based on its name. The operation of this function depends on the current name suffix settings (see sim.getNameSuffix, sim.setNameSuffix, and the section on accessing general-type objects). See also sim.isHandleValid and sim.getObjectUniqueIdentifier. objectName: name of object. If the name is appended by a @alt suffix, then the object handle based on the object's alternative name will be retrieved. If the name is appended by a @silentError suffix, then no error will be output if the object does not exist.objectName: name of object. If the name is appended by a @alt suffix, then the object handle based on the object's alternative name will be retrieved. If the name is appended by a @silentError suffix, then no error will be output if the object does not exist. handle of object or -1 if operation was not successful"
    }, 
    "sim.scripttype_mainscript": {
        "body": "sim.scripttype_mainscript", 
        "scope": "source.lua", 
        "prefix": "sim.scripttype_mainscript", 
        "description": "Constants"
    }, 
    "sim.launchExecutable": {
        "body": "sim.launchExecutable(${0:filename},${1:parameters=''},${2:showStatus=1})", 
        "scope": "source.lua", 
        "prefix": "sim.launchExecutable", 
        "description": "number result = sim.launchExecutable(string filename,string parameters='',number showStatus=1)Launches an executable. Similar to os.execute or io.popen, but is system independent. - -"
    }, 
    "sim.shapeintparam_compound": {
        "body": "sim.shapeintparam_compound", 
        "scope": "source.lua", 
        "prefix": "sim.shapeintparam_compound", 
        "description": "Constants"
    }, 
    "sim.vortex_body_primlinearaxisfriction": {
        "body": "sim.vortex_body_primlinearaxisfriction", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_primlinearaxisfriction", 
        "description": "Constants"
    }, 
    "simx.getObjectIntParameter": {
        "body": "simx.getObjectIntParameter(${0:clientId},${1:objectHandle},${2:parameterId})", 
        "scope": "source.lua", 
        "prefix": "simx.getObjectIntParameter", 
        "description": "number returnCode,number parameterValue= simx.getObjectIntParameter(number clientId,number objectHandle,number parameterId)Retrieves an integer parameter of a object. See also simx.setObjectIntParameter and simx.getObjectFloatParameter. clientID: the client ID. refer to simx.start.objectHandle: handle of the objectparameterID: identifier of the parameter to retrieve. See the list of all possible object parameter identifiersoperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls), or simx.opmode_blocking (depending on the intended usage) returnCode: a remote API function return codeparameterValue: the value of the parameter"
    }, 
    "sim.particle_particlerespondable": {
        "body": "sim.particle_particlerespondable", 
        "scope": "source.lua", 
        "prefix": "sim.particle_particlerespondable", 
        "description": "Constants"
    }, 
    "sim.displayattribute_nodrawingobjects": {
        "body": "sim.displayattribute_nodrawingobjects", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_nodrawingobjects", 
        "description": "Constants"
    }, 
    "sysCall_addOnScriptSuspend": {
        "body": "sysCall_addOnScriptSuspend(${0:suspended.})", 
        "scope": "source.lua", 
        "prefix": "sysCall_addOnScriptSuspend", 
        "description": "sysCall_addOnScriptSuspend(Called just before the add-on script execution gets suspended.)"
    }, 
    "sim.bullet_body_nondefaultcollisionmargingfactor": {
        "body": "sim.bullet_body_nondefaultcollisionmargingfactor", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_body_nondefaultcollisionmargingfactor", 
        "description": "Constants"
    }, 
    "sim.setObjectProperty": {
        "body": "sim.setObjectProperty(${0:objectHandle},${1:property})", 
        "scope": "source.lua", 
        "prefix": "sim.setObjectProperty", 
        "description": "number result = sim.setObjectProperty(number objectHandle,number property)Sets the properties of a scene object. See also sim.getObjectProperty, sim.setObjectSpecialProperty and sim.setModelProperty. objectHandle: object handleprop: object property. See the object property values. Combine them with the or-operatorobjectHandle: object handleprop: object property. See the object property values. Combine them with the or-operatorobjectHandle: object handleprop: object property. See the object property values. Combine them with the or-operator -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simUI.curve_type.time": {
        "body": "simUI.curve_type.time", 
        "scope": "source.lua", 
        "prefix": "simUI.curve_type.time", 
        "description": "Constants"
    }, 
    "sim.getScriptSimulationParameter": {
        "body": "sim.getScriptSimulationParameter(${0:scriptHandle},${1:parameterName},${2:forceStringReturn=false})", 
        "scope": "source.lua", 
        "prefix": "sim.getScriptSimulationParameter", 
        "description": "boolean/number/string parameterValue = sim.getScriptSimulationParameter(number scriptHandle,string parameterName,boolean forceStringReturn=false)Retrieves a main script's or child script's parameter from its simulation parameter list. Useful for simple interaction with the user, or for simple parameter exchange with other scripts. See also sim.setScriptSimulationParameter, and the data packing/unpacking functions. scriptHandle: handle of the main script or child script, or sim_handle_main_script or sim_handle_all. When scriptHandle is sim_handle_all, the function returns only one matching parameter encountered (other matching parameters might be different)parameterName: name of the parameter to retrieveparameterLength: the number of bytes that compose the value of the parameter (excluding the terminal zero)scriptHandle: handle of the main script or child script, or sim_handle_main_script or sim_handle_all. When scriptHandle is sim_handle_all, the function returns only one matching parameter encountered (other matching parameters might be different)parameterName: name of the parameter to retrieveparameterLength: the number of bytes that compose the value of the parameter (excluding the terminal zero)scriptHandle: handle of the main script or child script, or sim_handle_main_script or sim_handle_all. When scriptHandle is sim_handle_all, the function returns only one matching parameter encountered (other matching parameters might be different)parameterName: name of the parameter to retrieveparameterLength: the number of bytes that compose the value of the parameter (excluding the terminal zero)scriptHandle: handle of the main script or child script, or sim_handle_main_script or sim_handle_all. When scriptHandle is sim_handle_all, the function returns only one matching parameter encountered (other matching parameters might be different)parameterName: name of the parameter to retrieveparameterLength: the number of bytes that compose the value of the parameter (excluding the terminal zero) value of the parameter or NULL if parameterName does not exist for the given script, or in case of an error. The user is in charge of releasing the returned value with simReleaseBuffer. The returned pointer points to parameterLength byte values, terminated by a terminal zero (the returned buffer may however contain several embedded zeros)."
    }, 
    "sim.followPath": {
        "body": "sim.followPath(${0:objectHandle},${1:pathHandle},${2:positionAndOrOrientation},${3:relativeDistanceOnPath},${4:velocity},${5:accel})", 
        "scope": "source.lua", 
        "prefix": "sim.followPath", 
        "description": "number deltaTimeLeft = sim.followPath(number objectHandle,number pathHandle,number positionAndOrOrientation,number relativeDistanceOnPath,number velocity,number accel)Moves an object along a path object. This function can only be called from child scripts running in a thread (since this is a blocking operation) and is not available from the C-API. See also sim.rmlPos, sim.rmlVel and sim.moveToObject. - -"
    }, 
    "sim.vortex_joint_p2frictioncoeff": {
        "body": "sim.vortex_joint_p2frictioncoeff", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p2frictioncoeff", 
        "description": "Constants"
    }, 
    "simUI.setProgress": {
        "body": "simUI.setProgress(${0:handle},${1:id},${2:value})", 
        "scope": "source.lua", 
        "prefix": "simUI.setProgress", 
        "description": "simUI.setProgress(number handle,number id,number value)"
    }, 
    "sim.pure_primitive_plane": {
        "body": "sim.pure_primitive_plane", 
        "scope": "source.lua", 
        "prefix": "sim.pure_primitive_plane", 
        "description": "Constants"
    }, 
    "sim.objintparam_manipulation_permissions": {
        "body": "sim.objintparam_manipulation_permissions", 
        "scope": "source.lua", 
        "prefix": "sim.objintparam_manipulation_permissions", 
        "description": "Constants"
    }, 
    "string.unpack": {
        "body": "string.unpack(${0:...})", 
        "scope": "source.lua", 
        "prefix": "string.unpack", 
        "description": "5.3\n\nstring.unpack (fmt, s [, pos])"
    }, 
    "sim.colorcomponent_diffuse": {
        "body": "sim.colorcomponent_diffuse", 
        "scope": "source.lua", 
        "prefix": "sim.colorcomponent_diffuse", 
        "description": "Constants"
    }, 
    "simx.setJointPosition": {
        "body": "simx.setJointPosition(${0:clientId},${1:jointHandle},${2:position})", 
        "scope": "source.lua", 
        "prefix": "simx.setJointPosition", 
        "description": "number returnCode= simx.setJointPosition(number clientId,number jointHandle,number position)Sets the intrinsic position of a joint. May have no effect depending on the joint mode. This function cannot be used with spherical joints (use simx.setSphericalJointMatrix instead). If you want to set several joints that should be applied at the exact same time on the V-REP side, then use simx.pauseCommunication. See also simx.getJointPosition and simx.setJointTargetPosition. clientID: the client ID. refer to simx.start.jointHandle: handle of the jointposition: position of the joint (angular or linear value depending on the joint type)operationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_oneshot or simx.opmode_streaming returnCode: a remote API function return code"
    }, 
    "rawset": {
        "body": "rawset(${0:...})", 
        "scope": "source.lua", 
        "prefix": "rawset", 
        "description": "5.1,5.2,5.3\n\nrawset (table, index, value)"
    }, 
    "sim.texturemap_cylinder": {
        "body": "sim.texturemap_cylinder", 
        "scope": "source.lua", 
        "prefix": "sim.texturemap_cylinder", 
        "description": "Constants"
    }, 
    "sim.auxiliaryConsoleOpen": {
        "body": "sim.auxiliaryConsoleOpen(${0:title},${1:maxLines},${2:mode},${3:position=nil},${4:size=nil},${5:textColor=nil},${6:backgroundColor=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.auxiliaryConsoleOpen", 
        "description": "number consoleHandle = sim.auxiliaryConsoleOpen(string title,number maxLines,number mode,table_2 position=nil,table_2 size=nil,table_3 textColor=nil,table_3 backgroundColor=nil)Opens an auxiliary console window for text display. This console window is different from the application main console window. Console window handles are shared across all simulator scenes. See also sim.auxiliaryConsolePrint, sim.auxiliaryConsoleClose and sim.addStatusbarMessage. title: the title of the console windowmaxLines: the number of text lines that can be displayed and bufferedmode: bit-coded value. Bit0 (1) set indicates that the console window will automatically close at simulation end (when called from a simulation script, the consle window will always automatically close at simulation end), bit1 (2) set indicates that lines will be wrapped, bit2 (4) set indicates that the user can close the console window, bit3 (8) set indicates that the console will automatically be hidden during simulation pause, bit4 (16) set indicates that the console will not automatically hide when the user switches to another scene.position: the initial position of the console window (x and y value). Can be NULLsize: the initial size of the console window (x and y value). Can be NULLtextColor: the color of the text (rgb values, 0-1). Can be NULLbackgroundColor: the background color of the console window (rgb values, 0-1). Can be NULLtitle: the title of the console windowmaxLines: the number of text lines that can be displayed and bufferedmode: bit-coded value. Bit0 (1) set indicates that the console window will automatically close at simulation end (when called from a simulation script, the consle window will always automatically close at simulation end), bit1 (2) set indicates that lines will be wrapped, bit2 (4) set indicates that the user can close the console window, bit3 (8) set indicates that the console will automatically be hidden during simulation pause, bit4 (16) set indicates that the console will not automatically hide when the user switches to another scene.position: the initial position of the console window (x and y value). Can be NULLsize: the initial size of the console window (x and y value). Can be NULLtextColor: the color of the text (rgb values, 0-1). Can be NULLbackgroundColor: the background color of the console window (rgb values, 0-1). Can be NULLtitle: the title of the console windowmaxLines: the number of text lines that can be displayed and bufferedmode: bit-coded value. Bit0 (1) set indicates that the console window will automatically close at simulation end (when called from a simulation script, the consle window will always automatically close at simulation end), bit1 (2) set indicates that lines will be wrapped, bit2 (4) set indicates that the user can close the console window, bit3 (8) set indicates that the console will automatically be hidden during simulation pause, bit4 (16) set indicates that the console will not automatically hide when the user switches to another scene.position: the initial position of the console window (x and y value). Can be NULLsize: the initial size of the console window (x and y value). Can be NULLtextColor: the color of the text (rgb values, 0-1). Can be NULLbackgroundColor: the background color of the console window (rgb values, 0-1). Can be NULLtitle: the title of the console windowmaxLines: the number of text lines that can be displayed and bufferedmode: bit-coded value. Bit0 (1) set indicates that the console window will automatically close at simulation end (when called from a simulation script, the consle window will always automatically close at simulation end), bit1 (2) set indicates that lines will be wrapped, bit2 (4) set indicates that the user can close the console window, bit3 (8) set indicates that the console will automatically be hidden during simulation pause, bit4 (16) set indicates that the console will not automatically hide when the user switches to another scene.position: the initial position of the console window (x and y value). Can be NULLsize: the initial size of the console window (x and y value). Can be NULLtextColor: the color of the text (rgb values, 0-1). Can be NULLbackgroundColor: the background color of the console window (rgb values, 0-1). Can be NULLtitle: the title of the console windowmaxLines: the number of text lines that can be displayed and bufferedmode: bit-coded value. Bit0 (1) set indicates that the console window will automatically close at simulation end (when called from a simulation script, the consle window will always automatically close at simulation end), bit1 (2) set indicates that lines will be wrapped, bit2 (4) set indicates that the user can close the console window, bit3 (8) set indicates that the console will automatically be hidden during simulation pause, bit4 (16) set indicates that the console will not automatically hide when the user switches to another scene.position: the initial position of the console window (x and y value). Can be NULLsize: the initial size of the console window (x and y value). Can be NULLtextColor: the color of the text (rgb values, 0-1). Can be NULLbackgroundColor: the background color of the console window (rgb values, 0-1). Can be NULLtitle: the title of the console windowmaxLines: the number of text lines that can be displayed and bufferedmode: bit-coded value. Bit0 (1) set indicates that the console window will automatically close at simulation end (when called from a simulation script, the consle window will always automatically close at simulation end), bit1 (2) set indicates that lines will be wrapped, bit2 (4) set indicates that the user can close the console window, bit3 (8) set indicates that the console will automatically be hidden during simulation pause, bit4 (16) set indicates that the console will not automatically hide when the user switches to another scene.position: the initial position of the console window (x and y value). Can be NULLsize: the initial size of the console window (x and y value). Can be NULLtextColor: the color of the text (rgb values, 0-1). Can be NULLbackgroundColor: the background color of the console window (rgb values, 0-1). Can be NULLtitle: the title of the console windowmaxLines: the number of text lines that can be displayed and bufferedmode: bit-coded value. Bit0 (1) set indicates that the console window will automatically close at simulation end (when called from a simulation script, the consle window will always automatically close at simulation end), bit1 (2) set indicates that lines will be wrapped, bit2 (4) set indicates that the user can close the console window, bit3 (8) set indicates that the console will automatically be hidden during simulation pause, bit4 (16) set indicates that the console will not automatically hide when the user switches to another scene.position: the initial position of the console window (x and y value). Can be NULLsize: the initial size of the console window (x and y value). Can be NULLtextColor: the color of the text (rgb values, 0-1). Can be NULLbackgroundColor: the background color of the console window (rgb values, 0-1). Can be NULL -1 if operation was not successful. Otherwise a console window handle"
    }, 
    "sim.newton_body_staticfriction": {
        "body": "sim.newton_body_staticfriction", 
        "scope": "source.lua", 
        "prefix": "sim.newton_body_staticfriction", 
        "description": "Constants"
    }, 
    "sim.vortex_body_autosleepsteplivethreshold": {
        "body": "sim.vortex_body_autosleepsteplivethreshold", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_autosleepsteplivethreshold", 
        "description": "Constants"
    }, 
    "simRRS1.SELECT_TRAJECTORY_MODE": {
        "body": "simRRS1.SELECT_TRAJECTORY_MODE(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SELECT_TRAJECTORY_MODE", 
        "description": "int status= simRRS1.SELECT_TRAJECTORY_MODE(bitstring2 rcsHandle)"
    }, 
    "simx.getLastCmdTime": {
        "body": "simx.getLastCmdTime()", 
        "scope": "source.lua", 
        "prefix": "simx.getLastCmdTime", 
        "description": "number simulationTimeInMs= simx.getLastCmdTime()Retrieves the simulation time of the last fetched command (i.e. when the last fetched command was processed on the server side). The function can be used to verify how fresh a command reply is, or whether a command reply was recently updated. For example:local ret,img=simx.getVisionSensorImage(cid,handle,0,sim.opmode_buffer)if ret==simx.return_ok then    imageAcquisitionTime=simx.getLastCmdTime(cid)endIf some streaming commands are running, simx.getLastCmdTime will always retrieve the current simulation time, otherwise, only the simulation time of the last command that retrieved data from V-REP. This is a remote API helper function. clientID: the client ID. refer to simx.start. simulationTime: the simulation time in milliseconds when the command reply was generated, or 0 if simulation was not running."
    }, 
    "simMTB.getOutput": {
        "body": "simMTB.getOutput()", 
        "scope": "source.lua", 
        "prefix": "simMTB.getOutput", 
        "description": "table_4 outputValues= simMTB.getOutput()"
    }, 
    "debug.debug": {
        "body": "debug.debug()", 
        "scope": "source.lua", 
        "prefix": "debug.debug", 
        "description": "5.1,5.2,5.3\n\ndebug.debug ()"
    }, 
    "sim.simulation_advancing_abouttostop": {
        "body": "sim.simulation_advancing_abouttostop", 
        "scope": "source.lua", 
        "prefix": "sim.simulation_advancing_abouttostop", 
        "description": "Constants"
    }, 
    "sim.getModelProperty": {
        "body": "sim.getModelProperty(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getModelProperty", 
        "description": "number property = sim.getModelProperty(number objectHandle)Retrieves the properties of a model. See also sim.setModelProperty, sim.getObjectProperty and sim.getObjectSpecialProperty. objectHandle: handle of the object that serves as the model baseobjectHandle: handle of the object that serves as the model base model property values, or -1 if operation was not successful"
    }, 
    "simK3.setEncoders": {
        "body": "simK3.setEncoders(${0:k3Handle},${1:leftEncoderValue},${2:rightEncoderValue})", 
        "scope": "source.lua", 
        "prefix": "simK3.setEncoders", 
        "description": "boolean result = simK3.setEncoders(number k3Handle,number leftEncoderValue,number rightEncoderValue)"
    }, 
    "sim.getQHull": {
        "body": "sim.getQHull(${0:verticesIn})", 
        "scope": "source.lua", 
        "prefix": "sim.getQHull", 
        "description": "table verticesOut,table indicesOut = sim.getQHull(table verticesIn)Retrieves the convex hull mesh from the specified vertices. See also sim.convexDecompose and sim.getDecimatedMesh. inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).reserved1: reserved, set to 0.reserved2: reserved, set to NULL.inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).reserved1: reserved, set to 0.reserved2: reserved, set to NULL.inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).reserved1: reserved, set to 0.reserved2: reserved, set to NULL.inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).reserved1: reserved, set to 0.reserved2: reserved, set to NULL.inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).reserved1: reserved, set to 0.reserved2: reserved, set to NULL.inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).reserved1: reserved, set to 0.reserved2: reserved, set to NULL.inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).reserved1: reserved, set to 0.reserved2: reserved, set to NULL.inVertices: a pointer to the input vertices (succession of x/y/z values).inVerticesL: the number of input vertices times 3.verticesOut: a pointer to a pointer to the output vertices. The output vertices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.verticesOutL: a pointer to the number of output vertices times 3.indicesOut: a pointer to a pointer to the output indices. The output indices are allocated by V-REP and the user is in charge of releasing the buffer via simReleaseBuffer.indicesOutL: a pointer to the number of output indices (i.e. the number of triangles times 3).reserved1: reserved, set to 0.reserved2: reserved, set to NULL. -1 or 0 if operation was not successful."
    }, 
    "sim.intparam_mouse_buttons": {
        "body": "sim.intparam_mouse_buttons", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_mouse_buttons", 
        "description": "Constants"
    }, 
    "sim.floatparam_simulation_time_step": {
        "body": "sim.floatparam_simulation_time_step", 
        "scope": "source.lua", 
        "prefix": "sim.floatparam_simulation_time_step", 
        "description": "Constants"
    }, 
    "sim.dlgstyle_dont_center": {
        "body": "sim.dlgstyle_dont_center", 
        "scope": "source.lua", 
        "prefix": "sim.dlgstyle_dont_center", 
        "description": "Constants"
    }, 
    "sim.drawing_itemtransparency": {
        "body": "sim.drawing_itemtransparency", 
        "scope": "source.lua", 
        "prefix": "sim.drawing_itemtransparency", 
        "description": "Constants"
    }, 
    "sim.getVisionSensorImage": {
        "body": "sim.getVisionSensorImage(${0:sensorHandle},${1:posX=0},${2:posY=0},${3:sizeX=0},${4:sizeY=0},${5:returnType=0})", 
        "scope": "source.lua", 
        "prefix": "sim.getVisionSensorImage", 
        "description": "table/string imageBuffer = sim.getVisionSensorImage(number sensorHandle,number posX=0,number posY=0,number sizeX=0,number sizeY=0,number returnType=0)Retrieves the rgb-image (or a portion of it) of a vision sensor. Use sim.getVisionSensorResolution to know the resolution of the full image. The returned data doesn't make sense if sim.handleVisionSensor wasn't called previously  (sim.handleVisionSensor is called by default in the main script if the vision sensor is not tagged as explicit handling). See also sim.getVisionSensorCharImage and sim.setVisionSensorImage. sensorHandle: handle of the vision sensor.   Can be combined with sim_handleflag_greyscale (simply add sim_handleflag_greyscale to sensorHandle), if you wish to retrieve the grey scale equivalent.sensorHandle: handle of the vision sensor.   Can be combined with sim_handleflag_greyscale (simply add sim_handleflag_greyscale to sensorHandle), if you wish to retrieve the grey scale equivalent. image buffer (buffer size is resolutionX*resolutionY*3 or resolutionX*resolutionY in case of a grey scale image retrieval) or NULL in case of an error. The user is in charge of releasing the returned buffer with simReleaseBuffer. Returned values are in the range of 0-1 (0=min. intensity, 1=max. intensity)"
    }, 
    "simx.createDummy": {
        "body": "simx.createDummy(${0:clientId},${1:size},${2:colors})", 
        "scope": "source.lua", 
        "prefix": "simx.createDummy", 
        "description": "number returnCode,number dummyHandle= simx.createDummy(number clientId,number size,table_12 colors)Creates a dummy in the scene. clientID: the client ID. refer to simx.start.size: the size of the dummy.colors: a table of 4*3 values (0-255) for ambient_diffuse RGB, 3 reserved values (set to zero), specular RGB and emissive RGB. Can be nil for default colors.operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking returnCode: a remote API function return codedummyHandle: the dummy handle."
    }, 
    "sim.boolparam_exit_request": {
        "body": "sim.boolparam_exit_request", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_exit_request", 
        "description": "Constants"
    }, 
    "math.deg": {
        "body": "math.deg( ${1:x} )", 
        "scope": "source.lua", 
        "prefix": "math.deg", 
        "description": "5.1,5.2,5.3\n\nmath.deg"
    }, 
    "sim.bullet_constraintsolvertype_sequentialimpulse": {
        "body": "sim.bullet_constraintsolvertype_sequentialimpulse", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_constraintsolvertype_sequentialimpulse", 
        "description": "Constants"
    }, 
    "sim.displayattribute_colorcodedpickpass": {
        "body": "sim.displayattribute_colorcodedpickpass", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_colorcodedpickpass", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_p0loss": {
        "body": "sim.vortex_joint_p0loss", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p0loss", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_frictionproportionalbc": {
        "body": "sim.vortex_joint_frictionproportionalbc", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_frictionproportionalbc", 
        "description": "Constants"
    }, 
    "sim.displayattribute_noopenglcallbacks": {
        "body": "sim.displayattribute_noopenglcallbacks", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_noopenglcallbacks", 
        "description": "Constants"
    }, 
    "sim.getCollectionObjects": {
        "body": "sim.getCollectionObjects(${0:collectionHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getCollectionObjects", 
        "description": "table objectHandles = sim.getCollectionObjects(number collectionHandle)Retrieves the object handles that compose a given collection. collectionHandle: handle of the collectionobjectCount: pointer to a value receiving the number of returned object handlescollectionHandle: handle of the collectionobjectCount: pointer to a value receiving the number of returned object handles pointer to n object handles, or NULL if an error occurred. The user is in charge of destroying the returned buffer with simReleaseBuffer"
    }, 
    "simUI.line_style.dotted": {
        "body": "simUI.line_style.dotted", 
        "scope": "source.lua", 
        "prefix": "simUI.line_style.dotted", 
        "description": "Constants"
    }, 
    "sim.intparam_work_thread_calc_time_ms": {
        "body": "sim.intparam_work_thread_calc_time_ms", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_work_thread_calc_time_ms", 
        "description": "Constants"
    }, 
    "sim.tubeRead": {
        "body": "sim.tubeRead(${0:tubeHandle},${1:blockingOperation=false})", 
        "scope": "source.lua", 
        "prefix": "sim.tubeRead", 
        "description": "string data = sim.tubeRead(number tubeHandle,boolean blockingOperation=false)Receives a data packet from a communication tube previously opened with sim.tubeOpen. The tube needs to be connected (see sim.tubeStatus). tubeHandle: the handle of the tube that was returned by the simTubeOpen function.dataLength: size of the returned data packettubeHandle: the handle of the tube that was returned by the simTubeOpen function.dataLength: size of the returned data packettubeHandle: the handle of the tube that was returned by the simTubeOpen function.dataLength: size of the returned data packet Pointer to a data packet, or NULL if nothing could be read. The user is in charge of releasing the returned buffer with simReleaseBuffer."
    }, 
    "sim.resetCollision": {
        "body": "sim.resetCollision(${0:collisionObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.resetCollision", 
        "description": "number result = sim.resetCollision(number collisionObjectHandle)Clears the collision state, colors, intersections, etc. for a registered collision object. See also sim.handleCollision. collisionObjectHandle: handle of the collision object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all registered collision objects, while sim_handle_all_except_explicit will only reset those that are not marked as explicit handling)collisionObjectHandle: handle of the collision object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all registered collision objects, while sim_handle_all_except_explicit will only reset those that are not marked as explicit handling) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.getApiInfo": {
        "body": "sim.getApiInfo(${0:scriptHandleOrType},${1:apiWord})", 
        "scope": "source.lua", 
        "prefix": "sim.getApiInfo", 
        "description": "string info = sim.getApiInfo(number scriptHandleOrType,string apiWord)Returns the call tip (or info text) for an API function or variable. See also sim.getApiFunc. scriptHandleOrType: the handle of the script, otherwise the type of the script.apiWord: the API functions or variable to retrieve the info for, e.g. sim.getObjectHandlescriptHandleOrType: the handle of the script, otherwise the type of the script.apiWord: the API functions or variable to retrieve the info for, e.g. sim.getObjectHandle NULL in case of an error, or if there is no information. Otherwise the information related to the API function or variable. The user is in charge of releasing the returned buffer with simReleaseBuffer."
    }, 
    "sim.dummyfloatparam_follow_path_offset": {
        "body": "sim.dummyfloatparam_follow_path_offset", 
        "scope": "source.lua", 
        "prefix": "sim.dummyfloatparam_follow_path_offset", 
        "description": "Constants"
    }, 
    "math.tan": {
        "body": "math.tan( ${1:x} )", 
        "scope": "source.lua", 
        "prefix": "math.tan", 
        "description": "5.1,5.2,5.3\n\nmath.tan"
    }, 
    "sim.customizationscriptcall_simulationpause": {
        "body": "sim.customizationscriptcall_simulationpause", 
        "scope": "source.lua", 
        "prefix": "sim.customizationscriptcall_simulationpause", 
        "description": "Constants"
    }, 
    "simROS.publish": {
        "body": "simROS.publish(${0:publisherHandle},${1:message})", 
        "scope": "source.lua", 
        "prefix": "simROS.publish", 
        "description": "simROS.publish(number publisherHandle,table message)"
    }, 
    "simRRS1.GET_HOME_JOINT_POSITION": {
        "body": "simRRS1.GET_HOME_JOINT_POSITION()", 
        "scope": "source.lua", 
        "prefix": "simRRS1.GET_HOME_JOINT_POSITION", 
        "description": "int status,jointPosType homePosition= simRRS1.GET_HOME_JOINT_POSITION()"
    }, 
    "sim.dynmat_wheel": {
        "body": "sim.dynmat_wheel", 
        "scope": "source.lua", 
        "prefix": "sim.dynmat_wheel", 
        "description": "Constants"
    }, 
    "simRRS1.GET_MESSAGE": {
        "body": "simRRS1.GET_MESSAGE(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.GET_MESSAGE", 
        "description": "int status,int severity,string text= simRRS1.GET_MESSAGE(bitstring2 rcsHandle)"
    }, 
    "sim.pure_primitive_spheroid": {
        "body": "sim.pure_primitive_spheroid", 
        "scope": "source.lua", 
        "prefix": "sim.pure_primitive_spheroid", 
        "description": "Constants"
    }, 
    "sim.setScriptAttribute": {
        "body": "sim.setScriptAttribute(${0:scriptHandle},${1:attributeID},${2:attribute})", 
        "scope": "source.lua", 
        "prefix": "sim.setScriptAttribute", 
        "description": "number result = sim.setScriptAttribute(number scriptHandle,number attributeID,number/boolean attribute)Sets various script attributes or properties. See also sim.getScriptAttribute. scriptHandle: handle of a scriptattributeID: the script attributeIDfloatVal: the floating point attribute (if applicable)intOrBoolVal: the integer or Boolean attribute (if applicable)scriptHandle: handle of a scriptattributeID: the script attributeIDfloatVal: the floating point attribute (if applicable)intOrBoolVal: the integer or Boolean attribute (if applicable)scriptHandle: handle of a scriptattributeID: the script attributeIDfloatVal: the floating point attribute (if applicable)intOrBoolVal: the integer or Boolean attribute (if applicable)scriptHandle: handle of a scriptattributeID: the script attributeIDfloatVal: the floating point attribute (if applicable)intOrBoolVal: the integer or Boolean attribute (if applicable) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "debug.getupvalue": {
        "body": "debug.getupvalue( ${1:f}, ${2:up} )", 
        "scope": "source.lua", 
        "prefix": "debug.getupvalue", 
        "description": "5.1,5.2,5.3\n\ndebug.getupvalue (f, up)"
    }, 
    "simRRS1.SET_OVERRIDE_SPEED": {
        "body": "simRRS1.SET_OVERRIDE_SPEED(${0:rcsHandle},${1:correctionValue})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_OVERRIDE_SPEED", 
        "description": "int status= simRRS1.SET_OVERRIDE_SPEED(bitstring2 rcsHandle,real correctionValue)"
    }, 
    "simUI.setEnabled": {
        "body": "simUI.setEnabled(${0:handle},${1:id},${2:enabled},${3:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setEnabled", 
        "description": "simUI.setEnabled(number handle,number id,bool enabled,bool suppressEvents=true)"
    }, 
    "sim.associateScriptWithObject": {
        "body": "sim.associateScriptWithObject(${0:scriptHandle},${1:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.associateScriptWithObject", 
        "description": "number result = sim.associateScriptWithObject(number scriptHandle,number objectHandle)Sets the associated object of a child script. Use with care when simulation is running. See also sim.getObjectAssociatedWithScript, sim.addScript and sim.setScriptText.  scriptHandle: handle of the child scriptobjectHandle: handle of the associated object, or -1 to remove the associationscriptHandle: handle of the child scriptobjectHandle: handle of the associated object, or -1 to remove the associationscriptHandle: handle of the child scriptobjectHandle: handle of the associated object, or -1 to remove the association -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.vortex_global_autosleep": {
        "body": "sim.vortex_global_autosleep", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_global_autosleep", 
        "description": "Constants"
    }, 
    "sim.arrayparam_background_color2": {
        "body": "sim.arrayparam_background_color2", 
        "scope": "source.lua", 
        "prefix": "sim.arrayparam_background_color2", 
        "description": "Constants"
    }, 
    "sim.bullet_global_fullinternalscaling": {
        "body": "sim.bullet_global_fullinternalscaling", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_global_fullinternalscaling", 
        "description": "Constants"
    }, 
    "sim.arrayparam_background_color1": {
        "body": "sim.arrayparam_background_color1", 
        "scope": "source.lua", 
        "prefix": "sim.arrayparam_background_color1", 
        "description": "Constants"
    }, 
    "sim.handle_tree": {
        "body": "sim.handle_tree", 
        "scope": "source.lua", 
        "prefix": "sim.handle_tree", 
        "description": "Constants"
    }, 
    "simx.setIntegerParameter": {
        "body": "simx.setIntegerParameter(${0:clientId},${1:paramIdentifier},${2:paramValue})", 
        "scope": "source.lua", 
        "prefix": "simx.setIntegerParameter", 
        "description": "number returnCode= simx.setIntegerParameter(number clientId,number paramIdentifier,number paramValue)Sets an integer parameter. See also simx.getIntegerParameter, simx.setBooleanParameter, simx.setArrayParameter and simx.setFloatingParameter. clientID: the client ID. refer to simx.start.paramIdentifier: an integer parameter identifierparamValue: the parameter valueoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "sim.setShapeMassAndInertia": {
        "body": "sim.setShapeMassAndInertia(${0:shapeHandle},${1:mass},${2:inertiaMatrix},${3:centerOfMass},${4:transformation=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.setShapeMassAndInertia", 
        "description": "number result = sim.setShapeMassAndInertia(number shapeHandle,number mass,table_9 inertiaMatrix,table_3 centerOfMass,table_12 transformation=nil)Applies mass and inertia information to a shape. If simulation is running, the shape will be dynamically reset (similar to calling sim.resetDynamicObject right after). See also sim.getShapeMassAndInertia, sim.getObjectMatrix and sim.buildMatrix. shapeHandle: handle of the shape objectmass: the new mass of the objectinertia matrix: the new inertia matrix or tensor (9 values), expressed relative to the center of mass. The matrix should be relative to the orientational frame of transformation (see further below). centerOfMass: the new position of the center of mass, relative to the specified transformation (see next item).transformation: the transformation matrix (12 values) relative to which we specify the data. Can be NULL, in which case the data is relative to the absolute reference frame. See here to see how matrix transformations are specified in V-REP.shapeHandle: handle of the shape objectmass: the new mass of the objectinertia matrix: the new inertia matrix or tensor (9 values), expressed relative to the center of mass. The matrix should be relative to the orientational frame of transformation (see further below). centerOfMass: the new position of the center of mass, relative to the specified transformation (see next item).transformation: the transformation matrix (12 values) relative to which we specify the data. Can be NULL, in which case the data is relative to the absolute reference frame. See here to see how matrix transformations are specified in V-REP.shapeHandle: handle of the shape objectmass: the new mass of the objectinertia matrix: the new inertia matrix or tensor (9 values), expressed relative to the center of mass. The matrix should be relative to the orientational frame of transformation (see further below). centerOfMass: the new position of the center of mass, relative to the specified transformation (see next item).transformation: the transformation matrix (12 values) relative to which we specify the data. Can be NULL, in which case the data is relative to the absolute reference frame. See here to see how matrix transformations are specified in V-REP.shapeHandle: handle of the shape objectmass: the new mass of the objectinertia matrix: the new inertia matrix or tensor (9 values), expressed relative to the center of mass. The matrix should be relative to the orientational frame of transformation (see further below). centerOfMass: the new position of the center of mass, relative to the specified transformation (see next item).transformation: the transformation matrix (12 values) relative to which we specify the data. Can be NULL, in which case the data is relative to the absolute reference frame. See here to see how matrix transformations are specified in V-REP.shapeHandle: handle of the shape objectmass: the new mass of the objectinertia matrix: the new inertia matrix or tensor (9 values), expressed relative to the center of mass. The matrix should be relative to the orientational frame of transformation (see further below). centerOfMass: the new position of the center of mass, relative to the specified transformation (see next item).transformation: the transformation matrix (12 values) relative to which we specify the data. Can be NULL, in which case the data is relative to the absolute reference frame. See here to see how matrix transformations are specified in V-REP.shapeHandle: handle of the shape objectmass: the new mass of the objectinertia matrix: the new inertia matrix or tensor (9 values), expressed relative to the center of mass. The matrix should be relative to the orientational frame of transformation (see further below). centerOfMass: the new position of the center of mass, relative to the specified transformation (see next item).transformation: the transformation matrix (12 values) relative to which we specify the data. Can be NULL, in which case the data is relative to the absolute reference frame. See here to see how matrix transformations are specified in V-REP. -1 in case of an error"
    }, 
    "sim.navigation_objectrotate": {
        "body": "sim.navigation_objectrotate", 
        "scope": "source.lua", 
        "prefix": "sim.navigation_objectrotate", 
        "description": "Constants"
    }, 
    "sim.imgcomb_vertical": {
        "body": "sim.imgcomb_vertical", 
        "scope": "source.lua", 
        "prefix": "sim.imgcomb_vertical", 
        "description": "Constants"
    }, 
    "sim.rmlRemove": {
        "body": "sim.rmlRemove(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "sim.rmlRemove", 
        "description": "number result = sim.rmlRemove(number handle)"
    }, 
    "sim.intparam_prox_sensor_select_down": {
        "body": "sim.intparam_prox_sensor_select_down", 
        "scope": "source.lua", 
        "prefix": "sim.intparam_prox_sensor_select_down", 
        "description": "Constants"
    }, 
    "simx.getPingTime": {
        "body": "simx.getPingTime()", 
        "scope": "source.lua", 
        "prefix": "simx.getPingTime", 
        "description": "number returnCode,number pingTime= simx.getPingTime()Retrieves the time needed for a command to be sent to the server, executed, and sent back. That time depends on various factors like the client settings, the network load, whether a simulation is running, whether the simulation is real-time, the simulation time step, etc. The function is blocking. This is a remote API helper function. clientID: the client ID. refer to simx.start. returnCode: a remote API function return codepingTime: the ping time in milliseconds"
    }, 
    "sim.jointintparam_velocity_lock": {
        "body": "sim.jointintparam_velocity_lock", 
        "scope": "source.lua", 
        "prefix": "sim.jointintparam_velocity_lock", 
        "description": "Constants"
    }, 
    "function": {
        "body": "function ${1:function_name}( ${2:...} )\n\t${0:-- body}\nend", 
        "scope": "source.lua", 
        "prefix": "function", 
        "description": "function"
    }, 
    "sim.checkVisionSensor": {
        "body": "sim.checkVisionSensor(${0:sensorHandle},${1:entityHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.checkVisionSensor", 
        "description": "number result,table auxiliaryValuesPacket1,table auxiliaryValuesPacket2,etc. = sim.checkVisionSensor(number sensorHandle,number entityHandle)Checks whether the vision sensor detects the indicated entity. Detection is silent (no visual feedback) compared to sim.handleVisionSensor. Also, the renderable flag of the entity is overridden if the entity is an object. See also sim.readVisionSensor and sim.checkVisionSensorEx. sensorHandle: handle of the vision sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsauxValues: auxiliary values returned from the applied filters (refer to the filter's documentation for details). By default V-REP returns one packet of 15 auxiliary values:the minimum of intensity, red, green, blue, depth value, the maximum of intensity, red, green, blue, depth value, and the average of intensity, red, green, blue, depth value. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with simReleaseBuffer(*auxValues).auxValuesCount: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with simReleaseBuffer(*auxValuesCount).Usage example:float* auxValues=NULL;int* auxValuesCount=NULL;float averageColor[3]={0.0f,0.0f,0.0f};if (simCheckVisionSensor(sensorHandle,entityHandle,&auxValues,&auxValuesCount)>=0){    if ((auxValuesCount[0]>0)||(auxValuesCount[1]>=15))    {        averageColor[0]=auxValues[11];        averageColor[1]=auxValues[12];        averageColor[2]=auxValues[13];    }    simReleaseBuffer((char*)auxValues);    simReleaseBuffer((char*)auxValuesCount);}sensorHandle: handle of the vision sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsauxValues: auxiliary values returned from the applied filters (refer to the filter's documentation for details). By default V-REP returns one packet of 15 auxiliary values:the minimum of intensity, red, green, blue, depth value, the maximum of intensity, red, green, blue, depth value, and the average of intensity, red, green, blue, depth value. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with simReleaseBuffer(*auxValues).auxValuesCount: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with simReleaseBuffer(*auxValuesCount).Usage example:float* auxValues=NULL;int* auxValuesCount=NULL;float averageColor[3]={0.0f,0.0f,0.0f};if (simCheckVisionSensor(sensorHandle,entityHandle,&auxValues,&auxValuesCount)>=0){    if ((auxValuesCount[0]>0)||(auxValuesCount[1]>=15))    {        averageColor[0]=auxValues[11];        averageColor[1]=auxValues[12];        averageColor[2]=auxValues[13];    }    simReleaseBuffer((char*)auxValues);    simReleaseBuffer((char*)auxValuesCount);}sensorHandle: handle of the vision sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsauxValues: auxiliary values returned from the applied filters (refer to the filter's documentation for details). By default V-REP returns one packet of 15 auxiliary values:the minimum of intensity, red, green, blue, depth value, the maximum of intensity, red, green, blue, depth value, and the average of intensity, red, green, blue, depth value. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with simReleaseBuffer(*auxValues).auxValuesCount: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with simReleaseBuffer(*auxValuesCount).Usage example:float* auxValues=NULL;int* auxValuesCount=NULL;float averageColor[3]={0.0f,0.0f,0.0f};if (simCheckVisionSensor(sensorHandle,entityHandle,&auxValues,&auxValuesCount)>=0){    if ((auxValuesCount[0]>0)||(auxValuesCount[1]>=15))    {        averageColor[0]=auxValues[11];        averageColor[1]=auxValues[12];        averageColor[2]=auxValues[13];    }    simReleaseBuffer((char*)auxValues);    simReleaseBuffer((char*)auxValuesCount);}sensorHandle: handle of the vision sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsauxValues: auxiliary values returned from the applied filters (refer to the filter's documentation for details). By default V-REP returns one packet of 15 auxiliary values:the minimum of intensity, red, green, blue, depth value, the maximum of intensity, red, green, blue, depth value, and the average of intensity, red, green, blue, depth value. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with simReleaseBuffer(*auxValues).auxValuesCount: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with simReleaseBuffer(*auxValuesCount).Usage example:float* auxValues=NULL;int* auxValuesCount=NULL;float averageColor[3]={0.0f,0.0f,0.0f};if (simCheckVisionSensor(sensorHandle,entityHandle,&auxValues,&auxValuesCount)>=0){    if ((auxValuesCount[0]>0)||(auxValuesCount[1]>=15))    {        averageColor[0]=auxValues[11];        averageColor[1]=auxValues[12];        averageColor[2]=auxValues[13];    }    simReleaseBuffer((char*)auxValues);    simReleaseBuffer((char*)auxValuesCount);}sensorHandle: handle of the vision sensor objectentityHandle: handle of entity to detect (object or collection), or sim_handle_all to detect all detectable objectsauxValues: auxiliary values returned from the applied filters (refer to the filter's documentation for details). By default V-REP returns one packet of 15 auxiliary values:the minimum of intensity, red, green, blue, depth value, the maximum of intensity, red, green, blue, depth value, and the average of intensity, red, green, blue, depth value. If additional filter components return values, then they will be appended as packets to the first packet. AuxValues can be NULL. The user is in charge of releasing the auxValues buffer with simReleaseBuffer(*auxValues).auxValuesCount: contains information about the number of auxiliary value packets and packet sizes returned in auxValues. The first value is the number of packets, the second is the size of packet1, the third is the size of packet2, etc. Can be NULL if auxValues is also NULL. The user is in charge of releasing the auxValuesCount buffer with simReleaseBuffer(*auxValuesCount).Usage example:float* auxValues=NULL;int* auxValuesCount=NULL;float averageColor[3]={0.0f,0.0f,0.0f};if (simCheckVisionSensor(sensorHandle,entityHandle,&auxValues,&auxValuesCount)>=0){    if ((auxValuesCount[0]>0)||(auxValuesCount[1]>=15))    {        averageColor[0]=auxValues[11];        averageColor[1]=auxValues[12];        averageColor[2]=auxValues[13];    }    simReleaseBuffer((char*)auxValues);    simReleaseBuffer((char*)auxValuesCount);} -1 if operation was not successful, otherwise 0 (no detection) or 1 (detection)"
    }, 
    "sim.stringparam_app_arg2": {
        "body": "sim.stringparam_app_arg2", 
        "scope": "source.lua", 
        "prefix": "sim.stringparam_app_arg2", 
        "description": "Constants"
    }, 
    "sim.setExplicitHandling": {
        "body": "sim.setExplicitHandling(${0:generalObjectHandle},${1:explicitHandlingFlags})", 
        "scope": "source.lua", 
        "prefix": "sim.setExplicitHandling", 
        "description": "number result = sim.setExplicitHandling(number generalObjectHandle,number explicitHandlingFlags)Sets the explicit handling flags for a general object. See also sim.getExplicitHandling. generalObjectHandle: handle of a general object (can be a scene object, a collision object, a distance object, etc.)explicitFlags: the explicit handling flags. For now only bit 0 is usedgeneralObjectHandle: handle of a general object (can be a scene object, a collision object, a distance object, etc.)explicitFlags: the explicit handling flags. For now only bit 0 is usedgeneralObjectHandle: handle of a general object (can be a scene object, a collision object, a distance object, etc.)explicitFlags: the explicit handling flags. For now only bit 0 is used -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.stringparam_app_arg4": {
        "body": "sim.stringparam_app_arg4", 
        "scope": "source.lua", 
        "prefix": "sim.stringparam_app_arg4", 
        "description": "Constants"
    }, 
    "sim.pure_primitive_cylinder": {
        "body": "sim.pure_primitive_cylinder", 
        "scope": "source.lua", 
        "prefix": "sim.pure_primitive_cylinder", 
        "description": "Constants"
    }, 
    "sim.stringparam_app_arg6": {
        "body": "sim.stringparam_app_arg6", 
        "scope": "source.lua", 
        "prefix": "sim.stringparam_app_arg6", 
        "description": "Constants"
    }, 
    "sim.stringparam_app_arg7": {
        "body": "sim.stringparam_app_arg7", 
        "scope": "source.lua", 
        "prefix": "sim.stringparam_app_arg7", 
        "description": "Constants"
    }, 
    "sim.ode_body_friction": {
        "body": "sim.ode_body_friction", 
        "scope": "source.lua", 
        "prefix": "sim.ode_body_friction", 
        "description": "Constants"
    }, 
    "sim.stringparam_app_arg9": {
        "body": "sim.stringparam_app_arg9", 
        "scope": "source.lua", 
        "prefix": "sim.stringparam_app_arg9", 
        "description": "Constants"
    }, 
    "sim.particle_invisible": {
        "body": "sim.particle_invisible", 
        "scope": "source.lua", 
        "prefix": "sim.particle_invisible", 
        "description": "Constants"
    }, 
    "sim.dummy_linktype_gcs_loop_closure": {
        "body": "sim.dummy_linktype_gcs_loop_closure", 
        "scope": "source.lua", 
        "prefix": "sim.dummy_linktype_gcs_loop_closure", 
        "description": "Constants"
    }, 
    "sim.resumeThreads": {
        "body": "sim.resumeThreads(${0:location})", 
        "scope": "source.lua", 
        "prefix": "sim.resumeThreads", 
        "description": "number count = sim.resumeThreads(number location)In conjunction with sim.setThreadResumeLocation, sim.resumeThreads allows specifying when and in which order threads are resumed. By default, V-REP doesn't use regular threads, but something similar to hybrid threads (which behave like coroutines, but can also behave like regular threads). This allows much more flexibility and execution control of the threads. Once a thread switched to another thread, it will resume execution at the beginning of next simulation pass by default. In order to also have full synchronization control between threads, you can assign a resume location and order to each thread. When sim.resumeThreads(x) is called, all threads that were assigned a resume location of x will be resumed. See also sim.setThreadResumeLocation, sim.setThreadSwitchTiming, sim.switchThread and sim.setThreadIsFree. This function can only be called in the main script. - -"
    }, 
    "simB0.destroyServiceServer": {
        "body": "simB0.destroyServiceServer(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "simB0.destroyServiceServer", 
        "description": "simB0.destroyServiceServer(string handle)"
    }, 
    "sim.setObjectMatrix": {
        "body": "sim.setObjectMatrix(${0:objectHandle},${1:relativeToObjectHandle},${2:matrix})", 
        "scope": "source.lua", 
        "prefix": "sim.setObjectMatrix", 
        "description": "number result = sim.setObjectMatrix(number objectHandle,number relativeToObjectHandle,table_12 matrix)Sets the transformation matrix of an object. Dynamically simulated objects will implicitely be reset before the command is applied (i.e. similar to calling  sim.resetDynamicObject just before). See also sim.getObjectMatrix, sim.setObjectPosition, sim.setObjectOrientation and the other matrix/transformation functions. objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the matrix is specified. Specify -1 to set the absolute transformation matrix, sim_handle_parent to set the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame the transformation matrix is specified.matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11])objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the matrix is specified. Specify -1 to set the absolute transformation matrix, sim_handle_parent to set the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame the transformation matrix is specified.matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11])objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the matrix is specified. Specify -1 to set the absolute transformation matrix, sim_handle_parent to set the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame the transformation matrix is specified.matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11])objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the matrix is specified. Specify -1 to set the absolute transformation matrix, sim_handle_parent to set the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame the transformation matrix is specified.matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11])objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the matrix is specified. Specify -1 to set the absolute transformation matrix, sim_handle_parent to set the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame the transformation matrix is specified.matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11])objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the matrix is specified. Specify -1 to set the absolute transformation matrix, sim_handle_parent to set the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame the transformation matrix is specified.matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11])objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame the matrix is specified. Specify -1 to set the absolute transformation matrix, sim_handle_parent to set the transformation matrix relative to the object's parent, or an object handle relative to whose reference frame the transformation matrix is specified.matrix: pointer to 12 simFloat values (the last row of the 4x4 matrix (0,0,0,1) is not needed)The x-axis of the orientation component is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component is (matrix[2],matrix[6],matrix[10])The translation component is (matrix[3],matrix[7],matrix[11]) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "simRRS1.SET_JOINT_SPEEDS": {
        "body": "simRRS1.SET_JOINT_SPEEDS(${0:rcsHandle},${1:allJointFlags},${2:jointFlags})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_JOINT_SPEEDS", 
        "description": "int status= simRRS1.SET_JOINT_SPEEDS(bitstring2 rcsHandle,int allJointFlags,bitstring jointFlags)"
    }, 
    "sim.objfloatparam_abs_y_velocity": {
        "body": "sim.objfloatparam_abs_y_velocity", 
        "scope": "source.lua", 
        "prefix": "sim.objfloatparam_abs_y_velocity", 
        "description": "Constants"
    }, 
    "simUI.getTitle": {
        "body": "simUI.getTitle(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "simUI.getTitle", 
        "description": "string title = simUI.getTitle(number handle)"
    }, 
    "simUI.setPlotXRange": {
        "body": "simUI.setPlotXRange(${0:handle},${1:id},${2:xmin},${3:xmax})", 
        "scope": "source.lua", 
        "prefix": "simUI.setPlotXRange", 
        "description": "simUI.setPlotXRange(number handle,number id,number xmin,number xmax)"
    }, 
    "debug.getuservalue": {
        "body": "debug.getuservalue(${0:...})", 
        "scope": "source.lua", 
        "prefix": "debug.getuservalue", 
        "description": "5.2,5.3\n\ndebug.getuservalue (u)"
    }, 
    "sim.msgbox_return_ok": {
        "body": "sim.msgbox_return_ok", 
        "scope": "source.lua", 
        "prefix": "sim.msgbox_return_ok", 
        "description": "Constants"
    }, 
    "sim.visionintparam_windowed_pos_y": {
        "body": "sim.visionintparam_windowed_pos_y", 
        "scope": "source.lua", 
        "prefix": "sim.visionintparam_windowed_pos_y", 
        "description": "Constants"
    }, 
    "simx.opmode_remove": {
        "body": "simx.opmode_remove", 
        "scope": "source.lua", 
        "prefix": "simx.opmode_remove", 
        "description": "Constants"
    }, 
    "sim.message_object_selection_changed": {
        "body": "sim.message_object_selection_changed", 
        "scope": "source.lua", 
        "prefix": "sim.message_object_selection_changed", 
        "description": "Constants"
    }, 
    "sim.buildMatrixQ": {
        "body": "sim.buildMatrixQ(${0:position},${1:quaternion})", 
        "scope": "source.lua", 
        "prefix": "sim.buildMatrixQ", 
        "description": "table_12 matrix = sim.buildMatrixQ(table_3 position,table_4 quaternion)Builds a transformation matrix based on a position vector and a quaternion. See also the other matrix/transformation functions. position: pointer to 3 simFloat values representing the position componentquaternion: pointer to 4 simFloat values representing the orientation quaternion (x,y,z,w)matrix: pointer to 12 simFloat values representing the transformation matrixThe x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])The position component of the matrix is (matrix[3],matrix[7],matrix[11])position: pointer to 3 simFloat values representing the position componentquaternion: pointer to 4 simFloat values representing the orientation quaternion (x,y,z,w)matrix: pointer to 12 simFloat values representing the transformation matrixThe x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])The position component of the matrix is (matrix[3],matrix[7],matrix[11])position: pointer to 3 simFloat values representing the position componentquaternion: pointer to 4 simFloat values representing the orientation quaternion (x,y,z,w)matrix: pointer to 12 simFloat values representing the transformation matrixThe x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])The position component of the matrix is (matrix[3],matrix[7],matrix[11])position: pointer to 3 simFloat values representing the position componentquaternion: pointer to 4 simFloat values representing the orientation quaternion (x,y,z,w)matrix: pointer to 12 simFloat values representing the transformation matrixThe x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])The position component of the matrix is (matrix[3],matrix[7],matrix[11])position: pointer to 3 simFloat values representing the position componentquaternion: pointer to 4 simFloat values representing the orientation quaternion (x,y,z,w)matrix: pointer to 12 simFloat values representing the transformation matrixThe x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])The position component of the matrix is (matrix[3],matrix[7],matrix[11])position: pointer to 3 simFloat values representing the position componentquaternion: pointer to 4 simFloat values representing the orientation quaternion (x,y,z,w)matrix: pointer to 12 simFloat values representing the transformation matrixThe x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])The position component of the matrix is (matrix[3],matrix[7],matrix[11])position: pointer to 3 simFloat values representing the position componentquaternion: pointer to 4 simFloat values representing the orientation quaternion (x,y,z,w)matrix: pointer to 12 simFloat values representing the transformation matrixThe x-axis of the orientation component of the matrix is (matrix[0],matrix[4],matrix[8])The y-axis of the orientation component of the matrix is (matrix[1],matrix[5],matrix[9])The z-axis of the orientation component of the matrix is (matrix[2],matrix[6],matrix[10])The position component of the matrix is (matrix[3],matrix[7],matrix[11]) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.resetProximitySensor": {
        "body": "sim.resetProximitySensor(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.resetProximitySensor", 
        "description": "number result = sim.resetProximitySensor(number objectHandle)Clears the detection state, detection color, detection segments, etc. of a proximity sensor object. See also sim.handleProximitySensor. sensorHandle: handle of the proximity sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all proximity sensor objects, while sim_handle_all_except_explicit will only reset those that are not marked as explicit handling)sensorHandle: handle of the proximity sensor object or sim_handle_all or sim_handle_all_except_explicit. (sim_handle_all will reset all proximity sensor objects, while sim_handle_all_except_explicit will only reset those that are not marked as explicit handling) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.bullet_constraintsolvertype_nncg": {
        "body": "sim.bullet_constraintsolvertype_nncg", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_constraintsolvertype_nncg", 
        "description": "Constants"
    }, 
    "simRRS1.SET_CARTESIAN_POSITION_SPEED": {
        "body": "simRRS1.SET_CARTESIAN_POSITION_SPEED(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SET_CARTESIAN_POSITION_SPEED", 
        "description": "int status= simRRS1.SET_CARTESIAN_POSITION_SPEED(bitstring2 rcsHandle)"
    }, 
    "simUI.setItem": {
        "body": "simUI.setItem(${0:handle},${1:id},${2:row},${3:column},${4:text},${5:suppressEvents=true})", 
        "scope": "source.lua", 
        "prefix": "simUI.setItem", 
        "description": "simUI.setItem(number handle,number id,number row,number column,string text,bool suppressEvents=true)"
    }, 
    "simx.getJointForce": {
        "body": "simx.getJointForce(${0:clientId},${1:jointHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.getJointForce", 
        "description": "number returnCode,number force= simx.getJointForce(number clientId,number jointHandle)Retrieves the force or torque applied to a joint  along/about its active axis. This function retrieves meaningful information only if the joint is prismatic or revolute, and is dynamically enabled. With the Bullet engine, this function returns the force or torque applied to the joint motor  (torques from joint limits are not taken into account). With the ODE or Vortex engine, this function returns the total force or torque applied to a joint  along/about its z-axis. See also simx.setJointForce, simx.readForceSensor and simx.getObjectGroupData. clientID: the client ID. refer to simx.start.jointHandle: handle of the jointoperationMode: a remote API function operation mode. Recommended operation modes for this function are simx.opmode_streaming (the first call) and simx.opmode_buffer (the following calls) returnCode: a remote API function return codeforce: the force or the torque applied to the joint along/about its z-axis"
    }, 
    "rawlen": {
        "body": "rawlen(${0:...})", 
        "scope": "source.lua", 
        "prefix": "rawlen", 
        "description": "5.2,5.3\n\nrawlen (v)"
    }, 
    "simROS.serviceClientTreatUInt8ArrayAsString": {
        "body": "simROS.serviceClientTreatUInt8ArrayAsString(${0:serviceClientHandle})", 
        "scope": "source.lua", 
        "prefix": "simROS.serviceClientTreatUInt8ArrayAsString", 
        "description": "simROS.serviceClientTreatUInt8ArrayAsString(number serviceClientHandle)"
    }, 
    "simUI.setNodeValid": {
        "body": "simUI.setNodeValid(${0:handle},${1:id},${2:nodeId},${3:valid})", 
        "scope": "source.lua", 
        "prefix": "simUI.setNodeValid", 
        "description": "simUI.setNodeValid(number handle,number id,number nodeId,bool valid)"
    }, 
    "sim.wait": {
        "body": "sim.wait(${0:deltaTime},${1:simulationTime=true})", 
        "scope": "source.lua", 
        "prefix": "sim.wait", 
        "description": "number deltaTimeLeft = sim.wait(number deltaTime,boolean simulationTime=true)Waits for a certain amount of time. This function can only be called from child scripts running in a thread (since this is a blocking operation) and is not available from the C-API. See also sim.waitForSignal. - -"
    }, 
    "sim.moveToJointPositions": {
        "body": "sim.moveToJointPositions(${0:jointHandles},${1:jointPositions},${2:velocity},${3:accel},${4:angleToLinearCoeff})", 
        "scope": "source.lua", 
        "prefix": "sim.moveToJointPositions", 
        "description": "number deltaTimeLeft = sim.moveToJointPositions(table jointHandles,table jointPositions,number/table velocity,number/table accel,number angleToLinearCoeff)"
    }, 
    "sim.message_ui_button_state_change": {
        "body": "sim.message_ui_button_state_change", 
        "scope": "source.lua", 
        "prefix": "sim.message_ui_button_state_change", 
        "description": "Constants"
    }, 
    "sim.unpackTable": {
        "body": "sim.unpackTable(${0:buffer})", 
        "scope": "source.lua", 
        "prefix": "sim.unpackTable", 
        "description": "table aTable = sim.unpackTable(string buffer)Unpacks a buffer into a table. See also sim.packTable, the other stack functions and the other packing/unpacking functions. stackHandle: a stack handle obtained with simCreateStack. The unpacked table will be pushed onto the stack.buffer: the packed table (buffer).bufferSize: the size of the buffer.stackHandle: a stack handle obtained with simCreateStack. The unpacked table will be pushed onto the stack.buffer: the packed table (buffer).bufferSize: the size of the buffer.stackHandle: a stack handle obtained with simCreateStack. The unpacked table will be pushed onto the stack.buffer: the packed table (buffer).bufferSize: the size of the buffer. -1 in case of an error."
    }, 
    "sim.scaleObjects": {
        "body": "sim.scaleObjects(${0:objectHandles},${1:scalingFactor},${2:scalePositionsToo})", 
        "scope": "source.lua", 
        "prefix": "sim.scaleObjects", 
        "description": "number result = sim.scaleObjects(table objectHandles,number scalingFactor,boolean scalePositionsToo)Scales (in dimensions) specified objects. All related values are automatically scaled appropriately (e.g. masses, forces, etc.). See also sim.scaleObject for non-isometric scaling. objectHandles: an array containing the handles of the objects to scale. If an object is a model base, all its child objects will also be scaled.objectCount: the number of handles in the objectHandles array.scalingFactor: the scaling factorscalePositionsToo: if true, selected object's positions will also be scaledobjectHandles: an array containing the handles of the objects to scale. If an object is a model base, all its child objects will also be scaled.objectCount: the number of handles in the objectHandles array.scalingFactor: the scaling factorscalePositionsToo: if true, selected object's positions will also be scaledobjectHandles: an array containing the handles of the objects to scale. If an object is a model base, all its child objects will also be scaled.objectCount: the number of handles in the objectHandles array.scalingFactor: the scaling factorscalePositionsToo: if true, selected object's positions will also be scaledobjectHandles: an array containing the handles of the objects to scale. If an object is a model base, all its child objects will also be scaled.objectCount: the number of handles in the objectHandles array.scalingFactor: the scaling factorscalePositionsToo: if true, selected object's positions will also be scaled -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.newton_body_restitution": {
        "body": "sim.newton_body_restitution", 
        "scope": "source.lua", 
        "prefix": "sim.newton_body_restitution", 
        "description": "Constants"
    }, 
    "sim.dlgret_still_open": {
        "body": "sim.dlgret_still_open", 
        "scope": "source.lua", 
        "prefix": "sim.dlgret_still_open", 
        "description": "Constants"
    }, 
    "simCHAI3D.addConstraintPoint": {
        "body": "simCHAI3D.addConstraintPoint(${0:deviceIndex},${1:position},${2:Kp},${3:Kv},${4:Fmax})", 
        "scope": "source.lua", 
        "prefix": "simCHAI3D.addConstraintPoint", 
        "description": "number objectID = simCHAI3D.addConstraintPoint(number deviceIndex,table_3 position,number Kp,number Kv,number Fmax)"
    }, 
    "sim.displayattribute_groupselection": {
        "body": "sim.displayattribute_groupselection", 
        "scope": "source.lua", 
        "prefix": "sim.displayattribute_groupselection", 
        "description": "Constants"
    }, 
    "sim.filtercomponent_subtractbuffer1": {
        "body": "sim.filtercomponent_subtractbuffer1", 
        "scope": "source.lua", 
        "prefix": "sim.filtercomponent_subtractbuffer1", 
        "description": "Constants"
    }, 
    "simOMPL.Algorithm.LBKPIECE1": {
        "body": "simOMPL.Algorithm.LBKPIECE1", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.LBKPIECE1", 
        "description": "Constants"
    }, 
    "sim.getSimulatorMessage": {
        "body": "sim.getSimulatorMessage()", 
        "scope": "source.lua", 
        "prefix": "sim.getSimulatorMessage", 
        "description": "number messageID,table_4 auxiliaryData,table auxiliaryData2 = sim.getSimulatorMessage()Retrieves and removes the next message in the C/C++ or Lua message queues. Use this in a while-loop until all messages have been extracted. While the C/C++ interface has one single message queue, each Lua script has its own message queue. The C/C++ version of this function should only be called from the V-REP client application. A given message queue cannot hold more than 64 messages, unread messages will be discarded. messageID: a simulator message (see the simulator messages) or -1 if no message is available or in case of an errorauxiliaryData: table of 4 integers that can describe the returned message in more detailsreturnedDataSize: size of the returned buffermessageID: a simulator message (see the simulator messages) or -1 if no message is available or in case of an errorauxiliaryData: table of 4 integers that can describe the returned message in more detailsreturnedDataSize: size of the returned buffermessageID: a simulator message (see the simulator messages) or -1 if no message is available or in case of an errorauxiliaryData: table of 4 integers that can describe the returned message in more detailsreturnedDataSize: size of the returned buffer NULL if no buffer was returned, otherwise a buffer that should be released with simReleaseBuffer"
    }, 
    "sim.vortex_joint_p2damping": {
        "body": "sim.vortex_joint_p2damping", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_p2damping", 
        "description": "Constants"
    }, 
    "sim.bullet_body_oldfriction": {
        "body": "sim.bullet_body_oldfriction", 
        "scope": "source.lua", 
        "prefix": "sim.bullet_body_oldfriction", 
        "description": "Constants"
    }, 
    "package.loaded": {
        "body": "package.loaded(${0:...})", 
        "scope": "source.lua", 
        "prefix": "package.loaded", 
        "description": "5.1,5.2,5.3\n\npackage.loaded"
    }, 
    "sim.subtractObjectFromPointCloud": {
        "body": "sim.subtractObjectFromPointCloud(${0:pointCloudHandle},${1:objectHandle},${2:options},${3:tolerance})", 
        "scope": "source.lua", 
        "prefix": "sim.subtractObjectFromPointCloud", 
        "description": "number totalPointCnt = sim.subtractObjectFromPointCloud(number pointCloudHandle,number objectHandle,number options,number tolerance)Removes an object from a point cloud, as a subtraction. See also sim.insertPointsIntoPointCloud, sim.insertObjectIntoPointCloud, sim.removePointsFromPointCloud and the other point cloud related functions. pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleobjectHandle:  the handle of the object to subtract. Only potentially measurable objects are supported.options: reserved. Set to 0tolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleobjectHandle:  the handle of the object to subtract. Only potentially measurable objects are supported.options: reserved. Set to 0tolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleobjectHandle:  the handle of the object to subtract. Only potentially measurable objects are supported.options: reserved. Set to 0tolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleobjectHandle:  the handle of the object to subtract. Only potentially measurable objects are supported.options: reserved. Set to 0tolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULLpointCloudHandle: the handle of the point cloud. See also simGetObjectHandleobjectHandle:  the handle of the object to subtract. Only potentially measurable objects are supported.options: reserved. Set to 0tolerance: a distance used as a tolerance valuereserved: reserved for future extensions. Set to NULL -1 if operation was not successful, otherwise the total number of points in the point cloud"
    }, 
    "sim.vortex_body_randomshapesasterrain": {
        "body": "sim.vortex_body_randomshapesasterrain", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_body_randomshapesasterrain", 
        "description": "Constants"
    }, 
    "simROS.getParamDouble": {
        "body": "simROS.getParamDouble(${0:name},${1:defaultValue=0.0})", 
        "scope": "source.lua", 
        "prefix": "simROS.getParamDouble", 
        "description": "bool exists,number value = simROS.getParamDouble(string name,number defaultValue=0.0)"
    }, 
    "simRRS1.SELECT_FLYBY_CRITERIA": {
        "body": "simRRS1.SELECT_FLYBY_CRITERIA(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SELECT_FLYBY_CRITERIA", 
        "description": "int status= simRRS1.SELECT_FLYBY_CRITERIA(bitstring2 rcsHandle)"
    }, 
    "simUI.addCurveTimePoints": {
        "body": "simUI.addCurveTimePoints(${0:handle},${1:id},${2:name},${3:x},${4:y})", 
        "scope": "source.lua", 
        "prefix": "simUI.addCurveTimePoints", 
        "description": "simUI.addCurveTimePoints(number handle,number id,string name,table x,table y)"
    }, 
    "math.min": {
        "body": "math.min( ${1:x},${2:...} )", 
        "scope": "source.lua", 
        "prefix": "math.min", 
        "description": "5.1,5.2,5.3\n\nmath.min"
    }, 
    "sim.particle_emissioncolor": {
        "body": "sim.particle_emissioncolor", 
        "scope": "source.lua", 
        "prefix": "sim.particle_emissioncolor", 
        "description": "Constants"
    }, 
    "simOMPL.Algorithm.SPARS": {
        "body": "simOMPL.Algorithm.SPARS", 
        "scope": "source.lua", 
        "prefix": "simOMPL.Algorithm.SPARS", 
        "description": "Constants"
    }, 
    "sim.floatparam_rand": {
        "body": "sim.floatparam_rand", 
        "scope": "source.lua", 
        "prefix": "sim.floatparam_rand", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_upperlimitrestitution": {
        "body": "sim.vortex_joint_upperlimitrestitution", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_upperlimitrestitution", 
        "description": "Constants"
    }, 
    "sim.dynmat_nofriction": {
        "body": "sim.dynmat_nofriction", 
        "scope": "source.lua", 
        "prefix": "sim.dynmat_nofriction", 
        "description": "Constants"
    }, 
    "sim.boolparam_vision_sensor_handling_enabled": {
        "body": "sim.boolparam_vision_sensor_handling_enabled", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_vision_sensor_handling_enabled", 
        "description": "Constants"
    }, 
    "simx.getObjectGroupData": {
        "body": "simx.getObjectGroupData(${0:clientId},${1:objectType},${2:dataType})", 
        "scope": "source.lua", 
        "prefix": "simx.getObjectGroupData", 
        "description": "number returnCode,table handles,table intData,table floatData,table stringData= simx.getObjectGroupData(number clientId,number objectType,number dataType)Simultaneously retrieves data of various objects in a V-REP scene. clientID: the client ID. refer to simx.start.objectType: a scene object type, sim.appobj_object_type for all scene objects, or a collection handle.dataType: the type of data that is desired: operationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_blocking or simx.opmode_streaming. returnCode: a remote API function return codehandles the object handles.intData the integer values.floatData the float values.stringData the string values."
    }, 
    "sim.visionfloatparam_pov_blur_distance": {
        "body": "sim.visionfloatparam_pov_blur_distance", 
        "scope": "source.lua", 
        "prefix": "sim.visionfloatparam_pov_blur_distance", 
        "description": "Constants"
    }, 
    "sim.setJointTargetPosition": {
        "body": "sim.setJointTargetPosition(${0:objectHandle},${1:targetPosition})", 
        "scope": "source.lua", 
        "prefix": "sim.setJointTargetPosition", 
        "description": "number result = sim.setJointTargetPosition(number objectHandle,number targetPosition)Sets the target position of a joint if the joint is in torque/force mode (also make sure that the joint's motor and position control are enabled). See also sim.getJointTargetPosition and sim.setJointPosition. objectHandle: handle of the joint objecttargetPosition: target position of the joint (angular or linear value depending on the joint type)objectHandle: handle of the joint objecttargetPosition: target position of the joint (angular or linear value depending on the joint type)objectHandle: handle of the joint objecttargetPosition: target position of the joint (angular or linear value depending on the joint type) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.boolparam_shape_textures_are_visible": {
        "body": "sim.boolparam_shape_textures_are_visible", 
        "scope": "source.lua", 
        "prefix": "sim.boolparam_shape_textures_are_visible", 
        "description": "Constants"
    }, 
    "simx.auxiliaryConsoleClose": {
        "body": "simx.auxiliaryConsoleClose(${0:clientId},${1:consoleHandle})", 
        "scope": "source.lua", 
        "prefix": "simx.auxiliaryConsoleClose", 
        "description": "number returnCode= simx.auxiliaryConsoleClose(number clientId,number consoleHandle)Closes an auxiliary console window. See also simx.auxiliaryConsoleOpen. clientID: the client ID. refer to simx.start.consoleHandle: the handle of the console window, previously returned by the simx.auxiliaryConsoleOpen commandoperationMode: a remote API function operation mode. Recommended operation mode for this function is simx.opmode_oneshot returnCode: a remote API function return code"
    }, 
    "sim.api_error_output": {
        "body": "sim.api_error_output", 
        "scope": "source.lua", 
        "prefix": "sim.api_error_output", 
        "description": "Constants"
    }, 
    "sim.getLastError": {
        "body": "sim.getLastError()", 
        "scope": "source.lua", 
        "prefix": "sim.getLastError", 
        "description": "string lastError = sim.getLastError()Retrieves the last generated error message for the calling thread and/or script. By calling this function, the last error message is reset and a subsequent call to this function returns NULL. Errors are memorized on a thread- and/or script basis (e.g. each script have each an individual error handler, so does the C API functions (when the simulation thread and the GUI thread are differentiated)). See also simSetLastError, the sim.intparam_error_report_mode and the error report modes. None Error message buffer or NULL if no error message is present. The user has to delete the returned buffer with a call to simReleaseBuffer"
    }, 
    "sim.dlgstyle_ok": {
        "body": "sim.dlgstyle_ok", 
        "scope": "source.lua", 
        "prefix": "sim.dlgstyle_ok", 
        "description": "Constants"
    }, 
    "simx.opmode_streaming_split": {
        "body": "simx.opmode_streaming_split", 
        "scope": "source.lua", 
        "prefix": "simx.opmode_streaming_split", 
        "description": "Constants"
    }, 
    "sim.insertPointsIntoPointCloud": {
        "body": "sim.insertPointsIntoPointCloud(${0:pointCloudHandle},${1:options},${2:points},${3:color=nil},${4:duplicateTolerance=nil})", 
        "scope": "source.lua", 
        "prefix": "sim.insertPointsIntoPointCloud", 
        "description": "number totalPointCnt = sim.insertPointsIntoPointCloud(number pointCloudHandle,number options,table points,table color=nil,number duplicateTolerance=nil)Inserts points into a point cloud. See also sim.removePointsFromPointCloud and the other point cloud related functions. pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point. Otherwise it contains a single RGB triplepts: a pointer to the point positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point. Otherwise it contains a single RGB triplepts: a pointer to the point positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point. Otherwise it contains a single RGB triplepts: a pointer to the point positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point. Otherwise it contains a single RGB triplepts: a pointer to the point positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point. Otherwise it contains a single RGB triplepts: a pointer to the point positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point. Otherwise it contains a single RGB triplepts: a pointer to the point positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point. Otherwise it contains a single RGB triplepts: a pointer to the point positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point. Otherwise it contains a single RGB triplepts: a pointer to the point positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point. Otherwise it contains a single RGB triplepts: a pointer to the point positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0pointCloudHandle: the handle of the point cloud. See also simGetObjectHandleoptions: bit-coded:bit0 set (1): specified points are relative to the point cloud reference frame, otherwise they are relative to the world reference framebit1 set (2): the color array contains one RGB triple per point. Otherwise it contains a single RGB triplepts: a pointer to the point positions specified as X/Y/Z coordinatesptCnt: the number of point coordinates contained in ptscolor: a pointer to one or several RGB triples, specifying the red, green and blue color components (0-255). Can be NULL.optionalValues: can be used to specify additional parameters, or set to NULL for default parameter values:((simInt*)optionalValues)[0]: an integer value that is bit coded. Each bit indicates which additional parameter will be taken into account:((simFloat*)optionalValues)[1]: duplicateTolerance: a minimum distance tolerance value that is used to avoid duplicate points. To have this parameter taken into account, set bit0 to 1 in ((simInt*)optionalValues)[0]. Point insertion is slower when the duplicate tolerance is > then 0.0 -1 if operation was not successful, otherwise the total number of points in the point cloud"
    }, 
    "sim.proxintparam_volume_type": {
        "body": "sim.proxintparam_volume_type", 
        "scope": "source.lua", 
        "prefix": "sim.proxintparam_volume_type", 
        "description": "Constants"
    }, 
    "sim.pathproperty_flat_path": {
        "body": "sim.pathproperty_flat_path", 
        "scope": "source.lua", 
        "prefix": "sim.pathproperty_flat_path", 
        "description": "Constants"
    }, 
    "sim.vortex_joint_a2loss": {
        "body": "sim.vortex_joint_a2loss", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_a2loss", 
        "description": "Constants"
    }, 
    "sim.getObjectOrientation": {
        "body": "sim.getObjectOrientation(${0:objectHandle},${1:relativeToObjectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getObjectOrientation", 
        "description": "table_3 eulerAngles = sim.getObjectOrientation(number objectHandle,number relativeToObjectHandle)Retrieves the orientation (Euler angles) of an object. See also sim.getObjectQuaternion, sim.setObjectOrientation, sim.getObjectPosition, sim.getObjectMatrix and the other matrix/transformation functions. objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the orientation. Specify -1 to retrieve the absolute orientation, sim_handle_parent to retrieve the orientation relative to the object's parent, or an object handle relative to whose reference frame you want the orientation.eulerAngles: Euler angles (alpha, beta and gamma)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the orientation. Specify -1 to retrieve the absolute orientation, sim_handle_parent to retrieve the orientation relative to the object's parent, or an object handle relative to whose reference frame you want the orientation.eulerAngles: Euler angles (alpha, beta and gamma)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the orientation. Specify -1 to retrieve the absolute orientation, sim_handle_parent to retrieve the orientation relative to the object's parent, or an object handle relative to whose reference frame you want the orientation.eulerAngles: Euler angles (alpha, beta and gamma)objectHandle: handle of the objectrelativeToObjectHandle: indicates relative to which reference frame we want the orientation. Specify -1 to retrieve the absolute orientation, sim_handle_parent to retrieve the orientation relative to the object's parent, or an object handle relative to whose reference frame you want the orientation.eulerAngles: Euler angles (alpha, beta and gamma) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.modelproperty_not_dynamic": {
        "body": "sim.modelproperty_not_dynamic", 
        "scope": "source.lua", 
        "prefix": "sim.modelproperty_not_dynamic", 
        "description": "Constants"
    }, 
    "sim.childscriptcall_actuation": {
        "body": "sim.childscriptcall_actuation", 
        "scope": "source.lua", 
        "prefix": "sim.childscriptcall_actuation", 
        "description": "Constants"
    }, 
    "simUI.getSize": {
        "body": "simUI.getSize(${0:handle})", 
        "scope": "source.lua", 
        "prefix": "simUI.getSize", 
        "description": "number w,number h = simUI.getSize(number handle)"
    }, 
    "sim.particle_cyclic": {
        "body": "sim.particle_cyclic", 
        "scope": "source.lua", 
        "prefix": "sim.particle_cyclic", 
        "description": "Constants"
    }, 
    "sim.jointfloatparam_error_angle": {
        "body": "sim.jointfloatparam_error_angle", 
        "scope": "source.lua", 
        "prefix": "sim.jointfloatparam_error_angle", 
        "description": "Constants"
    }, 
    "sim.handleModule": {
        "body": "sim.handleModule(${0:sim_handle_all})", 
        "scope": "source.lua", 
        "prefix": "sim.handleModule", 
        "description": "number result = sim.handleModule(sim_handle_all)Handles a plugin. This function is only available from the Lua API. Plugins, next to their registered custom Lua functions, might need to perform operations on a regular basis and not when called from a threaded script (e.g. for synchronization purposes). They can do it when sim.handleModule is called (sim.openModule should however have been called previously). Refer to the messages relayed to plugins for more details. sim.handleModule can only be called from the main script and is not available in the C-API. Look at the default main script to get an idea about how to use sim.openModule, sim.handleModule and sim.closeModule. - -"
    }, 
    "simRRS1.startRcsServer": {
        "body": "simRRS1.startRcsServer(${0:rcsLibraryFilename},${1:rcsLibraryFunctionName})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.startRcsServer", 
        "description": "number rcsServerHandle= simRRS1.startRcsServer(string rcsLibraryFilename,string rcsLibraryFunctionName)"
    }, 
    "sim.getDialogResult": {
        "body": "sim.getDialogResult(${0:genericDlgHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.getDialogResult", 
        "description": "number result = sim.getDialogResult(number genericDlgHandle)Queries the result of a dialog box. To be used after sim.displayDialog was called genericDialogHandle: handle of the generic dialoggenericDialogHandle: handle of the generic dialog result of the dialog or -1 in case of an error.Note. If the return value is sim_dlgret_still_open, the dialog was not closed and no button was pressed. Otherwise, you should free resources with simEndDialog (the dialog might not be visible anymore, but is still present)result of the dialog or -1 in case of an error.Note. If the return value is sim_dlgret_still_open, the dialog was not closed and no button was pressed. Otherwise, you should free resources with simEndDialog (the dialog might not be visible anymore, but is still present)"
    }, 
    "sim.breakForceSensor": {
        "body": "sim.breakForceSensor(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.breakForceSensor", 
        "description": "number result = sim.breakForceSensor(number objectHandle)Allows breaking a force sensor during simulation. A broken force sensor will lose its positional and orientational constraints. See also sim.readForceSensor. objectHandle: handle of the object (must be a force sensor)objectHandle: handle of the object (must be a force sensor) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.vortex_joint_motorfrictionenabled": {
        "body": "sim.vortex_joint_motorfrictionenabled", 
        "scope": "source.lua", 
        "prefix": "sim.vortex_joint_motorfrictionenabled", 
        "description": "Constants"
    }, 
    "sim.getInt32Parameter": {
        "body": "sim.getInt32Parameter(${0:parameter})", 
        "scope": "source.lua", 
        "prefix": "sim.getInt32Parameter", 
        "description": "number intState = sim.getInt32Parameter(number parameter)Retrieves an integer value. See the integer parameter identifiers. See also sim.setInt32Parameter, sim.getBoolParameter, sim.getFloatParameter, sim.getArrayParameter and sim.getStringParameter. parameter: integer parameter identifierintState: value of the parameterparameter: integer parameter identifierintState: value of the parameterparameter: integer parameter identifierintState: value of the parameter -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.packFloatTable": {
        "body": "sim.packFloatTable(${0:floatNumbers},${1:startFloatIndex=0},${2:floatCount=0})", 
        "scope": "source.lua", 
        "prefix": "sim.packFloatTable", 
        "description": "string data = sim.packFloatTable(table floatNumbers,number startFloatIndex=0,number floatCount=0)Packs a table of floating-point numbers into a string. See also sim.unpackFloatTable and the other packing/unpacking functions. - -"
    }, 
    "sim.banner_right": {
        "body": "sim.banner_right", 
        "scope": "source.lua", 
        "prefix": "sim.banner_right", 
        "description": "Constants"
    }, 
    "simK3.setGripperGap": {
        "body": "simK3.setGripperGap(${0:k3Handle},${1:gap})", 
        "scope": "source.lua", 
        "prefix": "simK3.setGripperGap", 
        "description": "boolean result = simK3.setGripperGap(number k3Handle,number gap)"
    }, 
    "sim.readForceSensor": {
        "body": "sim.readForceSensor(${0:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.readForceSensor", 
        "description": "number result,table_3 forceVector,table_3 torqueVector = sim.readForceSensor(number objectHandle)Reads the force and torque applied to a force sensor (filtered values are read), and its current state ('unbroken' or 'broken'). See also sim.breakForceSensor and sim.getJointForce. objectHandle: handle of the object (must be a force sensor). Can be combined with sim_handleflag_rawvalue (simply add sim_handleflag_rawvalue to objectHandle), if you wish to access the raw values generated by each individual dynamic simulation step (by default, there are 10 dynamic simulation steps for each simulation step). Raw values can only be accessed from inside a callback function triggered by the physics engine.forceVector: pointer to 3 values (applied forces along the sensor's x, y and z-axes). Can be NULLtorqueVector: pointer to 3 values (applied torques about the sensor's x, y and z-axes). Can be NULLobjectHandle: handle of the object (must be a force sensor). Can be combined with sim_handleflag_rawvalue (simply add sim_handleflag_rawvalue to objectHandle), if you wish to access the raw values generated by each individual dynamic simulation step (by default, there are 10 dynamic simulation steps for each simulation step). Raw values can only be accessed from inside a callback function triggered by the physics engine.forceVector: pointer to 3 values (applied forces along the sensor's x, y and z-axes). Can be NULLtorqueVector: pointer to 3 values (applied torques about the sensor's x, y and z-axes). Can be NULLobjectHandle: handle of the object (must be a force sensor). Can be combined with sim_handleflag_rawvalue (simply add sim_handleflag_rawvalue to objectHandle), if you wish to access the raw values generated by each individual dynamic simulation step (by default, there are 10 dynamic simulation steps for each simulation step). Raw values can only be accessed from inside a callback function triggered by the physics engine.forceVector: pointer to 3 values (applied forces along the sensor's x, y and z-axes). Can be NULLtorqueVector: pointer to 3 values (applied torques about the sensor's x, y and z-axes). Can be NULLobjectHandle: handle of the object (must be a force sensor). Can be combined with sim_handleflag_rawvalue (simply add sim_handleflag_rawvalue to objectHandle), if you wish to access the raw values generated by each individual dynamic simulation step (by default, there are 10 dynamic simulation steps for each simulation step). Raw values can only be accessed from inside a callback function triggered by the physics engine.forceVector: pointer to 3 values (applied forces along the sensor's x, y and z-axes). Can be NULLtorqueVector: pointer to 3 values (applied torques about the sensor's x, y and z-axes). Can be NULL -1 in case of an error, otherwise bit-coded:bit 0 set (1): force and torque data is available, otherwise it is not (yet) available (e.g. when not enough values are present for the filter)bit 1 set (2): force sensor is broken, otherwise it is still intact ('unbroken')-1 in case of an error, otherwise bit-coded:bit 0 set (1): force and torque data is available, otherwise it is not (yet) available (e.g. when not enough values are present for the filter)bit 1 set (2): force sensor is broken, otherwise it is still intact ('unbroken')-1 in case of an error, otherwise bit-coded:bit 0 set (1): force and torque data is available, otherwise it is not (yet) available (e.g. when not enough values are present for the filter)bit 1 set (2): force sensor is broken, otherwise it is still intact ('unbroken')"
    }, 
    "math.cos": {
        "body": "math.cos( ${1:x} )", 
        "scope": "source.lua", 
        "prefix": "math.cos", 
        "description": "5.1,5.2,5.3\n\nmath.cos"
    }, 
    "simUI.line_style.solid": {
        "body": "simUI.line_style.solid", 
        "scope": "source.lua", 
        "prefix": "simUI.line_style.solid", 
        "description": "Constants"
    }, 
    "simRRS1.SELECT_WEAVING_MODE": {
        "body": "simRRS1.SELECT_WEAVING_MODE(${0:rcsHandle})", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SELECT_WEAVING_MODE", 
        "description": "int status= simRRS1.SELECT_WEAVING_MODE(bitstring2 rcsHandle)"
    }, 
    "simRRS1.SAVE_RCS_DATA": {
        "body": "simRRS1.SAVE_RCS_DATA()", 
        "scope": "source.lua", 
        "prefix": "simRRS1.SAVE_RCS_DATA", 
        "description": "int status= simRRS1.SAVE_RCS_DATA()"
    }, 
    "io.close": {
        "body": "io.close(${0:...})", 
        "scope": "source.lua", 
        "prefix": "io.close", 
        "description": "5.1,5.2,5.3\n\nio.close ([file])"
    }, 
    "sim.getPositionOnPath": {
        "body": "sim.getPositionOnPath(${0:pathHandle},${1:relativeDistance})", 
        "scope": "source.lua", 
        "prefix": "sim.getPositionOnPath", 
        "description": "table_3 position = sim.getPositionOnPath(number pathHandle,number relativeDistance)Retrieves the absolute interpolated position of a point along a path object. See also sim.getOrientationOnPath, sim.getDataOnPath, sim.getPathPosition and sim.getClosestPositionOnPath. pathHandle: handle of the path objectrelativeDistance: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate path length calculation method. See also simGetPathLength.  In order to retrieve the position that lies exactly on a specific path control point, specify following for relativeDistance: -ctrlPtIndex-1 (the value will be rounded appropriately).position: pointer to 3 values (x, y and z)pathHandle: handle of the path objectrelativeDistance: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate path length calculation method. See also simGetPathLength.  In order to retrieve the position that lies exactly on a specific path control point, specify following for relativeDistance: -ctrlPtIndex-1 (the value will be rounded appropriately).position: pointer to 3 values (x, y and z)pathHandle: handle of the path objectrelativeDistance: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate path length calculation method. See also simGetPathLength.  In order to retrieve the position that lies exactly on a specific path control point, specify following for relativeDistance: -ctrlPtIndex-1 (the value will be rounded appropriately).position: pointer to 3 values (x, y and z)pathHandle: handle of the path objectrelativeDistance: a value between 0 and 1, where 0 is the beginning of the path, and 1 the end of the path. Make sure you selected the appropriate path length calculation method. See also simGetPathLength.  In order to retrieve the position that lies exactly on a specific path control point, specify following for relativeDistance: -ctrlPtIndex-1 (the value will be rounded appropriately).position: pointer to 3 values (x, y and z) -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.buttonproperty_button": {
        "body": "sim.buttonproperty_button", 
        "scope": "source.lua", 
        "prefix": "sim.buttonproperty_button", 
        "description": "Constants"
    }, 
    "sim.scriptattribute_executioncount": {
        "body": "sim.scriptattribute_executioncount", 
        "scope": "source.lua", 
        "prefix": "sim.scriptattribute_executioncount", 
        "description": "Constants"
    }, 
    "sim.addObjectToSelection": {
        "body": "sim.addObjectToSelection(${0:what},${1:objectHandle})", 
        "scope": "source.lua", 
        "prefix": "sim.addObjectToSelection", 
        "description": "number result = sim.addObjectToSelection(number what,number objectHandle)Adds an object to the selection. See also sim.removeObjectFromSelection and sim.getObjectSelection. what: indicates what we want to add. Valid values are sim_handle_single (adds just one object), sim_handle_all (adds all objects in the scene), sim_handle_tree (adds the tree with base objectHandle (inclusive)) and sim_handle_chain (adds the chain with tip objectHandle (inclusive))objectHandle: handle of an object. Doesn't have a meaning if what is sim_handle_allwhat: indicates what we want to add. Valid values are sim_handle_single (adds just one object), sim_handle_all (adds all objects in the scene), sim_handle_tree (adds the tree with base objectHandle (inclusive)) and sim_handle_chain (adds the chain with tip objectHandle (inclusive))objectHandle: handle of an object. Doesn't have a meaning if what is sim_handle_allwhat: indicates what we want to add. Valid values are sim_handle_single (adds just one object), sim_handle_all (adds all objects in the scene), sim_handle_tree (adds the tree with base objectHandle (inclusive)) and sim_handle_chain (adds the chain with tip objectHandle (inclusive))objectHandle: handle of an object. Doesn't have a meaning if what is sim_handle_all -1 if operation was not successful. In a future release, a more differentiated return value might be available"
    }, 
    "sim.ode_global_quickstep": {
        "body": "sim.ode_global_quickstep", 
        "scope": "source.lua", 
        "prefix": "sim.ode_global_quickstep", 
        "description": "Constants"
    }
}